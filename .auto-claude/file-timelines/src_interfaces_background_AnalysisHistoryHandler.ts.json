{
  "file_path": "src/interfaces/background/AnalysisHistoryHandler.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * Analysis History Handler Service\n *\n * Handles automatic saving of email analysis results to history.\n *\n * This service:\n * - Listens for EmailAnalyzedEvent events\n * - Saves analysis results (including confidence scores) to persistent storage\n * - Manages event listener registration/deregistration\n * - Coordinates with EventBus and AnalysisHistoryRepository\n *\n * @module interfaces/background/AnalysisHistoryHandler\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IAnalysisHistoryRepository } from '@/infrastructure/interfaces/IAnalysisHistoryRepository';\nimport type { IMailReader } from '@/infrastructure/interfaces/IMailReader';\nimport { EventBus } from '@/domain/events/EventBus';\nimport type { EmailAnalyzedEvent } from '@/domain/events/EmailAnalyzedEvent';\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Event handler state.\n */\ninterface HandlerState {\n  /** Whether handlers are registered */\n  isRegistered: boolean;\n  /** Number of analysis records saved */\n  recordsSaved: number;\n  /** Number of errors encountered */\n  errorsEncountered: number;\n}\n\n// ============================================================================\n// Service Implementation\n// ============================================================================\n\n/**\n * Analysis History Handler Service\n *\n * Listens for EmailAnalyzedEvent and saves results to persistent storage.\n * Manages automatic analysis history tracking.\n *\n * @example\n * ```typescript\n * const service = container.resolve<AnalysisHistoryHandler>(AnalysisHistoryHandler);\n *\n * // Start handling analysis events\n * service.start();\n *\n * // Later, stop handling\n * service.stop();\n * ```\n */\n@injectable()\nexport class AnalysisHistoryHandler {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private readonly historyRepository: IAnalysisHistoryRepository;\n  private readonly mailReader: IMailReader;\n  private readonly logger: ILogger;\n  private readonly eventBus: EventBus;\n\n  private handlerState: HandlerState = {\n    isRegistered: false,\n    recordsSaved: 0,\n    errorsEncountered: 0,\n  };\n\n  // Cached unsubscribe function for proper cleanup\n  private unsubscribeFn: (() => void) | null = null;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  /**\n   * Creates a new AnalysisHistoryHandler instance.\n   *\n   * @param historyRepository - Repository for persisting analysis history\n   * @param mailReader - Mail reader for accessing email message metadata\n   * @param logger - Logger instance for logging operations\n   * @param eventBus - Event bus for subscribing to analysis events\n   */\n  constructor(\n    @inject('IAnalysisHistoryRepository') historyRepository: IAnalysisHistoryRepository,\n    @inject('IMailReader') mailReader: IMailReader,\n    @inject('ILogger') logger: ILogger,\n    @inject(EventBus) eventBus: EventBus\n  ) {\n    this.historyRepository = historyRepository;\n    this.mailReader = mailReader;\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.logger.debug('AnalysisHistoryHandler service initialized');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Registers event listeners.\n   *\n   * Sets up handlers for EmailAnalyzedEvent.\n   */\n  async registerListeners(): Promise<void> {\n    if (this.handlerState.isRegistered) {\n      this.logger.warn('Event listeners already registered');\n      return;\n    }\n\n    this.logger.info('Registering analysis history event listeners');\n\n    // Register EmailAnalyzedEvent handler\n    this.unsubscribeFn = this.eventBus.subscribe<EmailAnalyzedEvent>(\n      'EmailAnalyzed',\n      this.onEmailAnalyzed.bind(this)\n    );\n\n    this.handlerState.isRegistered = true;\n    this.logger.info('Analysis history event listener registered');\n  }\n\n  /**\n   * Unregisters event listeners.\n   *\n   * Removes all registered event handlers.\n   */\n  async unregisterListeners(): Promise<void> {\n    if (!this.handlerState.isRegistered) {\n      this.logger.debug('Event listeners not registered');\n      return;\n    }\n\n    this.logger.info('Unregistering analysis history event listeners');\n\n    // Unregister EmailAnalyzedEvent handler\n    if (this.unsubscribeFn) {\n      this.unsubscribeFn();\n      this.unsubscribeFn = null;\n      this.logger.info('Analysis history event listener unregistered');\n    }\n\n    this.handlerState.isRegistered = false;\n    this.logger.info('Analysis history event listeners unregistered');\n  }\n\n  /**\n   * Starts the event handler service.\n   *\n   * Registers all event listeners and begins tracking analysis history.\n   */\n  async start(): Promise<void> {\n    this.logger.info('Starting analysis history handler service');\n    await this.registerListeners();\n  }\n\n  /**\n   * Stops the event handler service.\n   *\n   * Unregisters all event listeners and stops tracking analysis history.\n   */\n  async stop(): Promise<void> {\n    this.logger.info('Stopping analysis history handler service');\n    await this.unregisterListeners();\n  }\n\n  /**\n   * Gets current handler state.\n   *\n   * @returns Current state of event handlers\n   */\n  getState(): HandlerState {\n    return { ...this.handlerState };\n  }\n\n  // ==========================================================================\n  // Private Methods\n  // ==========================================================================\n\n  /**\n   * Handler for EmailAnalyzedEvent.\n   *\n   * Saves analysis results (including confidence scores) to persistent storage.\n   *\n   * @param event - Email analyzed event\n   */\n  private async onEmailAnalyzed(event: EmailAnalyzedEvent): Promise<void> {\n    this.logger.debug('EmailAnalyzedEvent received', {\n      messageId: event.messageId,\n      providerId: event.providerId,\n      model: event.model,\n      fromCache: event.fromCache,\n    });\n\n    try {\n      // Get email message details for enrichment\n      let emailSubject = '';\n      let emailFrom = '';\n      let emailSender: string | undefined = undefined;\n      let senderConsistent: boolean | null | undefined = undefined;\n\n      try {\n        const messageIdNum = parseInt(event.messageId, 10);\n        if (!isNaN(messageIdNum)) {\n          const email = await this.mailReader.getFullMessage(messageIdNum);\n          if (email) {\n            emailSubject = email.subject || '';\n            emailFrom = email.from || '';\n\n            // Extract sender metadata from event result if available\n            emailSender = event.result.sender;\n            senderConsistent = event.result.sender_consistent;\n          }\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        this.logger.warn('Failed to get email message details', {\n          messageId: event.messageId,\n          error: errorMessage,\n        });\n        // Continue with empty values - non-fatal error\n      }\n\n      // Create analysis history record\n      const record = {\n        id: this.generateRecordId(),\n        messageId: event.messageId,\n        subject: emailSubject,\n        from: emailFrom,\n        tags: event.result.tags,\n        confidence_score: event.result.confidence_score,\n        confidence: event.result.confidence,\n        reasoning: event.result.reasoning,\n        provider: event.providerId,\n        model: event.model,\n        timestamp: event.timestamp,\n        is_scam: event.result.is_scam,\n        sender: emailSender,\n        sender_consistent: senderConsistent,\n        spf_pass: event.result.spf_pass,\n        dkim_pass: event.result.dkim_pass,\n        from_cache: event.fromCache,\n        cache_key: event.cacheKey,\n        duration_ms: event.duration || 0,\n      };\n\n      // Save to repository\n      await this.historyRepository.saveAnalysis(record);\n\n      this.handlerState.recordsSaved++;\n\n      this.logger.debug('Analysis record saved successfully', {\n        recordId: record.id,\n        messageId: event.messageId,\n        confidence_score: event.result.confidence_score,\n        tags: event.result.tags,\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save analysis record', {\n        messageId: event.messageId,\n        error: errorMessage,\n      });\n\n      this.handlerState.errorsEncountered++;\n      // Don't throw - continue processing other events\n    }\n  }\n\n  /**\n   * Generates a unique record ID.\n   *\n   * @returns Unique record ID\n   */\n  private generateRecordId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n  }\n}\n",
        "last_modified": "2026-01-05T19:59:00.210899"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.128026",
  "last_updated": "2026-01-05T14:48:03.131270"
}