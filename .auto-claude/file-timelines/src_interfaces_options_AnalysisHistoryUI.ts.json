{
  "file_path": "src/interfaces/options/AnalysisHistoryUI.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * Analysis History UI Component\n *\n * Displays confidence trends and statistics for email analysis history.\n * Shows average confidence, distribution charts, per-tag statistics, and trends over time.\n *\n * @module interfaces/options/AnalysisHistoryUI\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { IAnalysisHistoryRepository } from '@/infrastructure/interfaces/IAnalysisHistoryRepository';\nimport type {\n  IAnalysisHistoryRecord,\n  IAnalysisHistoryStats,\n} from '@/infrastructure/interfaces/IAnalysisHistoryRepository';\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\n\n// ============================================================================\n// DOM Element Interfaces\n// ============================================================================\n\n/**\n * Analysis History DOM Elements\n */\ninterface AnalysisHistoryElements {\n  container: HTMLDivElement;\n  statsContainer: HTMLDivElement;\n  refreshBtn: HTMLButtonElement;\n  providerFilter: HTMLSelectElement;\n  tagFilter: HTMLSelectElement;\n  dateRangeFilter: HTMLSelectElement;\n}\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Filter options for analysis history\n */\ninterface AnalysisHistoryFilters {\n  provider: string;\n  tag: string;\n  dateRange: string;\n}\n\n/**\n * Confidence distribution bucket\n */\ninterface ConfidenceDistribution {\n  range: string;\n  count: number;\n  percentage: number;\n}\n\n/**\n * Per-tag confidence statistics\n */\ninterface TagConfidenceStats {\n  tag: string;\n  count: number;\n  avgConfidence: number;\n  minConfidence: number;\n  maxConfidence: number;\n}\n\n/**\n * Confidence trend data point\n */\ninterface TrendDataPoint {\n  date: string;\n  avgConfidence: number;\n  count: number;\n}\n\n// ============================================================================\n// Analysis History UI Implementation\n// ============================================================================\n\n/**\n * Analysis History UI Component\n *\n * Displays statistics and visualizations for email analysis confidence scores.\n * Shows overall statistics, confidence distribution, per-tag statistics, and trends over time.\n *\n * @example\n * ```typescript\n * const historyUI = container.resolve<AnalysisHistoryUI>(AnalysisHistoryUI);\n * await historyUI.loadAnalysisHistory();\n * historyUI.render();\n * ```\n */\n@injectable()\nexport class AnalysisHistoryUI {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private readonly analysisHistoryRepository: IAnalysisHistoryRepository;\n  private readonly logger: ILogger;\n  private elements: AnalysisHistoryElements | null = null;\n  private currentRecords: IAnalysisHistoryRecord[] = [];\n  private filters: AnalysisHistoryFilters = {\n    provider: 'all',\n    tag: 'all',\n    dateRange: 'all',\n  };\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor(\n    @inject('IAnalysisHistoryRepository') analysisHistoryRepository: IAnalysisHistoryRepository,\n    @inject('ILogger') logger: ILogger\n  ) {\n    this.analysisHistoryRepository = analysisHistoryRepository;\n    this.logger = logger;\n    this.logger.debug('AnalysisHistoryUI initialized');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Renders the analysis history UI to the DOM.\n   *\n   * Sets up event listeners for filters and refresh.\n   */\n  render(): void {\n    this.logger.debug('Rendering analysis history UI');\n\n    this.elements = this.getDOMElements();\n\n    // Setup filter change handlers\n    this.elements.providerFilter.addEventListener('change', () => {\n      this.filters.provider = this.elements!.providerFilter.value;\n      this.loadAndRenderData();\n    });\n\n    this.elements.tagFilter.addEventListener('change', () => {\n      this.filters.tag = this.elements!.tagFilter.value;\n      this.loadAndRenderData();\n    });\n\n    this.elements.dateRangeFilter.addEventListener('change', () => {\n      this.filters.dateRange = this.elements!.dateRangeFilter.value;\n      this.loadAndRenderData();\n    });\n\n    // Setup refresh button\n    this.elements.refreshBtn.addEventListener('click', () => {\n      this.loadAndRenderData();\n    });\n\n    this.logger.debug('Analysis history UI rendered');\n  }\n\n  /**\n   * Loads analysis history data and renders visualizations.\n   */\n  async loadAnalysisHistory(): Promise<void> {\n    this.logger.debug('Loading analysis history');\n\n    try {\n      await this.loadAndRenderData();\n      this.logger.debug('Analysis history loaded successfully');\n    } catch (error) {\n      this.logger.error('Failed to load analysis history', { error });\n      this.showError('Fehler beim Laden der Analyse-Historie');\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods\n  // ==========================================================================\n\n  /**\n   * Gets DOM elements for analysis history UI.\n   */\n  private getDOMElements(): AnalysisHistoryElements {\n    const container = document.getElementById('analysis-history-container') as HTMLDivElement;\n    const statsContainer = document.getElementById('analysis-history-stats') as HTMLDivElement;\n    const refreshBtn = document.getElementById('refresh-analysis-history-btn') as HTMLButtonElement;\n    const providerFilter = document.getElementById('history-provider-filter') as HTMLSelectElement;\n    const tagFilter = document.getElementById('history-tag-filter') as HTMLSelectElement;\n    const dateRangeFilter = document.getElementById('history-date-range-filter') as HTMLSelectElement;\n\n    if (!container || !statsContainer || !refreshBtn || !providerFilter || !tagFilter || !dateRangeFilter) {\n      throw new Error('Required analysis history DOM elements not found');\n    }\n\n    return { container, statsContainer, refreshBtn, providerFilter, tagFilter, dateRangeFilter };\n  }\n\n  /**\n   * Loads data from repository and renders all visualizations.\n   */\n  private async loadAndRenderData(): Promise<void> {\n    // Build query from filters\n    const query = this.buildQuery();\n\n    // Fetch records\n    this.currentRecords = await this.analysisHistoryRepository.queryAnalysisHistory(query);\n\n    // Render all sections\n    this.renderFilters();\n    this.renderStatistics();\n    this.renderConfidenceDistribution();\n    this.renderPerTagStatistics();\n    this.renderConfidenceTrend();\n  }\n\n  /**\n   * Builds query object from current filters.\n   */\n  private buildQuery(): any {\n    const query: any = {};\n\n    // Provider filter\n    if (this.filters.provider !== 'all') {\n      query.provider = this.filters.provider;\n    }\n\n    // Tag filter\n    if (this.filters.tag !== 'all') {\n      query.hasTag = this.filters.tag;\n    }\n\n    // Date range filter\n    if (this.filters.dateRange !== 'all') {\n      const now = new Date();\n      const startDate = new Date();\n\n      switch (this.filters.dateRange) {\n        case '7d':\n          startDate.setDate(now.getDate() - 7);\n          break;\n        case '30d':\n          startDate.setDate(now.getDate() - 30);\n          break;\n        case '90d':\n          startDate.setDate(now.getDate() - 90);\n          break;\n        case '1y':\n          startDate.setFullYear(now.getFullYear() - 1);\n          break;\n      }\n\n      query.startDate = startDate.toISOString();\n    }\n\n    return query;\n  }\n\n  /**\n   * Renders filter dropdowns with available options.\n   */\n  private renderFilters(): void {\n    // Get unique providers\n    const providers = new Set(this.currentRecords.map((r) => r.provider));\n    const providerFilter = this.elements!.providerFilter;\n\n    // Save current selection\n    const currentValue = providerFilter.value;\n\n    // Clear and repopulate\n    providerFilter.innerHTML = '<option value=\"all\">Alle Provider</option>';\n    providers.forEach((provider) => {\n      const option = document.createElement('option');\n      option.value = provider;\n      option.textContent = provider;\n      providerFilter.appendChild(option);\n    });\n\n    // Restore selection if still valid\n    if (Array.from(providers).includes(currentValue) || currentValue === 'all') {\n      providerFilter.value = currentValue;\n    }\n\n    // Get unique tags\n    const tags = new Set<string>();\n    this.currentRecords.forEach((record) => {\n      record.tags.forEach((tag) => tags.add(tag));\n    });\n\n    const tagFilter = this.elements!.tagFilter;\n    const currentTag = tagFilter.value;\n\n    tagFilter.innerHTML = '<option value=\"all\">Alle Tags</option>';\n    Array.from(tags).sort().forEach((tag) => {\n      const option = document.createElement('option');\n      option.value = tag;\n      option.textContent = tag;\n      tagFilter.appendChild(option);\n    });\n\n    if (Array.from(tags).includes(currentTag) || currentTag === 'all') {\n      tagFilter.value = currentTag;\n    }\n  }\n\n  /**\n   * Renders overall statistics section.\n   */\n  private renderStatistics(): void {\n    const statsContainer = this.elements!.statsContainer;\n\n    if (this.currentRecords.length === 0) {\n      statsContainer.innerHTML = '<p class=\"help-text\">Keine Analyse-Daten verf\u00fcgbar</p>';\n      return;\n    }\n\n    // Calculate statistics\n    const totalAnalyses = this.currentRecords.length;\n    const avgConfidence =\n      this.currentRecords.reduce((sum, r) => sum + r.confidence_score, 0) / totalAnalyses;\n\n    const highConfidence = this.currentRecords.filter((r) => r.confidence_score >= 80).length;\n    const mediumConfidence = this.currentRecords.filter(\n      (r) => r.confidence_score >= 60 && r.confidence_score < 80\n    ).length;\n    const lowConfidence = this.currentRecords.filter((r) => r.confidence_score < 60).length;\n\n    statsContainer.innerHTML = `\n      <div class=\"history-stats-grid\">\n        <div class=\"stat-card\">\n          <h3>Gesamtanalysen</h3>\n          <div class=\"stat-value\">${totalAnalyses}</div>\n        </div>\n        <div class=\"stat-card\">\n          <h3>Durchschnittliche Konfidenz</h3>\n          <div class=\"stat-value ${this.getConfidenceClass(avgConfidence)}\">${avgConfidence.toFixed(1)}%</div>\n        </div>\n        <div class=\"stat-card\">\n          <h3>Hohe Konfidenz (&ge;80%)</h3>\n          <div class=\"stat-value confidence-high\">${highConfidence}</div>\n          <div class=\"stat-label\">${((highConfidence / totalAnalyses) * 100).toFixed(1)}%</div>\n        </div>\n        <div class=\"stat-card\">\n          <h3>Mittlere Konfidenz (60-80%)</h3>\n          <div class=\"stat-value confidence-medium\">${mediumConfidence}</div>\n          <div class=\"stat-label\">${((mediumConfidence / totalAnalyses) * 100).toFixed(1)}%</div>\n        </div>\n        <div class=\"stat-card\">\n          <h3>Niedrige Konfidenz (&lt;60%)</h3>\n          <div class=\"stat-value confidence-low\">${lowConfidence}</div>\n          <div class=\"stat-label\">${((lowConfidence / totalAnalyses) * 100).toFixed(1)}%</div>\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * Renders confidence distribution histogram.\n   */\n  private renderConfidenceDistribution(): void {\n    const container = this.elements!.container;\n\n    if (this.currentRecords.length === 0) {\n      return;\n    }\n\n    // Create distribution buckets\n    const buckets: ConfidenceDistribution[] = [\n      { range: '0-20%', count: 0, percentage: 0 },\n      { range: '20-40%', count: 0, percentage: 0 },\n      { range: '40-60%', count: 0, percentage: 0 },\n      { range: '60-80%', count: 0, percentage: 0 },\n      { range: '80-100%', count: 0, percentage: 0 },\n    ];\n\n    // Fill buckets\n    this.currentRecords.forEach((record) => {\n      const confidence = record.confidence_score;\n      if (confidence < 20) buckets[0].count++;\n      else if (confidence < 40) buckets[1].count++;\n      else if (confidence < 60) buckets[2].count++;\n      else if (confidence < 80) buckets[3].count++;\n      else buckets[4].count++;\n    });\n\n    // Calculate percentages\n    const total = this.currentRecords.length;\n    buckets.forEach((bucket) => {\n      bucket.percentage = (bucket.count / total) * 100;\n    });\n\n    // Create histogram HTML\n    const maxCount = Math.max(...buckets.map((b) => b.count));\n    const histogramHTML = `\n      <div class=\"history-section\">\n        <h3>Konfidenz-Verteilung</h3>\n        <div class=\"distribution-chart\">\n          ${buckets.map((bucket) => {\n            const width = maxCount > 0 ? (bucket.count / maxCount) * 100 : 0;\n            return `\n              <div class=\"distribution-bar\">\n                <div class=\"bar-label\">${bucket.range}</div>\n                <div class=\"bar-container\">\n                  <div class=\"bar-fill\" style=\"width: ${width}%\"></div>\n                </div>\n                <div class=\"bar-value\">${bucket.count} <span class=\"bar-percentage\">(${bucket.percentage.toFixed(1)}%)</span></div>\n              </div>\n            `;\n          }).join('')}\n        </div>\n      </div>\n    `;\n\n    container.innerHTML = histogramHTML;\n  }\n\n  /**\n   * Renders per-tag confidence statistics table.\n   */\n  private renderPerTagStatistics(): void {\n    const container = this.elements!.container;\n\n    if (this.currentRecords.length === 0) {\n      return;\n    }\n\n    // Calculate per-tag statistics\n    const tagStatsMap = new Map<string, { sum: number; count: number; min: number; max: number }>();\n\n    this.currentRecords.forEach((record) => {\n      record.tags.forEach((tag) => {\n        if (!tagStatsMap.has(tag)) {\n          tagStatsMap.set(tag, { sum: 0, count: 0, min: 100, max: 0 });\n        }\n        const stats = tagStatsMap.get(tag)!;\n        stats.sum += record.confidence_score;\n        stats.count++;\n        stats.min = Math.min(stats.min, record.confidence_score);\n        stats.max = Math.max(stats.max, record.confidence_score);\n      });\n    });\n\n    const tagStats: TagConfidenceStats[] = Array.from(tagStatsMap.entries())\n      .map(([tag, stats]) => ({\n        tag,\n        count: stats.count,\n        avgConfidence: stats.sum / stats.count,\n        minConfidence: stats.min,\n        maxConfidence: stats.max,\n      }))\n      .sort((a, b) => b.count - a.count);\n\n    if (tagStats.length === 0) {\n      return;\n    }\n\n    const tableHTML = `\n      <div class=\"history-section\">\n        <h3>Tag-Statistiken</h3>\n        <div class=\"table-responsive\">\n          <table class=\"stats-table\">\n            <thead>\n              <tr>\n                <th>Tag</th>\n                <th>Anzahl</th>\n                <th>Durchschnittliche Konfidenz</th>\n                <th>Min</th>\n                <th>Max</th>\n              </tr>\n            </thead>\n            <tbody>\n              ${tagStats.map((stat) => `\n                <tr>\n                  <td>${this.escapeHtml(stat.tag)}</td>\n                  <td>${stat.count}</td>\n                  <td>\n                    <span class=\"${this.getConfidenceClass(stat.avgConfidence)}\">\n                      ${stat.avgConfidence.toFixed(1)}%\n                    </span>\n                  </td>\n                  <td>${stat.minConfidence.toFixed(1)}%</td>\n                  <td>${stat.maxConfidence.toFixed(1)}%</td>\n                </tr>\n              `).join('')}\n            </tbody>\n          </table>\n        </div>\n      </div>\n    `;\n\n    container.innerHTML += tableHTML;\n  }\n\n  /**\n   * Renders confidence trend over time as a line chart.\n   */\n  private renderConfidenceTrend(): void {\n    const container = this.elements!.container;\n\n    if (this.currentRecords.length < 2) {\n      return;\n    }\n\n    // Group records by date\n    const dateMap = new Map<string, { sum: number; count: number }>();\n\n    this.currentRecords.forEach((record) => {\n      const date = new Date(record.timestamp).toISOString().split('T')[0];\n      if (!dateMap.has(date)) {\n        dateMap.set(date, { sum: 0, count: 0 });\n      }\n      const stats = dateMap.get(date)!;\n      stats.sum += record.confidence_score;\n      stats.count++;\n    });\n\n    // Convert to trend data points and sort by date\n    const trendData: TrendDataPoint[] = Array.from(dateMap.entries())\n      .map(([date, stats]) => ({\n        date,\n        avgConfidence: stats.sum / stats.count,\n        count: stats.count,\n      }))\n      .sort((a, b) => a.date.localeCompare(b.date));\n\n    // Take last 30 data points to avoid overcrowding\n    const displayData = trendData.slice(-30);\n\n    const trendHTML = `\n      <div class=\"history-section\">\n        <h3>Konfidenz-Trend</h3>\n        <canvas id=\"trend-chart\" class=\"trend-chart\"></canvas>\n      </div>\n    `;\n\n    container.innerHTML += trendHTML;\n\n    // Draw chart after adding to DOM\n    setTimeout(() => {\n      this.drawTrendChart(displayData);\n    }, 0);\n  }\n\n  /**\n   * Draws trend chart on canvas element.\n   */\n  private drawTrendChart(data: TrendDataPoint[]): void {\n    const canvas = document.getElementById('trend-chart') as HTMLCanvasElement;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Set canvas size\n    const width = canvas.parentElement!.clientWidth - 40;\n    const height = 300;\n    canvas.width = width;\n    canvas.height = height;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n\n    // Chart margins\n    const margin = { top: 20, right: 20, bottom: 40, left: 50 };\n    const chartWidth = width - margin.left - margin.right;\n    const chartHeight = height - margin.top - margin.bottom;\n\n    // Find min/max values\n    const minConfidence = Math.min(...data.map((d) => d.avgConfidence));\n    const maxConfidence = Math.max(...data.map((d) => d.avgConfidence));\n    const confidenceRange = maxConfidence - minConfidence || 1;\n\n    // Draw grid lines and Y-axis labels\n    ctx.strokeStyle = '#e0e0e0';\n    ctx.fillStyle = '#666';\n    ctx.font = '12px sans-serif';\n    ctx.textAlign = 'right';\n\n    for (let i = 0; i <= 4; i++) {\n      const y = margin.top + (chartHeight / 4) * i;\n      const value = maxConfidence - (confidenceRange / 4) * i;\n\n      ctx.beginPath();\n      ctx.moveTo(margin.left, y);\n      ctx.lineTo(margin.left + chartWidth, y);\n      ctx.stroke();\n\n      ctx.fillText(`${value.toFixed(0)}%`, margin.left - 10, y + 4);\n    }\n\n    // Draw trend line\n    ctx.strokeStyle = '#3498DB';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n\n    data.forEach((point, index) => {\n      const x = margin.left + (chartWidth / (data.length - 1)) * index;\n      const y = margin.top + chartHeight - ((point.avgConfidence - minConfidence) / confidenceRange) * chartHeight;\n\n      if (index === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    });\n\n    ctx.stroke();\n\n    // Draw data points\n    ctx.fillStyle = '#3498DB';\n    data.forEach((point, index) => {\n      const x = margin.left + (chartWidth / (data.length - 1)) * index;\n      const y = margin.top + chartHeight - ((point.avgConfidence - minConfidence) / confidenceRange) * chartHeight;\n\n      ctx.beginPath();\n      ctx.arc(x, y, 4, 0, 2 * Math.PI);\n      ctx.fill();\n\n      // Add tooltip on hover (simplified - just show date labels)\n      if (data.length <= 10 || index % Math.ceil(data.length / 10) === 0) {\n        ctx.fillStyle = '#666';\n        ctx.textAlign = 'center';\n        ctx.fillText(this.formatDate(point.date), x, margin.top + chartHeight + 20);\n        ctx.fillStyle = '#3498DB';\n      }\n    });\n  }\n\n  /**\n   * Formats date for display.\n   */\n  private formatDate(isoDate: string): string {\n    const date = new Date(isoDate);\n    return date.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit' });\n  }\n\n  /**\n   * Gets CSS class for confidence level.\n   */\n  private getConfidenceClass(confidence: number): string {\n    if (confidence >= 80) return 'confidence-high';\n    if (confidence >= 60) return 'confidence-medium';\n    return 'confidence-low';\n  }\n\n  /**\n   * Escapes HTML to prevent XSS.\n   */\n  private escapeHtml(text: string): string {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  /**\n   * Shows an error message to the user.\n   */\n  private showError(message: string): void {\n    const overlay = document.getElementById('error-display-overlay') as HTMLDivElement;\n    const messageEl = document.getElementById('error-display-message') as HTMLParagraphElement;\n\n    if (overlay && messageEl) {\n      messageEl.textContent = message;\n      overlay.style.display = 'block';\n    } else {\n      alert(message);\n    }\n  }\n}\n",
        "last_modified": "2026-01-05T19:59:00.212079"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.119296",
  "last_updated": "2026-01-05T14:48:03.122579"
}