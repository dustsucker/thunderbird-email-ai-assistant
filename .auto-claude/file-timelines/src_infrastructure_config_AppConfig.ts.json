{
  "file_path": "src/infrastructure/config/AppConfig.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "import { singleton, inject } from 'tsyringe';\nimport {\n  Tag,\n  HardcodedTags,\n  CustomTags,\n  Provider,\n  AppConfig,\n  DefaultConfig,\n  ModelConcurrencyConfig,\n} from '@/shared/types/ProviderTypes';\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Cached configuration with timestamp.\n */\ninterface CachedConfig<T> {\n  /** Cached value */\n  value: T;\n  /** Cache timestamp */\n  timestamp: number;\n}\n\n/**\n * Cache entry with TTL.\n */\ninterface CacheEntry {\n  /** Cached configuration */\n  config: CachedConfig<unknown>;\n  /** Time-to-live in milliseconds */\n  ttl: number;\n}\n\n// ============================================================================\n// AppConfigService Implementation\n// ============================================================================\n\n/**\n * Configuration service with caching.\n *\n * Provides access to application configuration with in-memory caching\n * to improve performance. Falls back to defaults if ConfigRepository is unavailable.\n */\n@singleton()\nexport class AppConfigService {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private readonly configRepository: IConfigRepository;\n  private readonly logger: ILogger;\n\n  /** In-memory cache for configurations */\n  private readonly cache: Map<string, CacheEntry> = new Map();\n\n  /** Default cache TTL: 5 minutes */\n  private readonly DEFAULT_CACHE_TTL = 5 * 60 * 1000;\n\n  // Hardcoded tags (system tags that cannot be modified)\n  private readonly hardcodedTags: HardcodedTags = {\n    is_scam: { key: 'is_scam', name: 'Scam Alert', color: '#FF5722' },\n    spf_fail: { key: 'spf_fail', name: 'SPF Fail', color: '#E91E63' },\n    dkim_fail: { key: 'dkim_fail', name: 'DKIM Fail', color: '#E91E63' },\n    tagged: { key: 'tagged', name: 'Tagged', color: '#4f4f4f' },\n    email_ai_analyzed: { key: 'email_ai_analyzed', name: 'AI Analyzed', color: '#9E9E9E' },\n  };\n\n  private readonly defaultCustomTags: CustomTags = [\n    {\n      key: 'is_advertise',\n      name: 'Advertisement',\n      color: '#FFC107',\n      prompt:\n        'check if email is advertising something and contains an offer or someone is asking for contact to show the offer',\n    },\n    {\n      key: 'is_business_approach',\n      name: 'Business Ad',\n      color: '#2196F3',\n      prompt:\n        'check if email is a cold marketing/sales/business approach (or next message in the approach process where sender reply to self to refresh the approach in the mailbox). Consider typical sales and lead generation scenarios.',\n    },\n    {\n      key: 'is_personal',\n      name: 'Personal',\n      color: '#4CAF50',\n      prompt:\n        'check if this is non-sales scenario approach from someone who likes to contact in a non-business context.',\n    },\n    {\n      key: 'is_business',\n      name: 'Business',\n      color: '#af4c87',\n      prompt: 'check if this looks like work related email',\n    },\n    {\n      key: 'is_service_important',\n      name: 'Service Important',\n      color: '#F44336',\n      prompt:\n        'check if email contains important information related to already subscribed service (if this is subscription offer - ignore it): bill, password reset, login link, 2fa code, expiration notice. Consider common services like electricity, bank account, netflix, or similar subscription service.',\n    },\n    {\n      key: 'is_service_not_important',\n      name: 'Service Info',\n      color: '#9E9E9E',\n      prompt:\n        'check if email contains non critical information from already subscribed service (if this is subscription offer - ignore it) - like: daily posts update from linkedin, AWS invitation for conference, cross sale, tips how to use product, surveys, new offers',\n    },\n    {\n      key: 'is_bill',\n      name: 'Bill',\n      color: '#f4b136',\n      prompt: 'check if email contains bill or invoice information.',\n    },\n    {\n      key: 'has_calendar_invite',\n      name: 'Appointment',\n      color: '#7F07f2',\n      prompt:\n        'check if the mail has invitation to the call or meeting (with calendar appointment attached)',\n    },\n  ];\n\n  private readonly defaults: Readonly<DefaultConfig> = {\n    provider: Provider.OLLAMA,\n    ollamaApiUrl: 'http://localhost:11434/api/generate',\n    ollamaModel: 'gemma3:27b',\n    openaiApiKey: '',\n    geminiApiKey: '',\n    claudeApiKey: '',\n    mistralApiKey: '',\n    deepseekApiKey: '',\n    zaiPaasApiKey: '',\n    zaiPaasModel: 'glm-4.5',\n    zaiCodingApiKey: '',\n    zaiCodingModel: 'glm-4.7',\n    customTags: this.defaultCustomTags,\n    enableNotifications: true,\n    enableLogging: true,\n    model: undefined,\n    modelConcurrencyLimits: undefined,\n  };\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor(\n    @inject('ILogger') logger: ILogger,\n    @inject('IConfigRepository') configRepository: IConfigRepository\n  ) {\n    this.logger = logger;\n    this.configRepository = configRepository;\n    this.logger.debug('AppConfigService initialized with ConfigRepository');\n  }\n\n  // ==========================================================================\n  // Public Methods - ConfigRepository Integration\n  // ==========================================================================\n\n  /**\n   * Gets application configuration from ConfigRepository with caching.\n   *\n   * @returns Promise resolving to application config\n   */\n  async getAppConfig(): Promise<\n    import('@/infrastructure/interfaces/IConfigRepository').IAppConfig\n  > {\n    const cacheKey = 'appConfig';\n\n    // Check cache\n    const cached =\n      this.getFromCache<import('@/infrastructure/interfaces/IConfigRepository').IAppConfig>(\n        cacheKey\n      );\n    if (cached) {\n      this.logger.debug('AppConfig cache hit', { cacheKey });\n      return cached;\n    }\n\n    // Load from repository\n    try {\n      const config = await this.configRepository.getAppConfig();\n\n      // Cache the result\n      this.setInCache(cacheKey, config, this.DEFAULT_CACHE_TTL);\n\n      return config;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('Failed to load app config from repository, using fallback', {\n        error: errorMessage,\n      });\n\n      // Return fallback config\n      return {\n        defaultProvider: this.defaults.provider,\n        enableNotifications: this.defaults.enableNotifications,\n        enableLogging: this.defaults.enableLogging,\n        modelConcurrencyLimits: this.defaults.modelConcurrencyLimits,\n      };\n    }\n  }\n\n  /**\n   * Gets provider settings from ConfigRepository with caching.\n   *\n   * @param providerId - Provider identifier\n   * @returns Promise resolving to provider settings\n   */\n  async getProviderSettings(\n    providerId: string\n  ): Promise<import('@/infrastructure/interfaces/IConfigRepository').IProviderSettings> {\n    const cacheKey = `providerSettings:${providerId}`;\n\n    // Check cache\n    const cached =\n      this.getFromCache<import('@/infrastructure/interfaces/IConfigRepository').IProviderSettings>(\n        cacheKey\n      );\n    if (cached) {\n      this.logger.debug('ProviderSettings cache hit', { cacheKey, providerId });\n      return cached;\n    }\n\n    // Load from repository\n    try {\n      const settings = await this.configRepository.getProviderSettings(providerId);\n\n      // Cache the result\n      this.setInCache(cacheKey, settings, this.DEFAULT_CACHE_TTL);\n\n      return settings;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('Failed to load provider settings from repository, using fallback', {\n        providerId,\n        error: errorMessage,\n      });\n\n      // Return fallback settings based on provider\n      return this.getFallbackProviderSettings(providerId);\n    }\n  }\n\n  /**\n   * Gets custom tags from ConfigRepository with caching.\n   *\n   * @returns Promise resolving to custom tags array\n   */\n  async getCustomTags(): Promise<\n    import('@/infrastructure/interfaces/IConfigRepository').ICustomTag[]\n  > {\n    const cacheKey = 'customTags';\n\n    // Check cache\n    const cached =\n      this.getFromCache<import('@/infrastructure/interfaces/IConfigRepository').ICustomTag[]>(\n        cacheKey\n      );\n    if (cached) {\n      this.logger.debug('CustomTags cache hit', { cacheKey });\n      return cached;\n    }\n\n    // Load from repository\n    try {\n      const tags = await this.configRepository.getCustomTags();\n\n      // Cache the result\n      this.setInCache(cacheKey, tags, this.DEFAULT_CACHE_TTL);\n\n      return tags;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('Failed to load custom tags from repository, using defaults', {\n        error: errorMessage,\n      });\n\n      // Return default custom tags\n      return this.defaultCustomTags.map((tag) => ({\n        key: tag.key,\n        name: tag.name,\n        color: tag.color,\n        prompt: tag.prompt,\n      }));\n    }\n  }\n\n  /**\n   * Saves provider settings to ConfigRepository and invalidates cache.\n   *\n   * @param providerId - Provider identifier\n   * @param settings - Provider settings to save\n   */\n  async setProviderSettings(\n    providerId: string,\n    settings: import('@/infrastructure/interfaces/IConfigRepository').IProviderSettings\n  ): Promise<void> {\n    try {\n      await this.configRepository.setProviderSettings(providerId, settings);\n\n      // Invalidate cache\n      this.invalidateCache(`providerSettings:${providerId}`);\n\n      this.logger.info('Provider settings saved successfully', { providerId });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save provider settings', { providerId, error: errorMessage });\n      throw new Error(`Failed to save provider settings for ${providerId}: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Saves custom tags to ConfigRepository and invalidates cache.\n   *\n   * @param tags - Custom tags to save\n   */\n  async setCustomTags(\n    tags: import('@/infrastructure/interfaces/IConfigRepository').ICustomTag[]\n  ): Promise<void> {\n    try {\n      await this.configRepository.setCustomTags(tags);\n\n      // Invalidate cache\n      this.invalidateCache('customTags');\n\n      this.logger.info('Custom tags saved successfully', { count: tags.length });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save custom tags', { error: errorMessage });\n      throw new Error(`Failed to save custom tags: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Saves application configuration to ConfigRepository and invalidates cache.\n   *\n   * @param config - Application config to save\n   */\n  async setAppConfig(\n    config: import('@/infrastructure/interfaces/IConfigRepository').IAppConfig\n  ): Promise<void> {\n    try {\n      await this.configRepository.setAppConfig(config);\n\n      // Invalidate cache\n      this.invalidateCache('appConfig');\n\n      this.logger.info('App config saved successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save app config', { error: errorMessage });\n      throw new Error(`Failed to save app config: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Clears all configuration cache entries.\n   */\n  clearCache(): void {\n    this.cache.clear();\n    this.logger.debug('AppConfigService cache cleared');\n  }\n\n  // ==========================================================================\n  // Public Methods - Defaults and Helpers\n  // ==========================================================================\n\n  getDefaults(): Readonly<DefaultConfig> {\n    return this.defaults;\n  }\n\n  getHardcodedTags(): HardcodedTags {\n    return this.hardcodedTags;\n  }\n\n  getDefaultCustomTags(): CustomTags {\n    return this.defaultCustomTags;\n  }\n\n  getPromptTemplate(): string {\n    const PROMPT_INSTRUCTIONS: ReadonlyArray<string> = [\n      'Hi, I like you to check and score an email based on the following structured data. Please respond as a single, clean JSON object with the specified properties.',\n      '',\n      '### Email Headers',\n      '```json',\n      '{headers}',\n      '```',\n      '',\n      '### Email Body (converted from HTML to plain text)',\n      '```text',\n      '{body}',\n      '```',\n      '',\n      '### Attachments',\n      '```json',\n      '{attachments}',\n      '```',\n      '',\n      '### INSTRUCTIONS',\n      'Based on the data above, please populate the following JSON object:',\n      '- tags: (array of strings) list of tag keys where the corresponding check is true (e.g., [\"is_advertise\", \"is_business\"])',\n      '- confidence: (number between 0.0 and 1.0) your overall confidence in the analysis',\n      '- reasoning: (string) brief explanation of your analysis in one or two sentences',\n    ];\n\n    return PROMPT_INSTRUCTIONS.join('\\n');\n  }\n\n  isValidProvider(provider: string): provider is Provider {\n    return Object.values(Provider).includes(provider as Provider);\n  }\n\n  isHardcodedTag(tag: Tag): tag is Tag & { key: keyof HardcodedTags } {\n    return Object.keys(this.hardcodedTags).includes(tag.key as string);\n  }\n\n  isValidColor(color: string): boolean {\n    return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n  }\n\n  getConcurrencyLimit(config: AppConfig, provider: string, model: string): number {\n    const PROVIDER_DEFAULT_CONCURRENCY: Record<Provider, number> = {\n      [Provider.OLLAMA]: 5,\n      [Provider.OPENAI]: 10,\n      [Provider.GEMINI]: 5,\n      [Provider.CLAUDE]: 5,\n      [Provider.MISTRAL]: 10,\n      [Provider.DEEPSEEK]: 10,\n      [Provider.ZAI_PAAS]: 5,\n      [Provider.ZAI_CODING]: 5,\n    };\n\n    if (!config.modelConcurrencyLimits) {\n      return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n    }\n\n    const modelConfig = config.modelConcurrencyLimits.find(\n      (c) => c.provider === provider && c.model === model\n    );\n\n    if (modelConfig && modelConfig.concurrency > 0) {\n      return modelConfig.concurrency;\n    }\n\n    const providerConfig = config.modelConcurrencyLimits.find(\n      (c) => c.provider === provider && !c.model\n    );\n\n    if (providerConfig && providerConfig.concurrency > 0) {\n      return providerConfig.concurrency;\n    }\n\n    return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n  }\n\n  validateConcurrencyConfig(config: ModelConcurrencyConfig[]): string[] {\n    const errors: string[] = [];\n\n    for (const entry of config) {\n      const providerStr = entry.provider as string;\n      if (!this.isValidProvider(providerStr)) {\n        errors.push(`Invalid provider: ${entry.provider}`);\n      }\n\n      if (!entry.model && !entry.provider) {\n        errors.push('Either provider or model must be specified');\n      }\n\n      if (\n        entry.concurrency !== undefined &&\n        (entry.concurrency < 1 || !Number.isInteger(entry.concurrency))\n      ) {\n        errors.push(\n          `Invalid concurrency value for ${providerStr}/${entry.model || '(any)'}: ${entry.concurrency}. Must be a positive integer.`\n        );\n      }\n    }\n\n    return errors;\n  }\n\n  // ==========================================================================\n  // Private Methods - Caching\n  // ==========================================================================\n\n  /**\n   * Gets value from cache if not expired.\n   *\n   * @param key - Cache key\n   * @returns Cached value or null if not found or expired\n   */\n  private getFromCache<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      return null;\n    }\n\n    // Check if cache entry is expired\n    const now = Date.now();\n    if (now - entry.config.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.config.value as T;\n  }\n\n  /**\n   * Sets value in cache.\n   *\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttl - Time-to-live in milliseconds\n   */\n  private setInCache<T>(key: string, value: T, ttl: number): void {\n    const entry: CacheEntry = {\n      config: {\n        value,\n        timestamp: Date.now(),\n      },\n      ttl,\n    };\n\n    this.cache.set(key, entry);\n  }\n\n  /**\n   * Invalidates cache entry.\n   *\n   * @param key - Cache key to invalidate\n   */\n  private invalidateCache(key: string): void {\n    this.cache.delete(key);\n    this.logger.debug('Cache entry invalidated', { key });\n  }\n\n  /**\n   * Gets fallback provider settings for a provider.\n   *\n   * @param providerId - Provider identifier\n   * @returns Fallback provider settings\n   */\n  private getFallbackProviderSettings(\n    providerId: string\n  ): import('@/infrastructure/interfaces/IConfigRepository').IProviderSettings {\n    const providerDefaults: Record<\n      string,\n      import('@/infrastructure/interfaces/IConfigRepository').IProviderSettings\n    > = {\n      openai: {\n        apiKey: this.defaults.openaiApiKey,\n        model: 'gpt-4o-mini',\n      },\n      gemini: {\n        apiKey: this.defaults.geminiApiKey,\n        model: 'gemini-2.0-flash-exp',\n      },\n      claude: {\n        apiKey: this.defaults.claudeApiKey,\n        model: 'claude-3-5-sonnet-20241022',\n      },\n      mistral: {\n        apiKey: this.defaults.mistralApiKey,\n        model: 'mistral-large-latest',\n      },\n      deepseek: {\n        apiKey: this.defaults.deepseekApiKey,\n        model: 'deepseek-chat',\n      },\n      'zai-paas': {\n        apiKey: this.defaults.zaiPaasApiKey,\n        model: this.defaults.zaiPaasModel,\n        apiUrl: 'https://api.z.ai/v1',\n      },\n      'zai-coding': {\n        apiKey: this.defaults.zaiCodingApiKey,\n        model: this.defaults.zaiCodingModel,\n        apiUrl: 'https://api.z.ai/v1',\n      },\n      ollama: {\n        apiKey: '',\n        model: this.defaults.ollamaModel,\n        apiUrl: this.defaults.ollamaApiUrl,\n      },\n    };\n\n    return (\n      providerDefaults[providerId] ?? {\n        apiKey: '',\n        model: '',\n      }\n    );\n  }\n}\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "import { singleton, inject } from 'tsyringe';\nimport {\n  Tag,\n  HardcodedTags,\n  CustomTags,\n  Provider,\n  AppConfig,\n  DefaultConfig,\n  ModelConcurrencyConfig,\n} from '@/shared/types/ProviderTypes';\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Cached configuration with timestamp.\n */\ninterface CachedConfig<T> {\n  /** Cached value */\n  value: T;\n  /** Cache timestamp */\n  timestamp: number;\n}\n\n/**\n * Cache entry with TTL.\n */\ninterface CacheEntry {\n  /** Cached configuration */\n  config: CachedConfig<unknown>;\n  /** Time-to-live in milliseconds */\n  ttl: number;\n}\n\n// ============================================================================\n// AppConfigService Implementation\n// ============================================================================\n\n/**\n * Configuration service with caching.\n *\n * Provides access to application configuration with in-memory caching\n * to improve performance. Falls back to defaults if ConfigRepository is unavailable.\n */\n@singleton()\nexport class AppConfigService {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private readonly configRepository: IConfigRepository;\n  private readonly logger: ILogger;\n\n  /** In-memory cache for configurations */\n  private readonly cache: Map<string, CacheEntry> = new Map();\n\n  /** Default cache TTL: 5 minutes */\n  private readonly DEFAULT_CACHE_TTL = 5 * 60 * 1000;\n\n  // Hardcoded tags (system tags that cannot be modified)\n  private readonly hardcodedTags: HardcodedTags = {\n    is_scam: { key: 'is_scam', name: 'Scam Alert', color: '#FF5722' },\n    spf_fail: { key: 'spf_fail', name: 'SPF Fail', color: '#E91E63' },\n    dkim_fail: { key: 'dkim_fail', name: 'DKIM Fail', color: '#E91E63' },\n    tagged: { key: 'tagged', name: 'Tagged', color: '#4f4f4f' },\n    email_ai_analyzed: { key: 'email_ai_analyzed', name: 'AI Analyzed', color: '#9E9E9E' },\n  };\n\n  private readonly defaultCustomTags: CustomTags = [\n    {\n      key: 'is_advertise',\n      name: 'Advertisement',\n      color: '#FFC107',\n      prompt:\n        'check if email is advertising something and contains an offer or someone is asking for contact to show the offer',\n    },\n    {\n      key: 'is_business_approach',\n      name: 'Business Ad',\n      color: '#2196F3',\n      prompt:\n        'check if email is a cold marketing/sales/business approach (or next message in the approach process where sender reply to self to refresh the approach in the mailbox). Consider typical sales and lead generation scenarios.',\n    },\n    {\n      key: 'is_personal',\n      name: 'Personal',\n      color: '#4CAF50',\n      prompt:\n        'check if this is non-sales scenario approach from someone who likes to contact in a non-business context.',\n    },\n    {\n      key: 'is_business',\n      name: 'Business',\n      color: '#af4c87',\n      prompt: 'check if this looks like work related email',\n    },\n    {\n      key: 'is_service_important',\n      name: 'Service Important',\n      color: '#F44336',\n      prompt:\n        'check if email contains important information related to already subscribed service (if this is subscription offer - ignore it): bill, password reset, login link, 2fa code, expiration notice. Consider common services like electricity, bank account, netflix, or similar subscription service.',\n    },\n    {\n      key: 'is_service_not_important',\n      name: 'Service Info',\n      color: '#9E9E9E',\n      prompt:\n        'check if email contains non critical information from already subscribed service (if this is subscription offer - ignore it) - like: daily posts update from linkedin, AWS invitation for conference, cross sale, tips how to use product, surveys, new offers',\n    },\n    {\n      key: 'is_bill',\n      name: 'Bill',\n      color: '#f4b136',\n      prompt: 'check if email contains bill or invoice information.',\n    },\n    {\n      key: 'has_calendar_invite',\n      name: 'Appointment',\n      color: '#7F07f2',\n      prompt:\n        'check if the mail has invitation to the call or meeting (with calendar appointment attached)',\n    },\n  ];\n\n  private readonly defaults: Readonly<DefaultConfig> = {\n    provider: Provider.OLLAMA,\n    ollamaApiUrl: 'http://localhost:11434/api/generate',\n    ollamaModel: 'gemma3:27b',\n    openaiApiKey: '',\n    geminiApiKey: '',\n    claudeApiKey: '',\n    mistralApiKey: '',\n    deepseekApiKey: '',\n    zaiPaasApiKey: '',\n    zaiPaasModel: 'glm-4.5',\n    zaiCodingApiKey: '',\n    zaiCodingModel: 'glm-4.7',\n    customTags: this.defaultCustomTags,\n    enableNotifications: true,\n    enableLogging: true,\n    model: undefined,\n    modelConcurrencyLimits: undefined,\n    confidenceThreshold: 70,\n  };\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor(\n    @inject('ILogger') logger: ILogger,\n    @inject('IConfigRepository') configRepository: IConfigRepository\n  ) {\n    this.logger = logger;\n    this.configRepository = configRepository;\n    this.logger.debug('AppConfigService initialized with ConfigRepository');\n  }\n\n  // ==========================================================================\n  // Public Methods - ConfigRepository Integration\n  // ==========================================================================\n\n  /**\n   * Gets application configuration from ConfigRepository with caching.\n   *\n   * @returns Promise resolving to application config\n   */\n  async getAppConfig(): Promise<\n    import('@/infrastructure/interfaces/IConfigRepository').IAppConfig\n  > {\n    const cacheKey = 'appConfig';\n\n    // Check cache\n    const cached =\n      this.getFromCache<import('@/infrastructure/interfaces/IConfigRepository').IAppConfig>(\n        cacheKey\n      );\n    if (cached) {\n      this.logger.debug('AppConfig cache hit', { cacheKey });\n      return cached;\n    }\n\n    // Load from repository\n    try {\n      const config = await this.configRepository.getAppConfig();\n\n      // Cache the result\n      this.setInCache(cacheKey, config, this.DEFAULT_CACHE_TTL);\n\n      return config;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('Failed to load app config from repository, using fallback', {\n        error: errorMessage,\n      });\n\n      // Return fallback config\n      return {\n        defaultProvider: this.defaults.provider,\n        enableNotifications: this.defaults.enableNotifications,\n        enableLogging: this.defaults.enableLogging,\n        modelConcurrencyLimits: this.defaults.modelConcurrencyLimits,\n        confidenceThreshold: this.defaults.confidenceThreshold,\n      };\n    }\n  }\n\n  /**\n   * Gets provider settings from ConfigRepository with caching.\n   *\n   * @param providerId - Provider identifier\n   * @returns Promise resolving to provider settings\n   */\n  async getProviderSettings(\n    providerId: string\n  ): Promise<import('@/infrastructure/interfaces/IConfigRepository').IProviderSettings> {\n    const cacheKey = `providerSettings:${providerId}`;\n\n    // Check cache\n    const cached =\n      this.getFromCache<import('@/infrastructure/interfaces/IConfigRepository').IProviderSettings>(\n        cacheKey\n      );\n    if (cached) {\n      this.logger.debug('ProviderSettings cache hit', { cacheKey, providerId });\n      return cached;\n    }\n\n    // Load from repository\n    try {\n      const settings = await this.configRepository.getProviderSettings(providerId);\n\n      // Cache the result\n      this.setInCache(cacheKey, settings, this.DEFAULT_CACHE_TTL);\n\n      return settings;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('Failed to load provider settings from repository, using fallback', {\n        providerId,\n        error: errorMessage,\n      });\n\n      // Return fallback settings based on provider\n      return this.getFallbackProviderSettings(providerId);\n    }\n  }\n\n  /**\n   * Gets custom tags from ConfigRepository with caching.\n   *\n   * @returns Promise resolving to custom tags array\n   */\n  async getCustomTags(): Promise<\n    import('@/infrastructure/interfaces/IConfigRepository').ICustomTag[]\n  > {\n    const cacheKey = 'customTags';\n\n    // Check cache\n    const cached =\n      this.getFromCache<import('@/infrastructure/interfaces/IConfigRepository').ICustomTag[]>(\n        cacheKey\n      );\n    if (cached) {\n      this.logger.debug('CustomTags cache hit', { cacheKey });\n      return cached;\n    }\n\n    // Load from repository\n    try {\n      const tags = await this.configRepository.getCustomTags();\n\n      // Cache the result\n      this.setInCache(cacheKey, tags, this.DEFAULT_CACHE_TTL);\n\n      return tags;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('Failed to load custom tags from repository, using defaults', {\n        error: errorMessage,\n      });\n\n      // Return default custom tags\n      return this.defaultCustomTags.map((tag) => ({\n        key: tag.key,\n        name: tag.name,\n        color: tag.color,\n        prompt: tag.prompt,\n      }));\n    }\n  }\n\n  /**\n   * Saves provider settings to ConfigRepository and invalidates cache.\n   *\n   * @param providerId - Provider identifier\n   * @param settings - Provider settings to save\n   */\n  async setProviderSettings(\n    providerId: string,\n    settings: import('@/infrastructure/interfaces/IConfigRepository').IProviderSettings\n  ): Promise<void> {\n    try {\n      await this.configRepository.setProviderSettings(providerId, settings);\n\n      // Invalidate cache\n      this.invalidateCache(`providerSettings:${providerId}`);\n\n      this.logger.info('Provider settings saved successfully', { providerId });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save provider settings', { providerId, error: errorMessage });\n      throw new Error(`Failed to save provider settings for ${providerId}: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Saves custom tags to ConfigRepository and invalidates cache.\n   *\n   * @param tags - Custom tags to save\n   */\n  async setCustomTags(\n    tags: import('@/infrastructure/interfaces/IConfigRepository').ICustomTag[]\n  ): Promise<void> {\n    try {\n      await this.configRepository.setCustomTags(tags);\n\n      // Invalidate cache\n      this.invalidateCache('customTags');\n\n      this.logger.info('Custom tags saved successfully', { count: tags.length });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save custom tags', { error: errorMessage });\n      throw new Error(`Failed to save custom tags: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Gets threshold override for a specific tag.\n   *\n   * @param tagKey - The tag key to get threshold for\n   * @returns Promise resolving to threshold value (0-100) or null if no override is set\n   */\n  async getTagThreshold(tagKey: string): Promise<number | null> {\n    try {\n      return await this.configRepository.getTagThreshold(tagKey);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('Failed to get tag threshold, returning null', {\n        tagKey,\n        error: errorMessage,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Sets threshold override for a specific tag.\n   *\n   * @param tagKey - The tag key to set threshold for\n   * @param threshold - Threshold value (0-100), or null to remove override\n   */\n  async setTagThreshold(tagKey: string, threshold: number | null): Promise<void> {\n    try {\n      await this.configRepository.setTagThreshold(tagKey, threshold);\n\n      // Invalidate relevant caches\n      this.invalidateCache(`tagThreshold:${tagKey}`);\n      this.invalidateCache('allTagThresholds');\n\n      this.logger.info('Tag threshold saved successfully', { tagKey, threshold });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save tag threshold', { tagKey, threshold, error: errorMessage });\n      throw new Error(`Failed to save tag threshold for ${tagKey}: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Gets all tag threshold overrides.\n   *\n   * @returns Promise resolving to record mapping tag keys to their threshold overrides\n   */\n  async getAllTagThresholds(): Promise<Record<string, number>> {\n    const cacheKey = 'allTagThresholds';\n\n    // Check cache\n    const cached = this.getFromCache<Record<string, number>>(cacheKey);\n    if (cached) {\n      this.logger.debug('All tag thresholds cache hit', { cacheKey });\n      return cached;\n    }\n\n    // Load from repository\n    try {\n      const thresholds = await this.configRepository.getAllTagThresholds();\n\n      // Cache the result\n      this.setInCache(cacheKey, thresholds, this.DEFAULT_CACHE_TTL);\n\n      return thresholds;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('Failed to get all tag thresholds, returning empty', {\n        error: errorMessage,\n      });\n      return {};\n    }\n  }\n\n  /**\n   * Gets the effective threshold for a tag, considering per-tag override and global threshold.\n   * Returns the per-tag override if set, otherwise returns the global threshold.\n   *\n   * @param tagKey - The tag key to get effective threshold for\n   * @returns Promise resolving to effective threshold value (0-100)\n   */\n  async getEffectiveThreshold(tagKey: string): Promise<number> {\n    // Check for per-tag override\n    const override = await this.getTagThreshold(tagKey);\n    if (override !== null) {\n      return override;\n    }\n\n    // Fall back to global threshold\n    const appConfig = await this.getAppConfig();\n    return appConfig.confidenceThreshold;\n  }\n\n  /**\n   * Saves application configuration to ConfigRepository and invalidates cache.\n   *\n   * @param config - Application config to save\n   */\n  async setAppConfig(\n    config: import('@/infrastructure/interfaces/IConfigRepository').IAppConfig\n  ): Promise<void> {\n    try {\n      await this.configRepository.setAppConfig(config);\n\n      // Invalidate cache\n      this.invalidateCache('appConfig');\n\n      this.logger.info('App config saved successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save app config', { error: errorMessage });\n      throw new Error(`Failed to save app config: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Clears all configuration cache entries.\n   */\n  clearCache(): void {\n    this.cache.clear();\n    this.logger.debug('AppConfigService cache cleared');\n  }\n\n  // ==========================================================================\n  // Public Methods - Defaults and Helpers\n  // ==========================================================================\n\n  getDefaults(): Readonly<DefaultConfig> {\n    return this.defaults;\n  }\n\n  getHardcodedTags(): HardcodedTags {\n    return this.hardcodedTags;\n  }\n\n  getDefaultCustomTags(): CustomTags {\n    return this.defaultCustomTags;\n  }\n\n  getPromptTemplate(): string {\n    const PROMPT_INSTRUCTIONS: ReadonlyArray<string> = [\n      'Hi, I like you to check and score an email based on the following structured data. Please respond as a single, clean JSON object with the specified properties.',\n      '',\n      '### Email Headers',\n      '```json',\n      '{headers}',\n      '```',\n      '',\n      '### Email Body (converted from HTML to plain text)',\n      '```text',\n      '{body}',\n      '```',\n      '',\n      '### Attachments',\n      '```json',\n      '{attachments}',\n      '```',\n      '',\n      '### INSTRUCTIONS',\n      'Based on the data above, please populate the following JSON object:',\n      '- tags: (array of strings) list of tag keys where the corresponding check is true (e.g., [\"is_advertise\", \"is_business\"])',\n      '- confidence: (number between 0.0 and 1.0) your overall confidence in the analysis',\n      '- reasoning: (string) brief explanation of your analysis in one or two sentences',\n    ];\n\n    return PROMPT_INSTRUCTIONS.join('\\n');\n  }\n\n  isValidProvider(provider: string): provider is Provider {\n    return Object.values(Provider).includes(provider as Provider);\n  }\n\n  isHardcodedTag(tag: Tag): tag is Tag & { key: keyof HardcodedTags } {\n    return Object.keys(this.hardcodedTags).includes(tag.key as string);\n  }\n\n  isValidColor(color: string): boolean {\n    return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n  }\n\n  getConcurrencyLimit(config: AppConfig, provider: string, model: string): number {\n    const PROVIDER_DEFAULT_CONCURRENCY: Record<Provider, number> = {\n      [Provider.OLLAMA]: 5,\n      [Provider.OPENAI]: 10,\n      [Provider.GEMINI]: 5,\n      [Provider.CLAUDE]: 5,\n      [Provider.MISTRAL]: 10,\n      [Provider.DEEPSEEK]: 10,\n      [Provider.ZAI_PAAS]: 5,\n      [Provider.ZAI_CODING]: 5,\n    };\n\n    if (!config.modelConcurrencyLimits) {\n      return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n    }\n\n    const modelConfig = config.modelConcurrencyLimits.find(\n      (c) => c.provider === provider && c.model === model\n    );\n\n    if (modelConfig && modelConfig.concurrency > 0) {\n      return modelConfig.concurrency;\n    }\n\n    const providerConfig = config.modelConcurrencyLimits.find(\n      (c) => c.provider === provider && !c.model\n    );\n\n    if (providerConfig && providerConfig.concurrency > 0) {\n      return providerConfig.concurrency;\n    }\n\n    return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n  }\n\n  validateConcurrencyConfig(config: ModelConcurrencyConfig[]): string[] {\n    const errors: string[] = [];\n\n    for (const entry of config) {\n      const providerStr = entry.provider as string;\n      if (!this.isValidProvider(providerStr)) {\n        errors.push(`Invalid provider: ${entry.provider}`);\n      }\n\n      if (!entry.model && !entry.provider) {\n        errors.push('Either provider or model must be specified');\n      }\n\n      if (\n        entry.concurrency !== undefined &&\n        (entry.concurrency < 1 || !Number.isInteger(entry.concurrency))\n      ) {\n        errors.push(\n          `Invalid concurrency value for ${providerStr}/${entry.model || '(any)'}: ${entry.concurrency}. Must be a positive integer.`\n        );\n      }\n    }\n\n    return errors;\n  }\n\n  // ==========================================================================\n  // Private Methods - Caching\n  // ==========================================================================\n\n  /**\n   * Gets value from cache if not expired.\n   *\n   * @param key - Cache key\n   * @returns Cached value or null if not found or expired\n   */\n  private getFromCache<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      return null;\n    }\n\n    // Check if cache entry is expired\n    const now = Date.now();\n    if (now - entry.config.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.config.value as T;\n  }\n\n  /**\n   * Sets value in cache.\n   *\n   * @param key - Cache key\n   * @param value - Value to cache\n   * @param ttl - Time-to-live in milliseconds\n   */\n  private setInCache<T>(key: string, value: T, ttl: number): void {\n    const entry: CacheEntry = {\n      config: {\n        value,\n        timestamp: Date.now(),\n      },\n      ttl,\n    };\n\n    this.cache.set(key, entry);\n  }\n\n  /**\n   * Invalidates cache entry.\n   *\n   * @param key - Cache key to invalidate\n   */\n  private invalidateCache(key: string): void {\n    this.cache.delete(key);\n    this.logger.debug('Cache entry invalidated', { key });\n  }\n\n  /**\n   * Gets fallback provider settings for a provider.\n   *\n   * @param providerId - Provider identifier\n   * @returns Fallback provider settings\n   */\n  private getFallbackProviderSettings(\n    providerId: string\n  ): import('@/infrastructure/interfaces/IConfigRepository').IProviderSettings {\n    const providerDefaults: Record<\n      string,\n      import('@/infrastructure/interfaces/IConfigRepository').IProviderSettings\n    > = {\n      openai: {\n        apiKey: this.defaults.openaiApiKey,\n        model: 'gpt-4o-mini',\n      },\n      gemini: {\n        apiKey: this.defaults.geminiApiKey,\n        model: 'gemini-2.0-flash-exp',\n      },\n      claude: {\n        apiKey: this.defaults.claudeApiKey,\n        model: 'claude-3-5-sonnet-20241022',\n      },\n      mistral: {\n        apiKey: this.defaults.mistralApiKey,\n        model: 'mistral-large-latest',\n      },\n      deepseek: {\n        apiKey: this.defaults.deepseekApiKey,\n        model: 'deepseek-chat',\n      },\n      'zai-paas': {\n        apiKey: this.defaults.zaiPaasApiKey,\n        model: this.defaults.zaiPaasModel,\n        apiUrl: 'https://api.z.ai/v1',\n      },\n      'zai-coding': {\n        apiKey: this.defaults.zaiCodingApiKey,\n        model: this.defaults.zaiCodingModel,\n        apiUrl: 'https://api.z.ai/v1',\n      },\n      ollama: {\n        apiKey: '',\n        model: this.defaults.ollamaModel,\n        apiUrl: this.defaults.ollamaApiUrl,\n      },\n    };\n\n    return (\n      providerDefaults[providerId] ?? {\n        apiKey: '',\n        model: '',\n      }\n    );\n  }\n}\n",
        "last_modified": "2026-01-05T19:59:00.206098"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.124086",
  "last_updated": "2026-01-05T14:48:03.127526"
}