{
  "file_path": "src/infrastructure/repositories/ReviewQueueRepository.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * Review queue repository using browser.storage.local.\n *\n * Implements IReviewQueueRepository using browser.storage.local API\n * which is available in Thunderbird extensions and provides a Promise-based\n * interface for persistent review queue storage.\n *\n * Uses a single storage namespace (key):\n * - 'reviewQueue': Array of review queue items\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { ILogger } from '../interfaces/ILogger';\nimport type {\n  IReviewQueueRepository,\n  IReviewQueueItem,\n  IReviewQueueQuery,\n  IReviewQueueStats,\n  ReviewStatus,\n} from '../interfaces/IReviewQueueRepository';\n\n// === Type Definitions ===\n\ninterface StorageLocal {\n  get: (\n    keys: string | string[] | Record<string, unknown> | null\n  ) => Promise<Record<string, unknown>>;\n  set: (items: Record<string, unknown>) => Promise<void>;\n  clear: () => Promise<void>;\n}\n\ninterface BrowserStorage {\n  storage: {\n    local: StorageLocal;\n  };\n}\n\n// === Type Guards ===\n\n/**\n * Type guard to check if object has browser.storage API.\n */\nfunction hasBrowserStorage(obj: unknown): obj is BrowserStorage {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const maybeStorage = obj as Record<string, unknown>;\n  if (typeof maybeStorage.storage !== 'object' || maybeStorage.storage === null) {\n    return false;\n  }\n\n  const storage = maybeStorage.storage as Record<string, unknown>;\n  if (typeof storage.local !== 'object' || storage.local === null) {\n    return false;\n  }\n\n  const local = storage.local as Record<string, unknown>;\n  return (\n    typeof local.get === 'function' &&\n    typeof local.set === 'function' &&\n    typeof local.clear === 'function'\n  );\n}\n\n// === Constants ===\n\nconst STORAGE_KEY = 'reviewQueue';\n\n// === Helper Functions ===\n\n/**\n * Generate a unique ID for a review queue item.\n */\nfunction generateId(): string {\n  return `rq-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n}\n\n/**\n * Check if a record matches a query.\n */\nfunction matchesQuery(item: IReviewQueueItem, query: IReviewQueueQuery): boolean {\n  // Filter by message ID\n  if (query.messageId && item.messageId !== query.messageId) {\n    return false;\n  }\n\n  // Filter by status\n  if (query.status && item.status !== query.status) {\n    return false;\n  }\n\n  // Filter by provider\n  if (query.provider && item.provider !== query.provider) {\n    return false;\n  }\n\n  // Filter by confidence score range\n  if (query.minConfidenceScore !== undefined && item.confidenceScore < query.minConfidenceScore) {\n    return false;\n  }\n  if (query.maxConfidenceScore !== undefined && item.confidenceScore > query.maxConfidenceScore) {\n    return false;\n  }\n\n  // Filter by tag\n  if (query.hasTag && !item.manualReviewTags.some((t) => t.tag === query.hasTag)) {\n    return false;\n  }\n\n  // Filter by date range (addedAt timestamp)\n  if (query.startDate && item.addedAt < query.startDate) {\n    return false;\n  }\n  if (query.endDate && item.addedAt > query.endDate) {\n    return false;\n  }\n\n  return true;\n}\n\n// === Implementation ===\n\n@injectable()\nexport class ReviewQueueRepository implements IReviewQueueRepository {\n  private readonly storage: {\n    get: (keys: string | string[] | Record<string, unknown> | null) => Promise<Record<string, unknown>>;\n    set: (items: Record<string, unknown>) => Promise<void>;\n    clear: () => Promise<void>;\n  };\n\n  constructor(@inject('ILogger') private readonly logger: ILogger) {\n    // Use browser.storage.local if available (Thunderbird extension environment)\n    const browserApi = (globalThis as unknown as Record<string, unknown>).browser as\n      | BrowserStorage\n      | undefined;\n    const chromeApi = (globalThis as unknown as Record<string, unknown>).chrome as\n      | BrowserStorage\n      | undefined;\n\n    if (browserApi && hasBrowserStorage(browserApi)) {\n      this.storage = {\n        get: browserApi.storage.local.get.bind(browserApi.storage.local),\n        set: browserApi.storage.local.set.bind(browserApi.storage.local),\n        clear: browserApi.storage.local.clear.bind(browserApi.storage.local),\n      };\n      this.logger.info('Using browser.storage.local for review queue persistence');\n    } else if (chromeApi && hasBrowserStorage(chromeApi)) {\n      this.storage = {\n        get: chromeApi.storage.local.get.bind(chromeApi.storage.local),\n        set: chromeApi.storage.local.set.bind(chromeApi.storage.local),\n        clear: chromeApi.storage.local.clear.bind(chromeApi.storage.local),\n      };\n      this.logger.info('Using chrome.storage.local for review queue persistence');\n    } else {\n      throw new Error(\n        'browser.storage API not available. ReviewQueueRepository requires a Thunderbird extension environment.'\n      );\n    }\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  async addToQueue(item: IReviewQueueItem): Promise<void> {\n    try {\n      this.logger.debug('Adding item to review queue', {\n        id: item.id,\n        messageId: item.messageId,\n        confidenceScore: item.confidenceScore,\n        manualReviewTags: item.manualReviewTags.length,\n      });\n\n      const data = await this.storage.get(STORAGE_KEY);\n      const queue = (data[STORAGE_KEY] as IReviewQueueItem[]) || [];\n\n      // Check if item with same ID already exists\n      const existingIndex = queue.findIndex((q) => q.id === item.id);\n      if (existingIndex !== -1) {\n        // Update existing item\n        queue[existingIndex] = item;\n        this.logger.debug('Updating existing review queue item', { id: item.id });\n      } else {\n        // Add new item\n        queue.push(item);\n        this.logger.debug('Adding new review queue item', { id: item.id });\n      }\n\n      // Sort by addedAt timestamp descending (newest first)\n      queue.sort((a, b) => new Date(b.addedAt).getTime() - new Date(a.addedAt).getTime());\n\n      await this.storage.set({ [STORAGE_KEY]: queue });\n\n      this.logger.debug('Review queue item added successfully', {\n        id: item.id,\n        totalItems: queue.length,\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to add review queue item', {\n        id: item.id,\n        error: message,\n      });\n      throw new Error(`Failed to add review queue item: ${message}`);\n    }\n  }\n\n  async getItem(id: string): Promise<IReviewQueueItem | null> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const queue = (data[STORAGE_KEY] as IReviewQueueItem[]) || [];\n\n      const item = queue.find((q) => q.id === id);\n\n      if (item) {\n        this.logger.debug('Review queue item found', { id });\n      } else {\n        this.logger.debug('Review queue item not found', { id });\n      }\n\n      return item || null;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get review queue item', { id, error: message });\n      throw new Error(`Failed to get review queue item: ${message}`);\n    }\n  }\n\n  async getItemsByMessage(messageId: string): Promise<IReviewQueueItem[]> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const queue = (data[STORAGE_KEY] as IReviewQueueItem[]) || [];\n\n      const items = queue.filter((item) => item.messageId === messageId);\n\n      this.logger.debug('Retrieved review queue items for message', {\n        messageId,\n        count: items.length,\n      });\n\n      return items;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get review queue items for message', {\n        messageId,\n        error: message,\n      });\n      throw new Error(`Failed to get review queue items for message: ${message}`);\n    }\n  }\n\n  async queryQueue(query?: IReviewQueueQuery): Promise<IReviewQueueItem[]> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      let queue = (data[STORAGE_KEY] as IReviewQueueItem[]) || [];\n\n      // Apply filters\n      if (query) {\n        queue = queue.filter((item) => matchesQuery(item, query));\n\n        // Apply limit and offset\n        const offset = query.offset || 0;\n        const limit = query.limit;\n        if (limit !== undefined) {\n          queue = queue.slice(offset, offset + limit);\n        } else if (offset > 0) {\n          queue = queue.slice(offset);\n        }\n      }\n\n      this.logger.debug('Review queue query executed successfully', {\n        query: JSON.stringify(query),\n        resultCount: queue.length,\n      });\n\n      return queue;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to query review queue', {\n        query: JSON.stringify(query),\n        error: message,\n      });\n      throw new Error(`Failed to query review queue: ${message}`);\n    }\n  }\n\n  async updateStatus(id: string, status: ReviewStatus, reviewNotes?: string): Promise<void> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const queue = (data[STORAGE_KEY] as IReviewQueueItem[]) || [];\n\n      const itemIndex = queue.findIndex((item) => item.id === id);\n\n      if (itemIndex === -1) {\n        this.logger.warn('Review queue item not found for status update', { id });\n        return;\n      }\n\n      // Update status and reviewedAt timestamp\n      queue[itemIndex].status = status;\n      queue[itemIndex].reviewedAt = new Date().toISOString();\n\n      if (reviewNotes !== undefined) {\n        queue[itemIndex].reviewNotes = reviewNotes;\n      }\n\n      await this.storage.set({ [STORAGE_KEY]: queue });\n\n      this.logger.info('Review queue item status updated', {\n        id,\n        status,\n        hasNotes: !!reviewNotes,\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to update review queue item status', {\n        id,\n        status,\n        error: message,\n      });\n      throw new Error(`Failed to update review queue item status: ${message}`);\n    }\n  }\n\n  async getStats(query?: IReviewQueueQuery): Promise<IReviewQueueStats> {\n    try {\n      const items = await this.queryQueue(query);\n\n      if (items.length === 0) {\n        return {\n          totalItems: 0,\n          pendingCount: 0,\n          approvedCount: 0,\n          rejectedCount: 0,\n          ignoredCount: 0,\n          averagePendingConfidence: 0,\n          topTags: [],\n        };\n      }\n\n      // Count by status\n      const pendingCount = items.filter((item) => item.status === 'pending').length;\n      const approvedCount = items.filter((item) => item.status === 'approved').length;\n      const rejectedCount = items.filter((item) => item.status === 'rejected').length;\n      const ignoredCount = items.filter((item) => item.status === 'ignored').length;\n\n      // Calculate average confidence for pending items\n      const pendingItems = items.filter((item) => item.status === 'pending');\n      const averagePendingConfidence =\n        pendingItems.length > 0\n          ? Math.round(\n              (pendingItems.reduce((sum, item) => sum + item.confidenceScore, 0) /\n                pendingItems.length) *\n                100\n            ) / 100\n          : 0;\n\n      // Count tag usage\n      const tagCounts = new Map<string, number>();\n      items.forEach((item) => {\n        item.manualReviewTags.forEach((tagInfo) => {\n          tagCounts.set(tagInfo.tag, (tagCounts.get(tagInfo.tag) || 0) + 1);\n        });\n      });\n      const topTags = Array.from(tagCounts.entries())\n        .map(([tag, count]) => ({ tag, count }))\n        .sort((a, b) => b.count - a.count)\n        .slice(0, 10);\n\n      this.logger.debug('Review queue statistics calculated successfully', {\n        totalItems: items.length,\n        pendingCount,\n        averagePendingConfidence,\n      });\n\n      return {\n        totalItems: items.length,\n        pendingCount,\n        approvedCount,\n        rejectedCount,\n        ignoredCount,\n        averagePendingConfidence,\n        topTags,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to calculate review queue stats', { error: message });\n      throw new Error(`Failed to calculate review queue stats: ${message}`);\n    }\n  }\n\n  async deleteItem(id: string): Promise<void> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const queue = (data[STORAGE_KEY] as IReviewQueueItem[]) || [];\n\n      const filtered = queue.filter((item) => item.id !== id);\n\n      if (filtered.length === queue.length) {\n        this.logger.warn('Review queue item not found for deletion', { id });\n        return;\n      }\n\n      await this.storage.set({ [STORAGE_KEY]: filtered });\n\n      this.logger.debug('Review queue item deleted', { id });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to delete review queue item', { id, error: message });\n      throw new Error(`Failed to delete review queue item: ${message}`);\n    }\n  }\n\n  async deleteItemsByMessage(messageId: string): Promise<number> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const queue = (data[STORAGE_KEY] as IReviewQueueItem[]) || [];\n\n      const filtered = queue.filter((item) => item.messageId !== messageId);\n      const deletedCount = queue.length - filtered.length;\n\n      if (deletedCount === 0) {\n        this.logger.debug('No review queue items found for message', { messageId });\n        return 0;\n      }\n\n      await this.storage.set({ [STORAGE_KEY]: filtered });\n\n      this.logger.debug('Review queue items deleted for message', {\n        messageId,\n        count: deletedCount,\n      });\n\n      return deletedCount;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to delete review queue items for message', {\n        messageId,\n        error: message,\n      });\n      throw new Error(`Failed to delete review queue items: ${message}`);\n    }\n  }\n\n  async clearAll(): Promise<number> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const queue = (data[STORAGE_KEY] as IReviewQueueItem[]) || [];\n      const count = queue.length;\n\n      await this.storage.set({ [STORAGE_KEY]: [] });\n\n      this.logger.info('All review queue items cleared', { count });\n      return count;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to clear review queue', { error: message });\n      throw new Error(`Failed to clear review queue: ${message}`);\n    }\n  }\n\n  async count(query?: IReviewQueueQuery): Promise<number> {\n    try {\n      const items = await this.queryQueue(query);\n      return items.length;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to count review queue items', { error: message });\n      throw new Error(`Failed to count review queue items: ${message}`);\n    }\n  }\n}\n",
        "last_modified": "2026-01-05T19:59:00.210042"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.111637",
  "last_updated": "2026-01-05T14:48:03.115283"
}