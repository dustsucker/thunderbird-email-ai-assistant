{
  "file_path": "core/config.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "// ============================================================================\n// Tag Configuration Types\n// ============================================================================\n\n/**\n * Represents a single tag configuration\n */\nexport interface Tag {\n  key: string;\n  name: string;\n  color: string;\n  prompt?: string;\n}\n\n/**\n * Type for the key of a hardcoded tag\n */\nexport type HardcodedTagKey = 'is_scam' | 'spf_fail' | 'dkim_fail' | 'tagged' | 'email_ai_analyzed';\n\n/**\n * Readonly map of hardcoded tags with their configurations\n */\nexport type HardcodedTags = Record<HardcodedTagKey, Tag>;\n\n/**\n * Array of custom tag configurations\n */\nexport type CustomTags = ReadonlyArray<Tag>;\n\n/**\n * Combined type for all tags\n */\nexport type AllTags = HardcodedTags & CustomTags;\n\n// ============================================================================\n// Provider Configuration Types\n// ============================================================================\n\n/**\n * Supported AI providers\n */\nexport enum Provider {\n  OLLAMA = 'ollama',\n  OPENAI = 'openai',\n  GEMINI = 'gemini',\n  CLAUDE = 'claude',\n  MISTRAL = 'mistral',\n  DEEPSEEK = 'deepseek',\n  ZAI_PAAS = 'zai-paas',\n  ZAI_CODING = 'zai-coding',\n}\n\n/**\n * Provider API configuration interface\n */\nexport interface ProviderConfig {\n  provider: Provider;\n  ollamaApiUrl: string;\n  ollamaModel: string;\n  openaiApiKey: string;\n  geminiApiKey: string;\n  claudeApiKey: string;\n  mistralApiKey: string;\n  deepseekApiKey: string;\n  zaiPaasApiKey: string;\n  zaiPaasModel: string;\n  zaiCodingApiKey: string;\n  zaiCodingModel: string;\n  model?: string;\n}\n\n// ============================================================================\n// Analysis Configuration Types\n// ============================================================================\n\n/**\n * Analysis context limits\n */\nexport interface AnalysisLimits {\n  contextCharLimit: number;\n}\n\n/**\n * Analysis prompt template interface\n */\nexport interface AnalysisPrompt {\n  template: string;\n  instructions: ReadonlyArray<string>;\n}\n\n/**\n * Feature flags for analysis\n */\nexport interface AnalysisFeatures {\n  enableNotifications: boolean;\n  enableLogging: boolean;\n}\n\n/**\n * Complete application configuration\n */\nexport interface ModelConcurrencyConfig {\n  provider: string;\n  model?: string;\n  concurrency: number;\n}\n\nexport interface AppConfig extends ProviderConfig, AnalysisFeatures {\n  customTags: CustomTags;\n  modelConcurrencyLimits?: ModelConcurrencyConfig[];\n}\n\n/**\n * Default configuration structure\n */\nexport interface DefaultConfig extends AppConfig {}\n\n// ============================================================================\n// Tag Key Constants\n// ============================================================================\n\nexport const TAG_KEY_PREFIX: string = '_ma_' as const;\nexport const TAG_NAME_PREFIX: string = 'A:' as const;\n\n// ============================================================================\n// Hardcoded Tags (readonly with const assertion)\n// ============================================================================\n\nexport const HARDCODED_TAGS: HardcodedTags = {\n  is_scam: { key: 'is_scam', name: 'Scam Alert', color: '#FF5722' },\n  spf_fail: { key: 'spf_fail', name: 'SPF Fail', color: '#E91E63' },\n  dkim_fail: { key: 'dkim_fail', name: 'DKIM Fail', color: '#E91E63' },\n  tagged: { key: 'tagged', name: 'Tagged', color: '#4f4f4f' },\n  email_ai_analyzed: { key: 'email_ai_analyzed', name: 'AI Analyzed', color: '#9E9E9E' },\n} as const;\n\n// ============================================================================\n// Default Custom Tags (readonly array)\n// ============================================================================\n\nexport const DEFAULT_CUSTOM_TAGS: CustomTags = [\n  {\n    key: 'is_advertise',\n    name: 'Advertisement',\n    color: '#FFC107',\n    prompt:\n      'check if email is advertising something and contains an offer or someone is asking for contact to show the offer',\n  },\n  {\n    key: 'is_business_approach',\n    name: 'Business Ad',\n    color: '#2196F3',\n    prompt:\n      'check if email is a cold marketing/sales/business approach (or next message in the approach process where sender reply to self to refresh the approach in the mailbox). Consider typical sales and lead generation scenarios.',\n  },\n  {\n    key: 'is_personal',\n    name: 'Personal',\n    color: '#4CAF50',\n    prompt:\n      'check if this is non-sales scenario approach from someone who likes to contact in a non-business context.',\n  },\n  {\n    key: 'is_business',\n    name: 'Business',\n    color: '#af4c87',\n    prompt: 'check if this looks like work related email',\n  },\n  {\n    key: 'is_service_important',\n    name: 'Service Important',\n    color: '#F44336',\n    prompt:\n      'check if email contains important information related to already subscribed service (if this is subscription offer - ignore it): bill, password reset, login link, 2fa code, expiration notice. Consider common services like electricity, bank account, netflix, or similar subscription service.',\n  },\n  {\n    key: 'is_service_not_important',\n    name: 'Service Info',\n    color: '#9E9E9E',\n    prompt:\n      'check if email contains non critical information from already subscribed service (if this is subscription offer - ignore it) - like: daily posts update from linkedin, AWS invitation for conference, cross sale, tips how to use product, surveys, new offers',\n  },\n  {\n    key: 'is_bill',\n    name: 'Bill',\n    color: '#f4b136',\n    prompt: 'check if email contains bill or invoice information.',\n  },\n  {\n    key: 'has_calendar_invite',\n    name: 'Appointment',\n    color: '#7F07f2',\n    prompt:\n      'check if the mail has invitation to the call or meeting (with calendar appointment attached)',\n  },\n] as const;\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\nexport const DEFAULTS: Readonly<DefaultConfig> = {\n  provider: Provider.OLLAMA,\n  ollamaApiUrl: 'http://localhost:11434/api/generate',\n  ollamaModel: 'gemma3:27b',\n  openaiApiKey: '',\n  geminiApiKey: '',\n  claudeApiKey: '',\n  mistralApiKey: '',\n  deepseekApiKey: '',\n  zaiPaasApiKey: '',\n  zaiPaasModel: 'glm-4.5',\n  zaiCodingApiKey: '',\n  zaiCodingModel: 'glm-4.7',\n  customTags: DEFAULT_CUSTOM_TAGS,\n  enableNotifications: true,\n  enableLogging: true,\n  model: undefined,\n  modelConcurrencyLimits: undefined,\n} as const;\n\n// ============================================================================\n// Analysis Prompt Template\n// ============================================================================\n\nconst PROMPT_INSTRUCTIONS: ReadonlyArray<string> = [\n  'Hi, I like you to check and score an email based on the following structured data. Please respond as a single, clean JSON object with the specified properties.',\n  '',\n  '### Email Headers',\n  '```json',\n  '{headers}',\n  '```',\n  '',\n  '### Email Body (converted from HTML to plain text)',\n  '```text',\n  '{body}',\n  '```',\n  '',\n  '### Attachments',\n  '```json',\n  '{attachments}',\n  '```',\n  '',\n  '### DEFINED TAGS - YOU MUST USE ONLY THESE',\n  'You MUST ONLY use tags from the list below. Do NOT invent or create new tags!',\n  '',\n] as const;\n\nexport const PROMPT_BASE: string = PROMPT_INSTRUCTIONS.join('\\n');\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\n/**\n * Type guard to check if a provider value is valid\n */\nexport function isValidProvider(provider: string): provider is Provider {\n  return Object.values(Provider).includes(provider as Provider);\n}\n\n/**\n * Type guard to check if a tag is a hardcoded tag\n */\nexport function isHardcodedTag(tag: Tag): tag is Tag & { key: HardcodedTagKey } {\n  return Object.keys(HARDCODED_TAGS).includes(tag.key as HardcodedTagKey);\n}\n\n/**\n * Type guard to check if a value is a valid tag color\n */\nexport function isValidColor(color: string): boolean {\n  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n}\n\nconst PROVIDER_DEFAULT_CONCURRENCY: Record<Provider, number> = {\n  [Provider.OLLAMA]: 5,\n  [Provider.OPENAI]: 10,\n  [Provider.GEMINI]: 5,\n  [Provider.CLAUDE]: 5,\n  [Provider.MISTRAL]: 10,\n  [Provider.DEEPSEEK]: 10,\n  [Provider.ZAI_PAAS]: 5,\n  [Provider.ZAI_CODING]: 5,\n} as const;\n\nexport function getConcurrencyLimit(config: AppConfig, provider: string, model: string): number {\n  if (!config.modelConcurrencyLimits) {\n    return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n  }\n\n  const modelConfig = config.modelConcurrencyLimits.find(\n    (c) => c.provider === provider && c.model === model\n  );\n\n  if (modelConfig && modelConfig.concurrency > 0) {\n    return modelConfig.concurrency;\n  }\n\n  const providerConfig = config.modelConcurrencyLimits.find(\n    (c) => c.provider === provider && !c.model\n  );\n\n  if (providerConfig && providerConfig.concurrency > 0) {\n    return providerConfig.concurrency;\n  }\n\n  return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n}\n\nexport function validateConcurrencyConfig(config: ModelConcurrencyConfig[]): string[] {\n  const errors: string[] = [];\n\n  for (const entry of config) {\n    if (!isValidProvider(entry.provider)) {\n      errors.push(`Invalid provider: ${entry.provider}`);\n    }\n\n    if (!entry.model && !entry.provider) {\n      errors.push('Either provider or model must be specified');\n    }\n\n    if (\n      entry.concurrency !== undefined &&\n      (entry.concurrency < 1 || !Number.isInteger(entry.concurrency))\n    ) {\n      errors.push(\n        `Invalid concurrency value for ${entry.provider}/${entry.model}: ${entry.concurrency}. Must be a positive integer.`\n      );\n    }\n  }\n\n  return errors;\n}\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "// ============================================================================\n// Tag Configuration Types\n// ============================================================================\n\n/**\n * Represents a single tag configuration\n */\nexport interface Tag {\n  key: string;\n  name: string;\n  color: string;\n  prompt?: string;\n  thresholdOverride?: number;\n}\n\n/**\n * Type for the key of a hardcoded tag\n */\nexport type HardcodedTagKey = 'is_scam' | 'spf_fail' | 'dkim_fail' | 'tagged' | 'email_ai_analyzed';\n\n/**\n * Readonly map of hardcoded tags with their configurations\n */\nexport type HardcodedTags = Record<HardcodedTagKey, Tag>;\n\n/**\n * Array of custom tag configurations\n */\nexport type CustomTags = ReadonlyArray<Tag>;\n\n/**\n * Combined type for all tags\n */\nexport type AllTags = HardcodedTags & CustomTags;\n\n// ============================================================================\n// Provider Configuration Types\n// ============================================================================\n\n/**\n * Supported AI providers\n */\nexport enum Provider {\n  OLLAMA = 'ollama',\n  OPENAI = 'openai',\n  GEMINI = 'gemini',\n  CLAUDE = 'claude',\n  MISTRAL = 'mistral',\n  DEEPSEEK = 'deepseek',\n  ZAI_PAAS = 'zai-paas',\n  ZAI_CODING = 'zai-coding',\n}\n\n/**\n * Provider API configuration interface\n */\nexport interface ProviderConfig {\n  provider: Provider;\n  ollamaApiUrl: string;\n  ollamaModel: string;\n  openaiApiKey: string;\n  geminiApiKey: string;\n  claudeApiKey: string;\n  mistralApiKey: string;\n  deepseekApiKey: string;\n  zaiPaasApiKey: string;\n  zaiPaasModel: string;\n  zaiCodingApiKey: string;\n  zaiCodingModel: string;\n  model?: string;\n}\n\n// ============================================================================\n// Analysis Configuration Types\n// ============================================================================\n\n/**\n * Analysis context limits\n */\nexport interface AnalysisLimits {\n  contextCharLimit: number;\n}\n\n/**\n * Analysis prompt template interface\n */\nexport interface AnalysisPrompt {\n  template: string;\n  instructions: ReadonlyArray<string>;\n}\n\n/**\n * Feature flags for analysis\n */\nexport interface AnalysisFeatures {\n  enableNotifications: boolean;\n  enableLogging: boolean;\n}\n\n/**\n * Complete application configuration\n */\nexport interface ModelConcurrencyConfig {\n  provider: string;\n  model?: string;\n  concurrency: number;\n}\n\nexport interface AppConfig extends ProviderConfig, AnalysisFeatures {\n  customTags: CustomTags;\n  modelConcurrencyLimits?: ModelConcurrencyConfig[];\n}\n\n/**\n * Default configuration structure\n */\nexport interface DefaultConfig extends AppConfig {}\n\n// ============================================================================\n// Tag Key Constants\n// ============================================================================\n\nexport const TAG_KEY_PREFIX: string = '_ma_' as const;\nexport const TAG_NAME_PREFIX: string = 'A:' as const;\n\n// ============================================================================\n// Hardcoded Tags (readonly with const assertion)\n// ============================================================================\n\nexport const HARDCODED_TAGS: HardcodedTags = {\n  is_scam: { key: 'is_scam', name: 'Scam Alert', color: '#FF5722' },\n  spf_fail: { key: 'spf_fail', name: 'SPF Fail', color: '#E91E63' },\n  dkim_fail: { key: 'dkim_fail', name: 'DKIM Fail', color: '#E91E63' },\n  tagged: { key: 'tagged', name: 'Tagged', color: '#4f4f4f' },\n  email_ai_analyzed: { key: 'email_ai_analyzed', name: 'AI Analyzed', color: '#9E9E9E' },\n} as const;\n\n// ============================================================================\n// Default Custom Tags (readonly array)\n// ============================================================================\n\nexport const DEFAULT_CUSTOM_TAGS: CustomTags = [\n  {\n    key: 'is_advertise',\n    name: 'Advertisement',\n    color: '#FFC107',\n    prompt:\n      'check if email is advertising something and contains an offer or someone is asking for contact to show the offer',\n  },\n  {\n    key: 'is_business_approach',\n    name: 'Business Ad',\n    color: '#2196F3',\n    prompt:\n      'check if email is a cold marketing/sales/business approach (or next message in the approach process where sender reply to self to refresh the approach in the mailbox). Consider typical sales and lead generation scenarios.',\n  },\n  {\n    key: 'is_personal',\n    name: 'Personal',\n    color: '#4CAF50',\n    prompt:\n      'check if this is non-sales scenario approach from someone who likes to contact in a non-business context.',\n  },\n  {\n    key: 'is_business',\n    name: 'Business',\n    color: '#af4c87',\n    prompt: 'check if this looks like work related email',\n  },\n  {\n    key: 'is_service_important',\n    name: 'Service Important',\n    color: '#F44336',\n    prompt:\n      'check if email contains important information related to already subscribed service (if this is subscription offer - ignore it): bill, password reset, login link, 2fa code, expiration notice. Consider common services like electricity, bank account, netflix, or similar subscription service.',\n  },\n  {\n    key: 'is_service_not_important',\n    name: 'Service Info',\n    color: '#9E9E9E',\n    prompt:\n      'check if email contains non critical information from already subscribed service (if this is subscription offer - ignore it) - like: daily posts update from linkedin, AWS invitation for conference, cross sale, tips how to use product, surveys, new offers',\n  },\n  {\n    key: 'is_bill',\n    name: 'Bill',\n    color: '#f4b136',\n    prompt: 'check if email contains bill or invoice information.',\n  },\n  {\n    key: 'has_calendar_invite',\n    name: 'Appointment',\n    color: '#7F07f2',\n    prompt:\n      'check if the mail has invitation to the call or meeting (with calendar appointment attached)',\n  },\n] as const;\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\nexport const DEFAULTS: Readonly<DefaultConfig> = {\n  provider: Provider.OLLAMA,\n  ollamaApiUrl: 'http://localhost:11434/api/generate',\n  ollamaModel: 'gemma3:27b',\n  openaiApiKey: '',\n  geminiApiKey: '',\n  claudeApiKey: '',\n  mistralApiKey: '',\n  deepseekApiKey: '',\n  zaiPaasApiKey: '',\n  zaiPaasModel: 'glm-4.5',\n  zaiCodingApiKey: '',\n  zaiCodingModel: 'glm-4.7',\n  customTags: DEFAULT_CUSTOM_TAGS,\n  enableNotifications: true,\n  enableLogging: true,\n  model: undefined,\n  modelConcurrencyLimits: undefined,\n} as const;\n\n// ============================================================================\n// Analysis Prompt Template\n// ============================================================================\n\nconst PROMPT_INSTRUCTIONS: ReadonlyArray<string> = [\n  'Hi, I like you to check and score an email based on the following structured data. Please respond as a single, clean JSON object with the specified properties.',\n  '',\n  '### Email Headers',\n  '```json',\n  '{headers}',\n  '```',\n  '',\n  '### Email Body (converted from HTML to plain text)',\n  '```text',\n  '{body}',\n  '```',\n  '',\n  '### Attachments',\n  '```json',\n  '{attachments}',\n  '```',\n  '',\n  '### DEFINED TAGS - YOU MUST USE ONLY THESE',\n  'You MUST ONLY use tags from the list below. Do NOT invent or create new tags!',\n  '',\n] as const;\n\nexport const PROMPT_BASE: string = PROMPT_INSTRUCTIONS.join('\\n');\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\n/**\n * Type guard to check if a provider value is valid\n */\nexport function isValidProvider(provider: string): provider is Provider {\n  return Object.values(Provider).includes(provider as Provider);\n}\n\n/**\n * Type guard to check if a tag is a hardcoded tag\n */\nexport function isHardcodedTag(tag: Tag): tag is Tag & { key: HardcodedTagKey } {\n  return Object.keys(HARDCODED_TAGS).includes(tag.key as HardcodedTagKey);\n}\n\n/**\n * Type guard to check if a value is a valid tag color\n */\nexport function isValidColor(color: string): boolean {\n  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n}\n\nconst PROVIDER_DEFAULT_CONCURRENCY: Record<Provider, number> = {\n  [Provider.OLLAMA]: 5,\n  [Provider.OPENAI]: 10,\n  [Provider.GEMINI]: 5,\n  [Provider.CLAUDE]: 5,\n  [Provider.MISTRAL]: 10,\n  [Provider.DEEPSEEK]: 10,\n  [Provider.ZAI_PAAS]: 5,\n  [Provider.ZAI_CODING]: 5,\n} as const;\n\nexport function getConcurrencyLimit(config: AppConfig, provider: string, model: string): number {\n  if (!config.modelConcurrencyLimits) {\n    return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n  }\n\n  const modelConfig = config.modelConcurrencyLimits.find(\n    (c) => c.provider === provider && c.model === model\n  );\n\n  if (modelConfig && modelConfig.concurrency > 0) {\n    return modelConfig.concurrency;\n  }\n\n  const providerConfig = config.modelConcurrencyLimits.find(\n    (c) => c.provider === provider && !c.model\n  );\n\n  if (providerConfig && providerConfig.concurrency > 0) {\n    return providerConfig.concurrency;\n  }\n\n  return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n}\n\nexport function validateConcurrencyConfig(config: ModelConcurrencyConfig[]): string[] {\n  const errors: string[] = [];\n\n  for (const entry of config) {\n    if (!isValidProvider(entry.provider)) {\n      errors.push(`Invalid provider: ${entry.provider}`);\n    }\n\n    if (!entry.model && !entry.provider) {\n      errors.push('Either provider or model must be specified');\n    }\n\n    if (\n      entry.concurrency !== undefined &&\n      (entry.concurrency < 1 || !Number.isInteger(entry.concurrency))\n    ) {\n      errors.push(\n        `Invalid concurrency value for ${entry.provider}/${entry.model}: ${entry.concurrency}. Must be a positive integer.`\n      );\n    }\n  }\n\n  return errors;\n}\n",
        "last_modified": "2026-01-05T19:59:00.201432"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "010-confidence-score-display-and-threshold-configurati": {
      "task_id": "010-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "bdfad3eb512d2cde785819b3e597f39d954633f3",
        "content": "// ============================================================================\n// Tag Configuration Types\n// ============================================================================\n\n/**\n * Represents a single tag configuration\n */\nexport interface Tag {\n  key: string;\n  name: string;\n  color: string;\n  prompt?: string;\n}\n\n/**\n * Type for the key of a hardcoded tag\n */\nexport type HardcodedTagKey = 'is_scam' | 'spf_fail' | 'dkim_fail' | 'tagged' | 'email_ai_analyzed';\n\n/**\n * Readonly map of hardcoded tags with their configurations\n */\nexport type HardcodedTags = Record<HardcodedTagKey, Tag>;\n\n/**\n * Array of custom tag configurations\n */\nexport type CustomTags = ReadonlyArray<Tag>;\n\n/**\n * Combined type for all tags\n */\nexport type AllTags = HardcodedTags & CustomTags;\n\n// ============================================================================\n// Provider Configuration Types\n// ============================================================================\n\n/**\n * Supported AI providers\n */\nexport enum Provider {\n  OLLAMA = 'ollama',\n  OPENAI = 'openai',\n  GEMINI = 'gemini',\n  CLAUDE = 'claude',\n  MISTRAL = 'mistral',\n  DEEPSEEK = 'deepseek',\n  ZAI_PAAS = 'zai-paas',\n  ZAI_CODING = 'zai-coding',\n}\n\n/**\n * Provider API configuration interface\n */\nexport interface ProviderConfig {\n  provider: Provider;\n  ollamaApiUrl: string;\n  ollamaModel: string;\n  openaiApiKey: string;\n  geminiApiKey: string;\n  claudeApiKey: string;\n  mistralApiKey: string;\n  deepseekApiKey: string;\n  zaiPaasApiKey: string;\n  zaiPaasModel: string;\n  zaiCodingApiKey: string;\n  zaiCodingModel: string;\n  model?: string;\n}\n\n// ============================================================================\n// Analysis Configuration Types\n// ============================================================================\n\n/**\n * Analysis context limits\n */\nexport interface AnalysisLimits {\n  contextCharLimit: number;\n}\n\n/**\n * Analysis prompt template interface\n */\nexport interface AnalysisPrompt {\n  template: string;\n  instructions: ReadonlyArray<string>;\n}\n\n/**\n * Feature flags for analysis\n */\nexport interface AnalysisFeatures {\n  enableNotifications: boolean;\n  enableLogging: boolean;\n}\n\n/**\n * Complete application configuration\n */\nexport interface ModelConcurrencyConfig {\n  provider: string;\n  model?: string;\n  concurrency: number;\n}\n\nexport interface AppConfig extends ProviderConfig, AnalysisFeatures {\n  customTags: CustomTags;\n  modelConcurrencyLimits?: ModelConcurrencyConfig[];\n}\n\n/**\n * Default configuration structure\n */\nexport interface DefaultConfig extends AppConfig {}\n\n// ============================================================================\n// Tag Key Constants\n// ============================================================================\n\nexport const TAG_KEY_PREFIX: string = '_ma_' as const;\nexport const TAG_NAME_PREFIX: string = 'A:' as const;\n\n// ============================================================================\n// Hardcoded Tags (readonly with const assertion)\n// ============================================================================\n\nexport const HARDCODED_TAGS: HardcodedTags = {\n  is_scam: { key: 'is_scam', name: 'Scam Alert', color: '#FF5722' },\n  spf_fail: { key: 'spf_fail', name: 'SPF Fail', color: '#E91E63' },\n  dkim_fail: { key: 'dkim_fail', name: 'DKIM Fail', color: '#E91E63' },\n  tagged: { key: 'tagged', name: 'Tagged', color: '#4f4f4f' },\n  email_ai_analyzed: { key: 'email_ai_analyzed', name: 'AI Analyzed', color: '#9E9E9E' },\n} as const;\n\n// ============================================================================\n// Default Custom Tags (readonly array)\n// ============================================================================\n\nexport const DEFAULT_CUSTOM_TAGS: CustomTags = [\n  {\n    key: 'is_advertise',\n    name: 'Advertisement',\n    color: '#FFC107',\n    prompt:\n      'check if email is advertising something and contains an offer or someone is asking for contact to show the offer',\n  },\n  {\n    key: 'is_business_approach',\n    name: 'Business Ad',\n    color: '#2196F3',\n    prompt:\n      'check if email is a cold marketing/sales/business approach (or next message in the approach process where sender reply to self to refresh the approach in the mailbox). Consider typical sales and lead generation scenarios.',\n  },\n  {\n    key: 'is_personal',\n    name: 'Personal',\n    color: '#4CAF50',\n    prompt:\n      'check if this is non-sales scenario approach from someone who likes to contact in a non-business context.',\n  },\n  {\n    key: 'is_business',\n    name: 'Business',\n    color: '#af4c87',\n    prompt: 'check if this looks like work related email',\n  },\n  {\n    key: 'is_service_important',\n    name: 'Service Important',\n    color: '#F44336',\n    prompt:\n      'check if email contains important information related to already subscribed service (if this is subscription offer - ignore it): bill, password reset, login link, 2fa code, expiration notice. Consider common services like electricity, bank account, netflix, or similar subscription service.',\n  },\n  {\n    key: 'is_service_not_important',\n    name: 'Service Info',\n    color: '#9E9E9E',\n    prompt:\n      'check if email contains non critical information from already subscribed service (if this is subscription offer - ignore it) - like: daily posts update from linkedin, AWS invitation for conference, cross sale, tips how to use product, surveys, new offers',\n  },\n  {\n    key: 'is_bill',\n    name: 'Bill',\n    color: '#f4b136',\n    prompt: 'check if email contains bill or invoice information.',\n  },\n  {\n    key: 'has_calendar_invite',\n    name: 'Appointment',\n    color: '#7F07f2',\n    prompt:\n      'check if the mail has invitation to the call or meeting (with calendar appointment attached)',\n  },\n] as const;\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\nexport const DEFAULTS: Readonly<DefaultConfig> = {\n  provider: Provider.OLLAMA,\n  ollamaApiUrl: 'http://localhost:11434/api/generate',\n  ollamaModel: 'gemma3:27b',\n  openaiApiKey: '',\n  geminiApiKey: '',\n  claudeApiKey: '',\n  mistralApiKey: '',\n  deepseekApiKey: '',\n  zaiPaasApiKey: '',\n  zaiPaasModel: 'glm-4.5',\n  zaiCodingApiKey: '',\n  zaiCodingModel: 'glm-4.7',\n  customTags: DEFAULT_CUSTOM_TAGS,\n  enableNotifications: true,\n  enableLogging: true,\n  model: undefined,\n  modelConcurrencyLimits: undefined,\n} as const;\n\n// ============================================================================\n// Analysis Prompt Template\n// ============================================================================\n\nconst PROMPT_INSTRUCTIONS: ReadonlyArray<string> = [\n  'Hi, I like you to check and score an email based on the following structured data. Please respond as a single, clean JSON object with the specified properties.',\n  '',\n  '### Email Headers',\n  '```json',\n  '{headers}',\n  '```',\n  '',\n  '### Email Body (converted from HTML to plain text)',\n  '```text',\n  '{body}',\n  '```',\n  '',\n  '### Attachments',\n  '```json',\n  '{attachments}',\n  '```',\n  '',\n  '### DEFINED TAGS - YOU MUST USE ONLY THESE',\n  'You MUST ONLY use tags from the list below. Do NOT invent or create new tags!',\n  '',\n] as const;\n\nexport const PROMPT_BASE: string = PROMPT_INSTRUCTIONS.join('\\n');\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\n/**\n * Type guard to check if a provider value is valid\n */\nexport function isValidProvider(provider: string): provider is Provider {\n  return Object.values(Provider).includes(provider as Provider);\n}\n\n/**\n * Type guard to check if a tag is a hardcoded tag\n */\nexport function isHardcodedTag(tag: Tag): tag is Tag & { key: HardcodedTagKey } {\n  return Object.keys(HARDCODED_TAGS).includes(tag.key as HardcodedTagKey);\n}\n\n/**\n * Type guard to check if a value is a valid tag color\n */\nexport function isValidColor(color: string): boolean {\n  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n}\n\nconst PROVIDER_DEFAULT_CONCURRENCY: Record<Provider, number> = {\n  [Provider.OLLAMA]: 5,\n  [Provider.OPENAI]: 10,\n  [Provider.GEMINI]: 5,\n  [Provider.CLAUDE]: 5,\n  [Provider.MISTRAL]: 10,\n  [Provider.DEEPSEEK]: 10,\n  [Provider.ZAI_PAAS]: 5,\n  [Provider.ZAI_CODING]: 5,\n} as const;\n\nexport function getConcurrencyLimit(config: AppConfig, provider: string, model: string): number {\n  if (!config.modelConcurrencyLimits) {\n    return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n  }\n\n  const modelConfig = config.modelConcurrencyLimits.find(\n    (c) => c.provider === provider && c.model === model\n  );\n\n  if (modelConfig && modelConfig.concurrency > 0) {\n    return modelConfig.concurrency;\n  }\n\n  const providerConfig = config.modelConcurrencyLimits.find(\n    (c) => c.provider === provider && !c.model\n  );\n\n  if (providerConfig && providerConfig.concurrency > 0) {\n    return providerConfig.concurrency;\n  }\n\n  return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n}\n\nexport function validateConcurrencyConfig(config: ModelConcurrencyConfig[]): string[] {\n  const errors: string[] = [];\n\n  for (const entry of config) {\n    if (!isValidProvider(entry.provider)) {\n      errors.push(`Invalid provider: ${entry.provider}`);\n    }\n\n    if (!entry.model && !entry.provider) {\n      errors.push('Either provider or model must be specified');\n    }\n\n    if (\n      entry.concurrency !== undefined &&\n      (entry.concurrency < 1 || !Number.isInteger(entry.concurrency))\n    ) {\n      errors.push(\n        `Invalid concurrency value for ${entry.provider}/${entry.model}: ${entry.concurrency}. Must be a positive integer.`\n      );\n    }\n  }\n\n  return errors;\n}\n",
        "timestamp": "2026-01-06T07:24:51.082736"
      },
      "worktree_state": {
        "content": "// ============================================================================\n// Tag Configuration Types\n// ============================================================================\n\n/**\n * Represents a single tag configuration\n */\nexport interface Tag {\n  key: string;\n  name: string;\n  color: string;\n  prompt?: string;\n  minConfidenceThreshold?: number;\n}\n\n/**\n * Type for the key of a hardcoded tag\n */\nexport type HardcodedTagKey = 'is_scam' | 'spf_fail' | 'dkim_fail' | 'tagged' | 'email_ai_analyzed';\n\n/**\n * Readonly map of hardcoded tags with their configurations\n */\nexport type HardcodedTags = Record<HardcodedTagKey, Tag>;\n\n/**\n * Array of custom tag configurations\n */\nexport type CustomTags = ReadonlyArray<Tag>;\n\n/**\n * Combined type for all tags\n */\nexport type AllTags = HardcodedTags & CustomTags;\n\n// ============================================================================\n// Provider Configuration Types\n// ============================================================================\n\n/**\n * Supported AI providers\n */\nexport enum Provider {\n  OLLAMA = 'ollama',\n  OPENAI = 'openai',\n  GEMINI = 'gemini',\n  CLAUDE = 'claude',\n  MISTRAL = 'mistral',\n  DEEPSEEK = 'deepseek',\n  ZAI_PAAS = 'zai-paas',\n  ZAI_CODING = 'zai-coding',\n}\n\n/**\n * Provider API configuration interface\n */\nexport interface ProviderConfig {\n  provider: Provider;\n  ollamaApiUrl: string;\n  ollamaModel: string;\n  openaiApiKey: string;\n  geminiApiKey: string;\n  claudeApiKey: string;\n  mistralApiKey: string;\n  deepseekApiKey: string;\n  zaiPaasApiKey: string;\n  zaiPaasModel: string;\n  zaiCodingApiKey: string;\n  zaiCodingModel: string;\n  model?: string;\n}\n\n// ============================================================================\n// Analysis Configuration Types\n// ============================================================================\n\n/**\n * Analysis context limits\n */\nexport interface AnalysisLimits {\n  contextCharLimit: number;\n}\n\n/**\n * Analysis prompt template interface\n */\nexport interface AnalysisPrompt {\n  template: string;\n  instructions: ReadonlyArray<string>;\n}\n\n/**\n * Feature flags for analysis\n */\nexport interface AnalysisFeatures {\n  enableNotifications: boolean;\n  enableLogging: boolean;\n}\n\n/**\n * Model concurrency configuration\n */\nexport interface ModelConcurrencyConfig {\n  provider: string;\n  model?: string;\n  concurrency: number;\n}\n\n/**\n * Confidence threshold configuration\n */\nexport interface AppConfig extends ProviderConfig, AnalysisFeatures {\n  customTags: CustomTags;\n  modelConcurrencyLimits?: ModelConcurrencyConfig[];\n  minConfidenceThreshold: number;\n}\n\n/**\n * Default configuration structure\n */\nexport interface DefaultConfig extends AppConfig {}\n\n// ============================================================================\n// Tag Key Constants\n// ============================================================================\n\nexport const TAG_KEY_PREFIX: string = '_ma_' as const;\nexport const TAG_NAME_PREFIX: string = 'A:' as const;\n\n// ============================================================================\n// Hardcoded Tags (readonly with const assertion)\n// ============================================================================\n\nexport const HARDCODED_TAGS: HardcodedTags = {\n  is_scam: { key: 'is_scam', name: 'Scam Alert', color: '#FF5722' },\n  spf_fail: { key: 'spf_fail', name: 'SPF Fail', color: '#E91E63' },\n  dkim_fail: { key: 'dkim_fail', name: 'DKIM Fail', color: '#E91E63' },\n  tagged: { key: 'tagged', name: 'Tagged', color: '#4f4f4f' },\n  email_ai_analyzed: { key: 'email_ai_analyzed', name: 'AI Analyzed', color: '#9E9E9E' },\n} as const;\n\n// ============================================================================\n// Default Custom Tags (readonly array)\n// ============================================================================\n\nexport const DEFAULT_CUSTOM_TAGS: CustomTags = [\n  {\n    key: 'is_advertise',\n    name: 'Advertisement',\n    color: '#FFC107',\n    prompt:\n      'check if email is advertising something and contains an offer or someone is asking for contact to show the offer',\n  },\n  {\n    key: 'is_business_approach',\n    name: 'Business Ad',\n    color: '#2196F3',\n    prompt:\n      'check if email is a cold marketing/sales/business approach (or next message in the approach process where sender reply to self to refresh the approach in the mailbox). Consider typical sales and lead generation scenarios.',\n  },\n  {\n    key: 'is_personal',\n    name: 'Personal',\n    color: '#4CAF50',\n    prompt:\n      'check if this is non-sales scenario approach from someone who likes to contact in a non-business context.',\n  },\n  {\n    key: 'is_business',\n    name: 'Business',\n    color: '#af4c87',\n    prompt: 'check if this looks like work related email',\n  },\n  {\n    key: 'is_service_important',\n    name: 'Service Important',\n    color: '#F44336',\n    prompt:\n      'check if email contains important information related to already subscribed service (if this is subscription offer - ignore it): bill, password reset, login link, 2fa code, expiration notice. Consider common services like electricity, bank account, netflix, or similar subscription service.',\n  },\n  {\n    key: 'is_service_not_important',\n    name: 'Service Info',\n    color: '#9E9E9E',\n    prompt:\n      'check if email contains non critical information from already subscribed service (if this is subscription offer - ignore it) - like: daily posts update from linkedin, AWS invitation for conference, cross sale, tips how to use product, surveys, new offers',\n  },\n  {\n    key: 'is_bill',\n    name: 'Bill',\n    color: '#f4b136',\n    prompt: 'check if email contains bill or invoice information.',\n  },\n  {\n    key: 'has_calendar_invite',\n    name: 'Appointment',\n    color: '#7F07f2',\n    prompt:\n      'check if the mail has invitation to the call or meeting (with calendar appointment attached)',\n  },\n] as const;\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\nexport const DEFAULTS: Readonly<DefaultConfig> = {\n  provider: Provider.OLLAMA,\n  ollamaApiUrl: 'http://localhost:11434/api/generate',\n  ollamaModel: 'gemma3:27b',\n  openaiApiKey: '',\n  geminiApiKey: '',\n  claudeApiKey: '',\n  mistralApiKey: '',\n  deepseekApiKey: '',\n  zaiPaasApiKey: '',\n  zaiPaasModel: 'glm-4.5',\n  zaiCodingApiKey: '',\n  zaiCodingModel: 'glm-4.7',\n  customTags: DEFAULT_CUSTOM_TAGS,\n  enableNotifications: true,\n  enableLogging: true,\n  model: undefined,\n  modelConcurrencyLimits: undefined,\n  minConfidenceThreshold: 70,\n} as const;\n\n// ============================================================================\n// Analysis Prompt Template\n// ============================================================================\n\nconst PROMPT_INSTRUCTIONS: ReadonlyArray<string> = [\n  'Hi, I like you to check and score an email based on the following structured data. Please respond as a single, clean JSON object with the specified properties.',\n  '',\n  '### Email Headers',\n  '```json',\n  '{headers}',\n  '```',\n  '',\n  '### Email Body (converted from HTML to plain text)',\n  '```text',\n  '{body}',\n  '```',\n  '',\n  '### Attachments',\n  '```json',\n  '{attachments}',\n  '```',\n  '',\n  '### DEFINED TAGS - YOU MUST USE ONLY THESE',\n  'You MUST ONLY use tags from the list below. Do NOT invent or create new tags!',\n  '',\n] as const;\n\nexport const PROMPT_BASE: string = PROMPT_INSTRUCTIONS.join('\\n');\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\n/**\n * Type guard to check if a provider value is valid\n */\nexport function isValidProvider(provider: string): provider is Provider {\n  return Object.values(Provider).includes(provider as Provider);\n}\n\n/**\n * Type guard to check if a tag is a hardcoded tag\n */\nexport function isHardcodedTag(tag: Tag): tag is Tag & { key: HardcodedTagKey } {\n  return Object.keys(HARDCODED_TAGS).includes(tag.key as HardcodedTagKey);\n}\n\n/**\n * Type guard to check if a value is a valid tag color\n */\nexport function isValidColor(color: string): boolean {\n  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n}\n\n/**\n * Type guard to check if a confidence threshold value is valid\n */\nexport function isValidConfidenceThreshold(threshold: number): boolean {\n  return Number.isInteger(threshold) && threshold >= 0 && threshold <= 100;\n}\n\nconst PROVIDER_DEFAULT_CONCURRENCY: Record<Provider, number> = {\n  [Provider.OLLAMA]: 5,\n  [Provider.OPENAI]: 10,\n  [Provider.GEMINI]: 5,\n  [Provider.CLAUDE]: 5,\n  [Provider.MISTRAL]: 10,\n  [Provider.DEEPSEEK]: 10,\n  [Provider.ZAI_PAAS]: 5,\n  [Provider.ZAI_CODING]: 5,\n} as const;\n\nexport function getConcurrencyLimit(config: AppConfig, provider: string, model: string): number {\n  if (!config.modelConcurrencyLimits) {\n    return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n  }\n\n  const modelConfig = config.modelConcurrencyLimits.find(\n    (c) => c.provider === provider && c.model === model\n  );\n\n  if (modelConfig && modelConfig.concurrency > 0) {\n    return modelConfig.concurrency;\n  }\n\n  const providerConfig = config.modelConcurrencyLimits.find(\n    (c) => c.provider === provider && !c.model\n  );\n\n  if (providerConfig && providerConfig.concurrency > 0) {\n    return providerConfig.concurrency;\n  }\n\n  return PROVIDER_DEFAULT_CONCURRENCY[provider as Provider] ?? 5;\n}\n\nexport function validateConcurrencyConfig(config: ModelConcurrencyConfig[]): string[] {\n  const errors: string[] = [];\n\n  for (const entry of config) {\n    if (!isValidProvider(entry.provider)) {\n      errors.push(`Invalid provider: ${entry.provider}`);\n    }\n\n    if (!entry.model && !entry.provider) {\n      errors.push('Either provider or model must be specified');\n    }\n\n    if (\n      entry.concurrency !== undefined &&\n      (entry.concurrency < 1 || !Number.isInteger(entry.concurrency))\n    ) {\n      errors.push(\n        `Invalid concurrency value for ${entry.provider}/${entry.model}: ${entry.concurrency}. Must be a positive integer.`\n      );\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Validates the confidence threshold configuration\n */\nexport function validateConfidenceThreshold(threshold: number): string[] {\n  const errors: string[] = [];\n\n  if (!Number.isInteger(threshold)) {\n    errors.push(`Confidence threshold must be an integer, got: ${threshold}`);\n  }\n\n  if (threshold < 0 || threshold > 100) {\n    errors.push(\n      `Confidence threshold must be between 0 and 100, got: ${threshold}`\n    );\n  }\n\n  return errors;\n}\n\n/**\n * Validates confidence thresholds for an array of custom tags\n *\n * @param customTags - Array of custom tag configurations to validate\n * @returns Array of error messages (empty if all valid)\n *\n * @example\n * const tags = [\n *   { key: 'tag1', name: 'Tag 1', color: '#FF0000', minConfidenceThreshold: 75 },\n *   { key: 'tag2', name: 'Tag 2', color: '#00FF00', minConfidenceThreshold: 101 },\n * ];\n * const errors = validateCustomTagsThresholds(tags);\n * // Returns [\"Tag 'tag2' has invalid threshold: 101. Must be an integer between 0 and 100\"]\n */\nexport function validateCustomTagsThresholds(customTags: CustomTags): string[] {\n  const errors: string[] = [];\n\n  for (const tag of customTags) {\n    if (tag.minConfidenceThreshold === undefined) {\n      continue; // Undefined threshold is valid (uses global setting)\n    }\n\n    const threshold = tag.minConfidenceThreshold;\n\n    if (!Number.isInteger(threshold)) {\n      errors.push(\n        `Tag '${tag.key}' has invalid threshold: ${threshold}. Must be an integer between 0 and 100`\n      );\n      continue;\n    }\n\n    if (threshold < 0 || threshold > 100) {\n      errors.push(\n        `Tag '${tag.key}' has invalid threshold: ${threshold}. Must be an integer between 0 and 100`\n      );\n    }\n  }\n\n  return errors;\n}\n",
        "last_modified": "2026-01-06T15:39:51.885461"
      },
      "task_intent": {
        "title": "010-confidence-score-display-and-threshold-configurati",
        "description": "# Confidence Score Display and Threshold Configuration\n\nDisplay confidence scores for AI classifications and allow users to configure minimum confidence thresholds. Tags are only applied when confidence exceeds the threshold.\n\n## Rationale\nAddresses market gap-5: lack of transparency in AI decisions. Gmail and SaneBox don't explain why emails are categorized (pain-3-3). Users need to understand AI certainty and control when tags are applied to avoid incorrect classifications.\n\n## User Stories\n- As a cautious user, I want to see confidence scores so that I can understand how certain the AI is about its classifications\n- As a power user, I want to set minimum confidence thresholds so that only high-confidence tags are applied automatically\n\n## Acceptance Criteria\n- [ ] Confidence score (0-100%) is displayed alongside each tag suggestion\n- [ ] Global confidence threshold setting in options (default: 70%)\n- [ ] Per-tag confidence threshold override option\n- [ ] Low-confidence classifications are flagged for manual review\n- [ ] Confidence scores are stored with analysis history\n",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.147431",
  "last_updated": "2026-01-06T07:24:51.086971"
}