{
  "file_path": "src/infrastructure/repositories/IndexedDBConfigRepository.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "/**\n * IndexedDB-based configuration repository.\n *\n * Implements IConfigRepository using browser.storage.local (Chrome Storage API)\n * which is available in Thunderbird extensions and provides a Promise-based\n * interface for persistent configuration storage.\n *\n * Uses three storage namespaces (keys):\n * - 'providerSettings': Store for provider-specific settings\n * - 'customTags': Store for custom email classification tags\n * - 'appConfig': Store for application-level configuration\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { ILogger } from '../interfaces/ILogger';\nimport type {\n  IConfigRepository,\n  IAppConfig,\n  IProviderSettings,\n  ICustomTag,\n} from '../interfaces/IConfigRepository';\n\n// === Type Definitions ===\n\ninterface StorageLocal {\n  get: (\n    keys: string | string[] | Record<string, unknown> | null\n  ) => Promise<Record<string, unknown>>;\n  set: (items: Record<string, unknown>) => Promise<void>;\n  clear: () => Promise<void>;\n}\n\ninterface BrowserStorage {\n  storage: {\n    local: StorageLocal;\n  };\n}\n\n// === Type Guards ===\n\n/**\n * Type guard to check if object has browser.storage API.\n */\nfunction hasBrowserStorage(obj: unknown): obj is BrowserStorage {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const maybeStorage = obj as Record<string, unknown>;\n  if (typeof maybeStorage.storage !== 'object' || maybeStorage.storage === null) {\n    return false;\n  }\n\n  const storage = maybeStorage.storage as Record<string, unknown>;\n  if (typeof storage.local !== 'object' || storage.local === null) {\n    return false;\n  }\n\n  const local = storage.local as Record<string, unknown>;\n  return (\n    typeof local.get === 'function' &&\n    typeof local.set === 'function' &&\n    typeof local.clear === 'function'\n  );\n}\n\n// === Constants ===\n\nconst STORAGE_KEYS = {\n  PROVIDER_SETTINGS: 'providerSettings',\n  CUSTOM_TAGS: 'customTags',\n  APP_CONFIG: 'appConfig',\n} as const;\n\n// === Implementation ===\n\n@injectable()\nexport class IndexedDBConfigRepository implements IConfigRepository {\n  private readonly storage: {\n    get: (\n      keys: string | string[] | Record<string, unknown> | null\n    ) => Promise<Record<string, unknown>>;\n    set: (items: Record<string, unknown>) => Promise<void>;\n    clear: () => Promise<void>;\n  };\n\n  constructor(@inject('ILogger') private readonly logger: ILogger) {\n    // Use browser.storage.local if available (Thunderbird extension environment)\n    const browserApi = (globalThis as unknown as Record<string, unknown>).browser as\n      | BrowserStorage\n      | undefined;\n    const chromeApi = (globalThis as unknown as Record<string, unknown>).chrome as\n      | BrowserStorage\n      | undefined;\n\n    if (browserApi && hasBrowserStorage(browserApi)) {\n      this.storage = {\n        get: browserApi.storage.local.get.bind(browserApi.storage.local),\n        set: browserApi.storage.local.set.bind(browserApi.storage.local),\n        clear: browserApi.storage.local.clear.bind(browserApi.storage.local),\n      };\n      this.logger.info('Using browser.storage.local for configuration persistence');\n    } else if (chromeApi && hasBrowserStorage(chromeApi)) {\n      this.storage = {\n        get: chromeApi.storage.local.get.bind(chromeApi.storage.local),\n        set: chromeApi.storage.local.set.bind(chromeApi.storage.local),\n        clear: chromeApi.storage.local.clear.bind(chromeApi.storage.local),\n      };\n      this.logger.info('Using chrome.storage.local for configuration persistence');\n    } else {\n      throw new Error(\n        'browser.storage API not available. IndexedDBConfigRepository requires a Thunderbird extension environment.'\n      );\n    }\n  }\n\n  // === Provider Settings ===\n\n  async getProviderSettings(providerId: string): Promise<IProviderSettings> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.PROVIDER_SETTINGS);\n      const providerSettings = data[STORAGE_KEYS.PROVIDER_SETTINGS] as\n        | Record<string, IProviderSettings>\n        | undefined;\n\n      if (!providerSettings || !(providerId in providerSettings)) {\n        throw new Error(`Provider settings not found for provider: ${providerId}`);\n      }\n\n      const settings = providerSettings[providerId];\n      this.logger.debug(`Retrieved provider settings for ${providerId}`, {\n        providerId,\n        hasApiKey: !!settings.apiKey,\n        model: settings.model,\n      });\n\n      return settings;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error(`Failed to get provider settings for ${providerId}`, {\n        providerId,\n        error: message,\n      });\n      throw new Error(`Failed to get provider settings for ${providerId}: ${message}`);\n    }\n  }\n\n  async setProviderSettings(providerId: string, settings: IProviderSettings): Promise<void> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.PROVIDER_SETTINGS);\n      const providerSettings =\n        (data[STORAGE_KEYS.PROVIDER_SETTINGS] as Record<string, IProviderSettings>) || {};\n\n      providerSettings[providerId] = settings;\n\n      await this.storage.set({ [STORAGE_KEYS.PROVIDER_SETTINGS]: providerSettings });\n\n      this.logger.debug(`Saved provider settings for ${providerId}`, {\n        providerId,\n        hasApiKey: !!settings.apiKey,\n        model: settings.model,\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error(`Failed to save provider settings for ${providerId}`, {\n        providerId,\n        error: message,\n      });\n      throw new Error(`Failed to save provider settings for ${providerId}: ${message}`);\n    }\n  }\n\n  async getAllProviderSettings(): Promise<Record<string, IProviderSettings>> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.PROVIDER_SETTINGS);\n      const providerSettings =\n        (data[STORAGE_KEYS.PROVIDER_SETTINGS] as Record<string, IProviderSettings>) || {};\n\n      this.logger.debug(`Retrieved settings for ${Object.keys(providerSettings).length} providers`);\n\n      return providerSettings;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get all provider settings', { error: message });\n      throw new Error(`Failed to get all provider settings: ${message}`);\n    }\n  }\n\n  // === Custom Tags ===\n\n  async getCustomTags(): Promise<ICustomTag[]> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.CUSTOM_TAGS);\n      const customTags = (data[STORAGE_KEYS.CUSTOM_TAGS] as ICustomTag[]) || [];\n\n      this.logger.debug(`Retrieved ${customTags.length} custom tags`);\n\n      return customTags;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get custom tags', { error: message });\n      throw new Error(`Failed to get custom tags: ${message}`);\n    }\n  }\n\n  async setCustomTags(tags: ICustomTag[]): Promise<void> {\n    try {\n      await this.storage.set({ [STORAGE_KEYS.CUSTOM_TAGS]: tags });\n\n      this.logger.debug(`Saved ${tags.length} custom tags`);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save custom tags', { error: message, tagCount: tags.length });\n      throw new Error(`Failed to save custom tags: ${message}`);\n    }\n  }\n\n  // === Application Configuration ===\n\n  async getAppConfig(): Promise<IAppConfig> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.APP_CONFIG);\n      const appConfig = data[STORAGE_KEYS.APP_CONFIG] as IAppConfig | undefined;\n\n      if (!appConfig) {\n        throw new Error('Application configuration not found');\n      }\n\n      this.logger.debug('Retrieved application config', {\n        defaultProvider: appConfig.defaultProvider,\n        enableNotifications: appConfig.enableNotifications,\n        enableLogging: appConfig.enableLogging,\n      });\n\n      return appConfig;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get application config', { error: message });\n      throw new Error(`Failed to get application config: ${message}`);\n    }\n  }\n\n  async setAppConfig(config: IAppConfig): Promise<void> {\n    try {\n      await this.storage.set({ [STORAGE_KEYS.APP_CONFIG]: config });\n\n      this.logger.debug('Saved application config', {\n        defaultProvider: config.defaultProvider,\n        enableNotifications: config.enableNotifications,\n        enableLogging: config.enableLogging,\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save application config', { error: message });\n      throw new Error(`Failed to save application config: ${message}`);\n    }\n  }\n\n  // === Utility Methods ===\n\n  async clearAll(): Promise<void> {\n    try {\n      await this.storage.clear();\n      this.logger.info('Cleared all configuration data');\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to clear configuration data', { error: message });\n      throw new Error(`Failed to clear configuration data: ${message}`);\n    }\n  }\n}\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * IndexedDB-based configuration repository.\n *\n * Implements IConfigRepository using browser.storage.local (Chrome Storage API)\n * which is available in Thunderbird extensions and provides a Promise-based\n * interface for persistent configuration storage.\n *\n * Uses three storage namespaces (keys):\n * - 'providerSettings': Store for provider-specific settings\n * - 'customTags': Store for custom email classification tags\n * - 'appConfig': Store for application-level configuration\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { ILogger } from '../interfaces/ILogger';\nimport type {\n  IConfigRepository,\n  IAppConfig,\n  IProviderSettings,\n  ICustomTag,\n} from '../interfaces/IConfigRepository';\n\n// === Type Definitions ===\n\ninterface StorageLocal {\n  get: (\n    keys: string | string[] | Record<string, unknown> | null\n  ) => Promise<Record<string, unknown>>;\n  set: (items: Record<string, unknown>) => Promise<void>;\n  clear: () => Promise<void>;\n}\n\ninterface BrowserStorage {\n  storage: {\n    local: StorageLocal;\n  };\n}\n\n// === Type Guards ===\n\n/**\n * Type guard to check if object has browser.storage API.\n */\nfunction hasBrowserStorage(obj: unknown): obj is BrowserStorage {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const maybeStorage = obj as Record<string, unknown>;\n  if (typeof maybeStorage.storage !== 'object' || maybeStorage.storage === null) {\n    return false;\n  }\n\n  const storage = maybeStorage.storage as Record<string, unknown>;\n  if (typeof storage.local !== 'object' || storage.local === null) {\n    return false;\n  }\n\n  const local = storage.local as Record<string, unknown>;\n  return (\n    typeof local.get === 'function' &&\n    typeof local.set === 'function' &&\n    typeof local.clear === 'function'\n  );\n}\n\n// === Constants ===\n\nconst STORAGE_KEYS = {\n  PROVIDER_SETTINGS: 'providerSettings',\n  CUSTOM_TAGS: 'customTags',\n  APP_CONFIG: 'appConfig',\n  TAG_THRESHOLDS: 'tagThresholds',\n} as const;\n\n// === Implementation ===\n\n@injectable()\nexport class IndexedDBConfigRepository implements IConfigRepository {\n  private readonly storage: {\n    get: (\n      keys: string | string[] | Record<string, unknown> | null\n    ) => Promise<Record<string, unknown>>;\n    set: (items: Record<string, unknown>) => Promise<void>;\n    clear: () => Promise<void>;\n  };\n\n  constructor(@inject('ILogger') private readonly logger: ILogger) {\n    // Use browser.storage.local if available (Thunderbird extension environment)\n    const browserApi = (globalThis as unknown as Record<string, unknown>).browser as\n      | BrowserStorage\n      | undefined;\n    const chromeApi = (globalThis as unknown as Record<string, unknown>).chrome as\n      | BrowserStorage\n      | undefined;\n\n    if (browserApi && hasBrowserStorage(browserApi)) {\n      this.storage = {\n        get: browserApi.storage.local.get.bind(browserApi.storage.local),\n        set: browserApi.storage.local.set.bind(browserApi.storage.local),\n        clear: browserApi.storage.local.clear.bind(browserApi.storage.local),\n      };\n      this.logger.info('Using browser.storage.local for configuration persistence');\n    } else if (chromeApi && hasBrowserStorage(chromeApi)) {\n      this.storage = {\n        get: chromeApi.storage.local.get.bind(chromeApi.storage.local),\n        set: chromeApi.storage.local.set.bind(chromeApi.storage.local),\n        clear: chromeApi.storage.local.clear.bind(chromeApi.storage.local),\n      };\n      this.logger.info('Using chrome.storage.local for configuration persistence');\n    } else {\n      throw new Error(\n        'browser.storage API not available. IndexedDBConfigRepository requires a Thunderbird extension environment.'\n      );\n    }\n  }\n\n  // === Provider Settings ===\n\n  async getProviderSettings(providerId: string): Promise<IProviderSettings> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.PROVIDER_SETTINGS);\n      const providerSettings = data[STORAGE_KEYS.PROVIDER_SETTINGS] as\n        | Record<string, IProviderSettings>\n        | undefined;\n\n      if (!providerSettings || !(providerId in providerSettings)) {\n        throw new Error(`Provider settings not found for provider: ${providerId}`);\n      }\n\n      const settings = providerSettings[providerId];\n      this.logger.debug(`Retrieved provider settings for ${providerId}`, {\n        providerId,\n        hasApiKey: !!settings.apiKey,\n        model: settings.model,\n      });\n\n      return settings;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error(`Failed to get provider settings for ${providerId}`, {\n        providerId,\n        error: message,\n      });\n      throw new Error(`Failed to get provider settings for ${providerId}: ${message}`);\n    }\n  }\n\n  async setProviderSettings(providerId: string, settings: IProviderSettings): Promise<void> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.PROVIDER_SETTINGS);\n      const providerSettings =\n        (data[STORAGE_KEYS.PROVIDER_SETTINGS] as Record<string, IProviderSettings>) || {};\n\n      providerSettings[providerId] = settings;\n\n      await this.storage.set({ [STORAGE_KEYS.PROVIDER_SETTINGS]: providerSettings });\n\n      this.logger.debug(`Saved provider settings for ${providerId}`, {\n        providerId,\n        hasApiKey: !!settings.apiKey,\n        model: settings.model,\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error(`Failed to save provider settings for ${providerId}`, {\n        providerId,\n        error: message,\n      });\n      throw new Error(`Failed to save provider settings for ${providerId}: ${message}`);\n    }\n  }\n\n  async getAllProviderSettings(): Promise<Record<string, IProviderSettings>> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.PROVIDER_SETTINGS);\n      const providerSettings =\n        (data[STORAGE_KEYS.PROVIDER_SETTINGS] as Record<string, IProviderSettings>) || {};\n\n      this.logger.debug(`Retrieved settings for ${Object.keys(providerSettings).length} providers`);\n\n      return providerSettings;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get all provider settings', { error: message });\n      throw new Error(`Failed to get all provider settings: ${message}`);\n    }\n  }\n\n  // === Custom Tags ===\n\n  async getCustomTags(): Promise<ICustomTag[]> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.CUSTOM_TAGS);\n      const customTags = (data[STORAGE_KEYS.CUSTOM_TAGS] as ICustomTag[]) || [];\n\n      this.logger.debug(`Retrieved ${customTags.length} custom tags`);\n\n      return customTags;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get custom tags', { error: message });\n      throw new Error(`Failed to get custom tags: ${message}`);\n    }\n  }\n\n  async setCustomTags(tags: ICustomTag[]): Promise<void> {\n    try {\n      await this.storage.set({ [STORAGE_KEYS.CUSTOM_TAGS]: tags });\n\n      this.logger.debug(`Saved ${tags.length} custom tags`);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save custom tags', { error: message, tagCount: tags.length });\n      throw new Error(`Failed to save custom tags: ${message}`);\n    }\n  }\n\n  // === Tag Threshold Overrides ===\n\n  async getTagThreshold(tagKey: string): Promise<number | null> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.TAG_THRESHOLDS);\n      const tagThresholds = (data[STORAGE_KEYS.TAG_THRESHOLDS] as Record<string, number>) || {};\n\n      const threshold = tagThresholds[tagKey];\n      if (typeof threshold === 'number' && threshold >= 0 && threshold <= 100) {\n        this.logger.debug(`Retrieved threshold for tag ${tagKey}`, { tagKey, threshold });\n        return threshold;\n      }\n\n      this.logger.debug(`No threshold override set for tag ${tagKey}`, { tagKey });\n      return null;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error(`Failed to get threshold for tag ${tagKey}`, { tagKey, error: message });\n      throw new Error(`Failed to get threshold for tag ${tagKey}: ${message}`);\n    }\n  }\n\n  async setTagThreshold(tagKey: string, threshold: number | null): Promise<void> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.TAG_THRESHOLDS);\n      const tagThresholds = (data[STORAGE_KEYS.TAG_THRESHOLDS] as Record<string, number>) || {};\n\n      if (threshold === null) {\n        // Remove the override\n        delete tagThresholds[tagKey];\n        this.logger.debug(`Removed threshold override for tag ${tagKey}`, { tagKey });\n      } else {\n        // Validate threshold\n        if (typeof threshold !== 'number' || isNaN(threshold) || threshold < 0 || threshold > 100) {\n          throw new Error(`Invalid threshold value: ${threshold}. Must be between 0 and 100.`);\n        }\n\n        // Set or update the override\n        tagThresholds[tagKey] = threshold;\n        this.logger.debug(`Set threshold override for tag ${tagKey}`, { tagKey, threshold });\n      }\n\n      await this.storage.set({ [STORAGE_KEYS.TAG_THRESHOLDS]: tagThresholds });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error(`Failed to set threshold for tag ${tagKey}`, {\n        tagKey,\n        threshold,\n        error: message,\n      });\n      throw new Error(`Failed to set threshold for tag ${tagKey}: ${message}`);\n    }\n  }\n\n  async getAllTagThresholds(): Promise<Record<string, number>> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.TAG_THRESHOLDS);\n      const tagThresholds = (data[STORAGE_KEYS.TAG_THRESHOLDS] as Record<string, number>) || {};\n\n      this.logger.debug(`Retrieved threshold overrides for ${Object.keys(tagThresholds).length} tags`);\n\n      return tagThresholds;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get all tag thresholds', { error: message });\n      throw new Error(`Failed to get all tag thresholds: ${message}`);\n    }\n  }\n\n  // === Application Configuration ===\n\n  async getAppConfig(): Promise<IAppConfig> {\n    try {\n      const data = await this.storage.get(STORAGE_KEYS.APP_CONFIG);\n      const appConfig = data[STORAGE_KEYS.APP_CONFIG] as IAppConfig | undefined;\n\n      if (!appConfig) {\n        throw new Error('Application configuration not found');\n      }\n\n      // Ensure confidenceThreshold exists (for backward compatibility)\n      if (typeof appConfig.confidenceThreshold !== 'number') {\n        this.logger.info('confidenceThreshold not found in config, defaulting to 70');\n        appConfig.confidenceThreshold = 70;\n      }\n\n      // Validate confidenceThreshold is within valid range\n      if (appConfig.confidenceThreshold < 0 || appConfig.confidenceThreshold > 100) {\n        this.logger.warn('Invalid confidenceThreshold value, defaulting to 70', {\n          confidenceThreshold: appConfig.confidenceThreshold,\n        });\n        appConfig.confidenceThreshold = 70;\n      }\n\n      this.logger.debug('Retrieved application config', {\n        defaultProvider: appConfig.defaultProvider,\n        enableNotifications: appConfig.enableNotifications,\n        enableLogging: appConfig.enableLogging,\n        confidenceThreshold: appConfig.confidenceThreshold,\n      });\n\n      return appConfig;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get application config', { error: message });\n      throw new Error(`Failed to get application config: ${message}`);\n    }\n  }\n\n  async setAppConfig(config: IAppConfig): Promise<void> {\n    try {\n      // Validate confidenceThreshold\n      if (typeof config.confidenceThreshold !== 'number' || isNaN(config.confidenceThreshold) || config.confidenceThreshold < 0 || config.confidenceThreshold > 100) {\n        throw new Error(`Invalid confidenceThreshold value: ${config.confidenceThreshold}. Must be between 0 and 100.`);\n      }\n\n      await this.storage.set({ [STORAGE_KEYS.APP_CONFIG]: config });\n\n      this.logger.debug('Saved application config', {\n        defaultProvider: config.defaultProvider,\n        enableNotifications: config.enableNotifications,\n        enableLogging: config.enableLogging,\n        confidenceThreshold: config.confidenceThreshold,\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save application config', { error: message });\n      throw new Error(`Failed to save application config: ${message}`);\n    }\n  }\n\n  // === Utility Methods ===\n\n  async clearAll(): Promise<void> {\n    try {\n      await this.storage.clear();\n      this.logger.info('Cleared all configuration data');\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to clear configuration data', { error: message });\n      throw new Error(`Failed to clear configuration data: ${message}`);\n    }\n  }\n}\n",
        "last_modified": "2026-01-05T19:59:00.209622"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.159289",
  "last_updated": "2026-01-05T14:48:03.162919"
}