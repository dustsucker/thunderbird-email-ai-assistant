{
  "file_path": "options.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "import 'reflect-metadata';\n\nimport {\n  DEFAULTS,\n  Provider,\n  ProviderConfig,\n  CustomTags,\n  Tag,\n  isValidProvider,\n  ModelConcurrencyConfig,\n} from './core/config';\nimport {\n  ErrorSeverity,\n  ErrorType,\n  ErrorDisplay,\n  ShowErrorRuntimeMessage,\n  debounce,\n} from './src/infrastructure/providers/ProviderUtils';\n\n/**\n * Batch processing statistics\n */\ninterface BatchStatistics {\n  total: number;\n  successful: number;\n  failed: number;\n  [key: string]: unknown;\n}\nimport { ensureTagsExist } from './core/tags';\nimport { logger } from './src/infrastructure/providers/ProviderUtils';\nimport { fetchZaiModels } from './src/infrastructure/providers';\n\ndeclare const messenger: {\n  storage: {\n    local: {\n      get(\n        keys: Partial<ProviderConfig> | { customTags?: CustomTags }\n      ): Promise<Partial<ProviderConfig> & { customTags?: CustomTags }>;\n      set(items: Partial<ProviderConfig> & { customTags?: CustomTags }): Promise<void>;\n      get(keys: unknown): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n  runtime: {\n    reload(): void;\n  };\n  permissions: {\n    request(permissions: { permissions?: string[]; origins?: string[] }): Promise<boolean>;\n  };\n};\n\ninterface StorageProviderSettings {\n  [providerId: string]: {\n    apiKey: string;\n    model: string;\n    apiUrl?: string;\n  };\n}\n\ninterface AppSettingsStorage {\n  appConfig?: {\n    defaultProvider?: string;\n    enableNotifications?: boolean;\n    enableLogging?: boolean;\n  };\n  providerSettings?: StorageProviderSettings;\n  customTags?: CustomTags;\n}\n\ninterface BrowserRuntime {\n  sendMessage<T = unknown>(message: unknown, callback?: (response: T) => void): void;\n  onMessage: {\n    addListener(\n      callback: (\n        message: unknown,\n        sender: unknown,\n        sendResponse: (response?: unknown) => void\n      ) => void\n    ): void;\n  };\n  lastError?: { message: string };\n}\n\ninterface BrowserExtension {\n  runtime: BrowserRuntime;\n}\n\ndeclare global {\n  interface Window {\n    browser: BrowserExtension;\n  }\n}\n\n// ============================================================================\n// DOM Element Interfaces\n// ============================================================================\n\n/**\n * General Settings DOM Elements\n */\ninterface GeneralSettingsElements {\n  providerSelect: HTMLSelectElement;\n  generalForm: HTMLFormElement;\n  generalStatusMessage: HTMLSpanElement;\n  statusMessage: HTMLSpanElement;\n  ollamaApiUrl: HTMLInputElement | null;\n  ollamaModel: HTMLInputElement | null;\n  openaiApiKey: HTMLInputElement | null;\n  geminiApiKey: HTMLInputElement | null;\n  claudeApiKey: HTMLInputElement | null;\n  mistralApiKey: HTMLInputElement | null;\n  deepseekApiKey: HTMLInputElement | null;\n  zaiPaasApiKey: HTMLInputElement | null;\n  zaiPaasModel: HTMLSelectElement | null;\n  zaiCodingApiKey: HTMLInputElement | null;\n  zaiCodingModel: HTMLSelectElement | null;\n}\n\n/**\n * Tag Management DOM Elements\n */\ninterface TagManagementElements {\n  tagListContainer: HTMLDivElement;\n  modal: HTMLDivElement;\n  modalTitle: HTMLHeadingElement;\n  tagForm: HTMLFormElement;\n  closeModalBtn: HTMLSpanElement;\n  addNewTagBtn: HTMLButtonElement;\n  tagIndex: HTMLInputElement;\n  tagName: HTMLInputElement;\n  tagKey: HTMLInputElement;\n  tagColor: HTMLInputElement;\n  tagPrompt: HTMLTextAreaElement;\n}\n\n/**\n * Tab DOM Elements\n */\ninterface TabElements {\n  tabButtons: NodeListOf<HTMLButtonElement>;\n  tabContents: NodeListOf<HTMLDivElement>;\n}\n\n/**\n * Cache Management DOM Elements\n */\ninterface CacheManagementElements {\n  clearCacheBtn: HTMLButtonElement;\n  cacheStatusMessage: HTMLSpanElement;\n  cacheStats: HTMLSpanElement;\n}\n\n/**\n * All DOM Elements\n */\ninterface DOMElements\n  extends GeneralSettingsElements, TagManagementElements, CacheManagementElements {\n  tabs: TabElements['tabButtons'];\n  tabContents: TabElements['tabContents'];\n}\n\n// ============================================================================\n// UI State Interfaces\n// ============================================================================\n\n/**\n * Tag Form State\n */\ninterface TagFormState {\n  index: number;\n  name: string;\n  key: string;\n  color: string;\n  prompt: string;\n}\n\n/**\n * Settings Save Result\n */\ninterface SettingsSaveResult {\n  success: boolean;\n  message: string;\n}\n\n/**\n * Tag Edit Context\n */\ninterface TagEditContext {\n  tag: Tag | null;\n  index: number;\n}\n\n// ============================================================================\n// Provider Settings Types\n// ============================================================================\n\n/**\n * Settings to save for each provider type\n */\ntype ProviderSettingsData =\n  | { provider: Provider.OLLAMA; ollamaApiUrl: string; ollamaModel: string }\n  | { provider: Provider.OPENAI; openaiApiKey: string }\n  | { provider: Provider.GEMINI; geminiApiKey: string }\n  | { provider: Provider.CLAUDE; claudeApiKey: string }\n  | { provider: Provider.MISTRAL; mistralApiKey: string }\n  | { provider: Provider.DEEPSEEK; deepseekApiKey: string };\n\n/**\n * Partial provider config for saving\n */\ntype PartialProviderConfig = {\n  provider: Provider;\n  ollamaApiUrl?: string;\n  ollamaModel?: string;\n  openaiApiKey?: string;\n  geminiApiKey?: string;\n  claudeApiKey?: string;\n  mistralApiKey?: string;\n  deepseekApiKey?: string;\n  zaiPaasApiKey?: string;\n  zaiPaasModel?: string;\n  zaiCodingApiKey?: string;\n  zaiCodingModel?: string;\n};\n\n// ============================================================================\n// Storage Types\n// ============================================================================\n\n/**\n * Storage response for general settings\n */\ninterface GeneralSettingsStorage {\n  provider?: Provider;\n  ollamaApiUrl?: string;\n  ollamaModel?: string;\n  openaiApiKey?: string;\n  geminiApiKey?: string;\n  claudeApiKey?: string;\n  mistralApiKey?: string;\n  deepseekApiKey?: string;\n  zaiPaasApiKey?: string;\n  zaiPaasModel?: string;\n  zaiCodingApiKey?: string;\n  zaiCodingModel?: string;\n}\n\n/**\n * Storage response for custom tags\n */\ninterface CustomTagsStorage {\n  customTags?: CustomTags;\n}\n\n// ============================================================================\n// Event Handler Types\n// ============================================================================\n\n/**\n * Tab click event handler\n */\ntype TabClickHandler = (event: MouseEvent) => void;\n\n/**\n * Form submit event handler for general settings\n */\ntype GeneralSettingsSubmitHandler = (event: SubmitEvent) => Promise<void>;\n\n/**\n * Provider change event handler\n */\ntype ProviderChangeHandler = (event: Event) => void;\n\n/**\n * Tag list click event handler\n */\ntype TagListClickHandler = (event: MouseEvent) => void;\n\n/**\n * Tag form submit event handler\n */\ntype TagFormSubmitHandler = (event: SubmitEvent) => void;\n\n/**\n * Batch analysis click event handler\n */\ntype BatchAnalysisClickHandler = (event: MouseEvent) => void;\n\n// ============================================================================\n// Batch Analysis Types\n// ============================================================================\n\n/**\n * Batch analysis status\n */\ntype BatchStatus = 'idle' | 'running' | 'completed' | 'cancelled' | 'error';\n\n/**\n * Batch analysis progress data\n */\ninterface BatchProgress {\n  status: BatchStatus;\n  total: number;\n  processed: number;\n  successful: number;\n  failed: number;\n  startTime: number;\n  endTime?: number;\n  errorMessage?: string;\n}\n\n/**\n * Batch analysis response\n */\ninterface BatchAnalysisResponse {\n  success: boolean;\n  statistics?: BatchStatistics;\n  error?: string;\n  message?: string;\n}\n\n/**\n * Batch analysis cancel response\n */\ninterface BatchCancelResponse {\n  success: boolean;\n  message: string;\n}\n\n/**\n * Runtime message types for batch analysis\n */\ntype BatchRuntimeMessage =\n  | { action: 'startBatchAnalysis'; folderId?: string }\n  | { action: 'getBatchProgress' }\n  | { action: 'cancelBatchAnalysis' }\n  | { action: 'clearQueue'; cancelRunning?: boolean }\n  | { action: 'clearCache' }\n  | { action: 'getCacheStats' }\n  | ShowErrorRuntimeMessage;\n\n/**\n * Runtime message response types\n */\ntype BatchRuntimeResponse =\n  | BatchAnalysisResponse\n  | BatchProgress\n  | BatchCancelResponse\n  | { success: boolean; message: string };\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Type guard to check if an element is a valid provider settings element\n */\nfunction isProviderSettingsElement(element: HTMLElement | null): element is HTMLDivElement {\n  return element !== null && element.classList.contains('provider-settings');\n}\n\n/**\n * Type guard to check if an event target is a button with index data\n */\nfunction isButtonWithIndex(\n  target: EventTarget | null\n): target is HTMLButtonElement & { dataset: { index: string } } {\n  if (target === null || !(target instanceof HTMLButtonElement)) {\n    return false;\n  }\n  return 'index' in target.dataset && typeof target.dataset.index === 'string';\n}\n\n/**\n * Validates tag key format\n * Pattern: lowercase letters, numbers, underscores only\n */\nfunction isValidTagKey(key: string): boolean {\n  return /^[a-z0-9_]+$/.test(key);\n}\n\n/**\n * Validates hex color format\n */\nfunction isValidHexColor(color: string): boolean {\n  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n}\n\n/**\n * Gets permission origin for a provider\n */\nfunction getPermissionOrigin(provider: Provider, settings: PartialProviderConfig): string {\n  switch (provider) {\n    case Provider.OLLAMA:\n      if (settings.ollamaApiUrl) {\n        return new URL(settings.ollamaApiUrl).origin + '/*';\n      }\n      throw new Error('Ollama API URL is required for permission request');\n    case Provider.OPENAI:\n      return 'https://api.openai.com/';\n    case Provider.GEMINI:\n      return 'https://generativelanguage.googleapis.com/';\n    case Provider.CLAUDE:\n      return 'https://api.anthropic.com/';\n    case Provider.MISTRAL:\n      return 'https://api.mistral.ai/';\n    case Provider.DEEPSEEK:\n      return 'https://api.deepseek.com/';\n    case Provider.ZAI_PAAS:\n      return 'https://api.z.ai/';\n    case Provider.ZAI_CODING:\n      return 'https://api.z.ai/';\n    default:\n      throw new Error(`Unknown provider: ${provider}`);\n  }\n}\n\n// ============================================================================\n// DOM Element Accessors\n// ============================================================================\n\n/**\n * Safely retrieves an element by ID with type assertion\n */\nfunction getElementById<T extends HTMLElement>(id: string): T | null {\n  return document.getElementById(id) as T | null;\n}\n\n/**\n * Retrieves all general settings DOM elements\n */\nfunction getGeneralSettingsElements(): GeneralSettingsElements {\n  const providerSelect = getElementById<HTMLSelectElement>('provider');\n  const generalForm = getElementById<HTMLFormElement>('provider-options-form');\n  const generalStatusMessage = getElementById<HTMLSpanElement>('provider-status-message');\n  const statusMessage = getElementById<HTMLSpanElement>('provider-status-message');\n  const ollamaApiUrl = getElementById<HTMLInputElement>('ollama-api-url');\n  const ollamaModel = getElementById<HTMLInputElement>('ollama-model');\n  const openaiApiKey = getElementById<HTMLInputElement>('openai-api-key');\n  const geminiApiKey = getElementById<HTMLInputElement>('gemini-api-key');\n  const claudeApiKey = getElementById<HTMLInputElement>('claude-api-key');\n  const mistralApiKey = getElementById<HTMLInputElement>('mistral-api-key');\n  const deepseekApiKey = getElementById<HTMLInputElement>('deepseek-api-key');\n  const zaiPaasApiKey = getElementById<HTMLInputElement>('zaiPaasApiKey');\n  const zaiPaasModel = getElementById<HTMLSelectElement>('zaiPaasModel');\n  const zaiCodingApiKey = getElementById<HTMLInputElement>('zaiCodingApiKey');\n  const zaiCodingModel = getElementById<HTMLSelectElement>('zaiCodingModel');\n\n  if (!providerSelect || !generalForm || !generalStatusMessage || !statusMessage) {\n    throw new Error('Required general settings elements not found');\n  }\n\n  return {\n    providerSelect,\n    generalForm,\n    generalStatusMessage,\n    statusMessage,\n    ollamaApiUrl,\n    ollamaModel,\n    openaiApiKey,\n    geminiApiKey,\n    claudeApiKey,\n    mistralApiKey,\n    deepseekApiKey,\n    zaiPaasApiKey,\n    zaiPaasModel,\n    zaiCodingApiKey,\n    zaiCodingModel,\n  };\n}\n\n/**\n * Retrieves all tag management DOM elements\n */\nfunction getTagManagementElements(): TagManagementElements {\n  const tagListContainer = getElementById<HTMLDivElement>('tag-list-container');\n  const modal = getElementById<HTMLDivElement>('tag-modal');\n  const modalTitle = getElementById<HTMLHeadingElement>('modal-title');\n  const tagForm = getElementById<HTMLFormElement>('tag-form');\n  const closeModalBtn = document.querySelector<HTMLSpanElement>('.close-button');\n  const addNewTagBtn = getElementById<HTMLButtonElement>('add-new-tag-btn');\n  const tagIndex = getElementById<HTMLInputElement>('tag-index');\n  const tagName = getElementById<HTMLInputElement>('tag-name');\n  const tagKey = getElementById<HTMLInputElement>('tag-key');\n  const tagColor = getElementById<HTMLInputElement>('tag-color');\n  const tagPrompt = getElementById<HTMLTextAreaElement>('tag-prompt');\n\n  if (\n    !tagListContainer ||\n    !modal ||\n    !modalTitle ||\n    !tagForm ||\n    !closeModalBtn ||\n    !addNewTagBtn ||\n    !tagIndex ||\n    !tagName ||\n    !tagKey ||\n    !tagColor ||\n    !tagPrompt\n  ) {\n    throw new Error('Required tag management elements not found');\n  }\n\n  return {\n    tagListContainer,\n    modal,\n    modalTitle,\n    tagForm,\n    closeModalBtn,\n    addNewTagBtn,\n    tagIndex,\n    tagName,\n    tagKey,\n    tagColor,\n    tagPrompt,\n  };\n}\n\n/**\n * Retrieves all DOM elements\n */\nfunction getAllDOMElements(): DOMElements {\n  const general = getGeneralSettingsElements();\n  const tag = getTagManagementElements();\n\n  const clearCacheBtn = getElementById<HTMLButtonElement>('clear-cache-btn');\n  const cacheStatusMessage = getElementById<HTMLSpanElement>('cache-status-message');\n  const cacheStats = getElementById<HTMLSpanElement>('cache-stats');\n\n  if (!clearCacheBtn || !cacheStatusMessage || !cacheStats) {\n    throw new Error('Required cache management elements not found');\n  }\n\n  return {\n    ...general,\n    ...tag,\n    clearCacheBtn,\n    cacheStatusMessage,\n    cacheStats,\n    tabs: document.querySelectorAll('.tab-button'),\n    tabContents: document.querySelectorAll('.tab-content'),\n  };\n}\n\n// ============================================================================\n// Tab Management Functions\n// ============================================================================\n\n/**\n * Handles tab switching\n */\nfunction handleTabClick(\n  tabs: NodeListOf<HTMLButtonElement>,\n  tabContents: NodeListOf<HTMLDivElement>\n): TabClickHandler {\n  return (event: MouseEvent): void => {\n    const clickedTab = event.currentTarget as HTMLButtonElement;\n    const targetTabId = clickedTab.dataset.tab;\n\n    if (!targetTabId) {\n      logger.warn('Tab does not have data-tab attribute', { tab: clickedTab });\n      return;\n    }\n\n    tabs.forEach((tab) => tab.classList.remove('active'));\n    clickedTab.classList.add('active');\n\n    tabContents.forEach((content) => content.classList.remove('active'));\n\n    const targetContent = document.getElementById(targetTabId);\n    if (targetContent) {\n      targetContent.classList.add('active');\n    } else {\n      logger.warn('Target tab content not found', { tabId: targetTabId });\n    }\n  };\n}\n\n/**\n * Initializes tab functionality\n */\nfunction initializeTabs(\n  tabs: NodeListOf<HTMLButtonElement>,\n  tabContents: NodeListOf<HTMLDivElement>\n): void {\n  tabs.forEach((tab) => {\n    tab.addEventListener('click', handleTabClick(tabs, tabContents));\n  });\n}\n\n// ============================================================================\n// General Settings Functions\n// ============================================================================\n\n/**\n * Shows/hides provider-specific settings based on selected provider\n */\nfunction showRelevantSettings(provider: string): void {\n  logger.info('[DEBUG-options] showRelevantSettings() called', { provider });\n\n  document.querySelectorAll<HTMLElement>('.provider-settings').forEach((div) => {\n    div.style.display = 'none';\n    div\n      .querySelectorAll<HTMLInputElement | HTMLSelectElement>('input[required], select[required]')\n      .forEach((field) => {\n        field.removeAttribute('required');\n      });\n  });\n\n  const settingsToShow = document.getElementById(`${provider}-settings`);\n  if (settingsToShow && isProviderSettingsElement(settingsToShow)) {\n    logger.info('[DEBUG-options] Showing settings for provider', { provider });\n    settingsToShow.style.display = 'block';\n    settingsToShow\n      .querySelectorAll<HTMLInputElement | HTMLSelectElement>('input, select')\n      .forEach((field) => {\n        field.setAttribute('required', '');\n      });\n  } else {\n    logger.warn('[DEBUG-options] No settings found for provider', { provider });\n  }\n}\n\n/**\n * Loads general settings from storage and populates form fields\n */\nasync function loadGeneralSettings(elements: GeneralSettingsElements): Promise<void> {\n  logger.info('[DEBUG-options] loadGeneralSettings() called');\n\n  try {\n    const data = (await messenger.storage.local.get({\n      appConfig: { defaultProvider: DEFAULTS.provider },\n      providerSettings: {},\n    })) as AppSettingsStorage;\n\n    const appConfig = data.appConfig || {};\n    const providerSettings = data.providerSettings || {};\n\n    logger.info('[DEBUG-options] Storage loaded', {\n      appConfig,\n      providerSettings,\n    });\n\n    elements.providerSelect.value = appConfig.defaultProvider || DEFAULTS.provider;\n\n    if (elements.ollamaApiUrl && providerSettings.ollama) {\n      logger.info('[DEBUG-options] Loaded ollama settings', {\n        apiUrl: providerSettings.ollama.apiUrl,\n        model: providerSettings.ollama.model,\n      });\n      elements.ollamaApiUrl.value = providerSettings.ollama.apiUrl || '';\n    }\n    if (elements.ollamaModel && providerSettings.ollama) {\n      elements.ollamaModel.value = providerSettings.ollama.model || '';\n    }\n    if (elements.openaiApiKey && providerSettings.openai) {\n      logger.info('[DEBUG-options] Loaded openai settings', {\n        apiKey: providerSettings.openai.apiKey ? '***REDACTED***' : '',\n      });\n      elements.openaiApiKey.value = providerSettings.openai.apiKey || '';\n    }\n    if (elements.geminiApiKey && providerSettings.gemini) {\n      logger.info('[DEBUG-options] Loaded gemini settings', {\n        apiKey: providerSettings.gemini.apiKey ? '***REDACTED***' : '',\n      });\n      elements.geminiApiKey.value = providerSettings.gemini.apiKey || '';\n    }\n    if (elements.claudeApiKey && providerSettings.claude) {\n      logger.info('[DEBUG-options] Loaded claude settings', {\n        apiKey: providerSettings.claude.apiKey ? '***REDACTED***' : '',\n      });\n      elements.claudeApiKey.value = providerSettings.claude.apiKey || '';\n    }\n    if (elements.mistralApiKey && providerSettings.mistral) {\n      logger.info('[DEBUG-options] Loaded mistral settings', {\n        apiKey: providerSettings.mistral.apiKey ? '***REDACTED***' : '',\n      });\n      elements.mistralApiKey.value = providerSettings.mistral.apiKey || '';\n    }\n    if (elements.deepseekApiKey && providerSettings.deepseek) {\n      logger.info('[DEBUG-options] Loaded deepseek settings', {\n        apiKey: providerSettings.deepseek.apiKey ? '***REDACTED***' : '',\n      });\n      elements.deepseekApiKey.value = providerSettings.deepseek.apiKey || '';\n    }\n    if (elements.zaiPaasApiKey && providerSettings['zai-paas']) {\n      logger.info('[DEBUG-options] Loaded zai-paas settings', {\n        apiKey: providerSettings['zai-paas'].apiKey ? '***REDACTED***' : '',\n        model: providerSettings['zai-paas'].model,\n      });\n      elements.zaiPaasApiKey.value = providerSettings['zai-paas'].apiKey || '';\n    }\n    if (elements.zaiPaasModel && providerSettings['zai-paas']) {\n      elements.zaiPaasModel.value = providerSettings['zai-paas'].model || '';\n    }\n    if (elements.zaiCodingApiKey && providerSettings['zai-coding']) {\n      logger.info('[DEBUG-options] Loaded zai-coding settings', {\n        apiKey: providerSettings['zai-coding'].apiKey ? '***REDACTED***' : '',\n        model: providerSettings['zai-coding'].model,\n      });\n      elements.zaiCodingApiKey.value = providerSettings['zai-coding'].apiKey || '';\n    }\n    if (elements.zaiCodingModel && providerSettings['zai-coding']) {\n      elements.zaiCodingModel.value = providerSettings['zai-coding'].model || '';\n    }\n\n    showRelevantSettings(appConfig.defaultProvider || DEFAULTS.provider);\n\n    // Populate z.ai models if API key is present\n    if (elements.zaiPaasApiKey && elements.zaiPaasApiKey.value) {\n      logger.info('[DEBUG-options] Populating zaiPaas models on load');\n      populateZaiModels('zaiPaas').catch((error) => {\n        logger.error('Failed to populate z.ai PaaS models on load', { error });\n      });\n    }\n    if (elements.zaiCodingApiKey && elements.zaiCodingApiKey.value) {\n      logger.info('[DEBUG-options] Populating zaiCoding models on load');\n      populateZaiModels('zaiCoding').catch((error) => {\n        logger.error('Failed to populate z.ai Coding models on load', { error });\n      });\n    }\n\n    logger.info('[DEBUG-options] loadGeneralSettings() completed');\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error loading general settings', { error: errorMessage });\n  }\n}\n\n/**\n * Gathers settings data based on selected provider\n */\nfunction gatherProviderSettings(\n  provider: string,\n  elements: GeneralSettingsElements\n): PartialProviderConfig {\n  logger.info('[DEBUG-options] gatherProviderSettings() called', { provider });\n\n  const baseSettings: PartialProviderConfig = { provider: provider as Provider };\n\n  switch (provider) {\n    case Provider.OLLAMA:\n      if (!elements.ollamaApiUrl || !elements.ollamaModel) {\n        throw new Error('Ollama settings elements not found');\n      }\n      const ollamaSettings = {\n        ...baseSettings,\n        ollamaApiUrl: elements.ollamaApiUrl.value.trim(),\n        ollamaModel: elements.ollamaModel.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered ollama settings', {\n        apiUrl: ollamaSettings.ollamaApiUrl,\n        model: ollamaSettings.ollamaModel,\n      });\n      return ollamaSettings;\n\n    case Provider.OPENAI:\n      if (!elements.openaiApiKey) {\n        throw new Error('OpenAI settings element not found');\n      }\n      const openaiSettings = {\n        ...baseSettings,\n        openaiApiKey: elements.openaiApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered openai settings', {\n        apiKey: openaiSettings.openaiApiKey ? '***REDACTED***' : '',\n      });\n      return openaiSettings;\n\n    case Provider.GEMINI:\n      if (!elements.geminiApiKey) {\n        throw new Error('Gemini settings element not found');\n      }\n      const geminiSettings = {\n        ...baseSettings,\n        geminiApiKey: elements.geminiApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered gemini settings', {\n        apiKey: geminiSettings.geminiApiKey ? '***REDACTED***' : '',\n      });\n      return geminiSettings;\n\n    case Provider.CLAUDE:\n      if (!elements.claudeApiKey) {\n        throw new Error('Claude settings element not found');\n      }\n      const claudeSettings = {\n        ...baseSettings,\n        claudeApiKey: elements.claudeApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered claude settings', {\n        apiKey: claudeSettings.claudeApiKey ? '***REDACTED***' : '',\n      });\n      return claudeSettings;\n\n    case Provider.MISTRAL:\n      if (!elements.mistralApiKey) {\n        throw new Error('Mistral settings element not found');\n      }\n      const mistralSettings = {\n        ...baseSettings,\n        mistralApiKey: elements.mistralApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered mistral settings', {\n        apiKey: mistralSettings.mistralApiKey ? '***REDACTED***' : '',\n      });\n      return mistralSettings;\n\n    case Provider.DEEPSEEK:\n      if (!elements.deepseekApiKey) {\n        throw new Error('DeepSeek settings element not found');\n      }\n      const deepseekSettings = {\n        ...baseSettings,\n        deepseekApiKey: elements.deepseekApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered deepseek settings', {\n        apiKey: deepseekSettings.deepseekApiKey ? '***REDACTED***' : '',\n      });\n      return deepseekSettings;\n\n    case Provider.ZAI_PAAS:\n      if (!elements.zaiPaasApiKey || !elements.zaiPaasModel) {\n        throw new Error('Zai PaaS settings element not found');\n      }\n      const zaiPaasSettings = {\n        ...baseSettings,\n        zaiPaasApiKey: elements.zaiPaasApiKey.value.trim(),\n        zaiPaasModel: elements.zaiPaasModel.value,\n      };\n      logger.info('[DEBUG-options] Gathered zai-paas settings', {\n        apiKey: zaiPaasSettings.zaiPaasApiKey ? '***REDACTED***' : '',\n        model: zaiPaasSettings.zaiPaasModel,\n      });\n      return zaiPaasSettings;\n\n    case Provider.ZAI_CODING:\n      if (!elements.zaiCodingApiKey || !elements.zaiCodingModel) {\n        throw new Error('Zai Coding settings element not found');\n      }\n      const zaiCodingSettings = {\n        ...baseSettings,\n        zaiCodingApiKey: elements.zaiCodingApiKey.value.trim(),\n        zaiCodingModel: elements.zaiCodingModel.value,\n      };\n      logger.info('[DEBUG-options] Gathered zai-coding settings', {\n        apiKey: zaiCodingSettings.zaiCodingApiKey ? '***REDACTED***' : '',\n        model: zaiCodingSettings.zaiCodingModel,\n      });\n      return zaiCodingSettings;\n\n    default:\n      throw new Error(`Unknown provider: ${provider}`);\n  }\n}\n\n/**\n * Handles general settings form submission\n */\nasync function handleGeneralSettingsSubmit(\n  elements: GeneralSettingsElements\n): Promise<SettingsSaveResult> {\n  const provider = elements.providerSelect.value;\n\n  logger.info('[DEBUG-options] handleGeneralSettingsSubmit() called', { provider });\n\n  if (!isValidProvider(provider)) {\n    logger.warn('[DEBUG-options] Invalid provider selected', { provider });\n    return {\n      success: false,\n      message: 'Invalid provider selected',\n    };\n  }\n\n  const settingsToSave = gatherProviderSettings(provider, elements);\n  logger.info('[DEBUG-options] Gathered settings', { settingsToSave });\n\n  let permissionGranted = true;\n\n  try {\n    const permissionOrigin = getPermissionOrigin(provider as Provider, settingsToSave);\n    const hasSettings = Object.values(settingsToSave).some((val) => val && val !== '');\n\n    if (hasSettings) {\n      try {\n        logger.info('[DEBUG-options] Requesting permission for origin', {\n          origin: permissionOrigin,\n        });\n        permissionGranted = await messenger.permissions.request({\n          origins: [permissionOrigin],\n        });\n        logger.info('[DEBUG-options] Permission result', {\n          granted: permissionGranted,\n          origin: permissionOrigin,\n        });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        logger.error('[DEBUG-options] Error requesting permission', { error: errorMessage });\n        return {\n          success: false,\n          message: 'Error with permission request',\n        };\n      }\n    } else {\n      logger.info('[DEBUG-options] No settings to save, skipping permission request');\n    }\n\n    if (permissionGranted) {\n      const data = (await messenger.storage.local.get({\n        appConfig: {\n          enableNotifications: DEFAULTS.enableNotifications,\n          enableLogging: DEFAULTS.enableLogging,\n          modelConcurrencyLimits: DEFAULTS.modelConcurrencyLimits,\n        },\n        providerSettings: {},\n      })) as AppSettingsStorage;\n\n      const providerSettings = data.providerSettings || {};\n      const existingAppConfig = data.appConfig || {};\n\n      const convertedSettings = convertToProviderSettings(settingsToSave);\n      providerSettings[provider] = convertedSettings;\n\n      existingAppConfig.defaultProvider = provider as Provider;\n\n      logger.info('[DEBUG-options] Saving to storage', {\n        appConfig: existingAppConfig,\n        providerSettings,\n      });\n\n      await messenger.storage.local.set({\n        appConfig: existingAppConfig,\n        providerSettings,\n      });\n\n      logger.info('[DEBUG-options] Settings saved successfully');\n\n      return {\n        success: true,\n        message: 'Settings saved!',\n      };\n    } else {\n      logger.warn('[DEBUG-options] Permission denied, settings not saved');\n      return {\n        success: false,\n        message: 'Permission denied. Settings not saved.',\n      };\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('[DEBUG-options] Save failed', { error: errorMessage });\n    return {\n      success: false,\n      message: 'Error saving settings',\n    };\n  }\n}\n\nfunction convertToProviderSettings(settings: PartialProviderConfig) {\n  logger.info('[DEBUG-options] convertToProviderSettings() called', {\n    provider: settings.provider,\n    input: settings,\n  });\n\n  let result: { apiKey: string; model: string; apiUrl?: string };\n\n  switch (settings.provider) {\n    case Provider.OLLAMA:\n      result = {\n        apiKey: '',\n        model: settings.ollamaModel || '',\n        apiUrl: settings.ollamaApiUrl || '',\n      };\n      logger.info('[DEBUG-options] Converted ollama settings', { result });\n      return result;\n\n    case Provider.OPENAI:\n      result = {\n        apiKey: settings.openaiApiKey || '',\n        model: 'gpt-4o-mini',\n      };\n      logger.info('[DEBUG-options] Converted openai settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.GEMINI:\n      result = {\n        apiKey: settings.geminiApiKey || '',\n        model: 'gemini-2.0-flash-exp',\n      };\n      logger.info('[DEBUG-options] Converted gemini settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.CLAUDE:\n      result = {\n        apiKey: settings.claudeApiKey || '',\n        model: 'claude-3-5-sonnet-20241022',\n      };\n      logger.info('[DEBUG-options] Converted claude settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.MISTRAL:\n      result = {\n        apiKey: settings.mistralApiKey || '',\n        model: 'mistral-large-latest',\n      };\n      logger.info('[DEBUG-options] Converted mistral settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.DEEPSEEK:\n      result = {\n        apiKey: settings.deepseekApiKey || '',\n        model: 'deepseek-chat',\n      };\n      logger.info('[DEBUG-options] Converted deepseek settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.ZAI_PAAS:\n      result = {\n        apiKey: settings.zaiPaasApiKey || '',\n        model: settings.zaiPaasModel || 'glm-4.5',\n        apiUrl: 'https://api.z.ai/api/paas/v4/chat/completions',\n      };\n      logger.info('[DEBUG-options] Converted zai-paas settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n        apiUrl: result.apiUrl,\n      });\n      return result;\n\n    case Provider.ZAI_CODING:\n      result = {\n        apiKey: settings.zaiCodingApiKey || '',\n        model: settings.zaiCodingModel || 'glm-4.7',\n        apiUrl: 'https://api.z.ai/api/coding/paas/v4/chat/completions',\n      };\n      logger.info('[DEBUG-options] Converted zai-coding settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n        apiUrl: result.apiUrl,\n      });\n      return result;\n\n    default:\n      throw new Error(`Unknown provider: ${settings.provider}`);\n  }\n}\n\n/**\n * Sets a status message and clears it after a delay\n */\nfunction setStatusMessage(element: HTMLSpanElement, message: string, delay: number = 3000): void {\n  element.textContent = message;\n  setTimeout(() => {\n    element.textContent = '';\n  }, delay);\n}\n\n/**\n * Populates the z.ai model dropdown with available models from the API\n */\nasync function populateZaiModels(provider: 'zaiPaas' | 'zaiCoding'): Promise<void> {\n  const zaiKeyInput = document.getElementById(`${provider}ApiKey`) as HTMLInputElement;\n  const zaiModelSelect = document.getElementById(`${provider}Model`) as HTMLSelectElement;\n\n  if (!zaiKeyInput?.value) {\n    return; // Kein API-Key, nichts zu tun\n  }\n\n  try {\n    logger.info(`[DEBUG-options] Fetching ${provider} models`);\n    const models = await fetchZaiModels(zaiKeyInput.value);\n\n    // Clear existing options\n    zaiModelSelect.innerHTML = '';\n\n    // Add new options\n    models.forEach((model) => {\n      const option = document.createElement('option');\n      option.value = model;\n      option.textContent = model;\n      zaiModelSelect.appendChild(option);\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error(`Failed to populate ${provider} models`, { error: errorMessage });\n  }\n}\n\n// ============================================================================\n// Tag Management Functions\n// ============================================================================\n\n/**\n * Renders the tag list to the DOM\n */\nfunction renderTagList(container: HTMLDivElement, customTags: CustomTags): void {\n  container.innerHTML = '';\n\n  customTags.forEach((tag, index) => {\n    const item = document.createElement('div');\n    item.className = 'tag-item';\n    item.innerHTML = `\n      <div class=\"tag-color-preview\" style=\"background-color: ${escapeHtml(tag.color)};\"></div>\n      <div class=\"tag-details\">\n        <div class=\"tag-name\">${escapeHtml(tag.name)}</div>\n        <div class=\"tag-key\">Key: ${escapeHtml(tag.key)}</div>\n        <div class=\"tag-prompt\">Prompt: ${escapeHtml(tag.prompt || '')}</div>\n      </div>\n      <div class=\"tag-actions\">\n        <button class=\"edit-tag-btn\" data-index=\"${index}\">Edit</button>\n        <button class=\"delete-tag-btn\" data-index=\"${index}\">Delete</button>\n      </div>\n    `;\n    container.appendChild(item);\n  });\n}\n\n/**\n * Cleans up resources when the page is unloaded\n */\nfunction cleanupResources(): void {\n  // No resources to clean up\n}\n\n// ============================================================================\n// ERROR DISPLAY FUNCTIONALITY\n// ============================================================================\n\n/**\n * Error display element in the options page\n */\nlet errorDisplayElement: HTMLDivElement | null = null;\n\n/**\n * Creates the error display overlay if it doesn't exist\n */\nfunction ensureErrorDisplay(): HTMLDivElement {\n  if (errorDisplayElement) {\n    return errorDisplayElement;\n  }\n\n  const errorOverlay = document.createElement('div');\n  errorOverlay.id = 'error-display-overlay';\n  errorOverlay.className = 'error-display-overlay';\n  errorOverlay.innerHTML = `\n    <div class=\"error-display-content\">\n      <div class=\"error-display-header\">\n        <span class=\"error-display-icon\"></span>\n        <h3 id=\"error-display-title\"></h3>\n        <button class=\"error-display-close\">&times;</button>\n      </div>\n      <p id=\"error-display-message\"></p>\n      <div id=\"error-display-details\" style=\"margin-top: 10px; font-size: 12px; color: #666;\"></div>\n    </div>\n  `;\n\n  const closeButton = errorOverlay.querySelector('.error-display-close') as HTMLButtonElement;\n  if (closeButton) {\n    closeButton.addEventListener('click', () => {\n      if (errorDisplayElement) {\n        errorDisplayElement.remove();\n        errorDisplayElement = null;\n      }\n    });\n  }\n\n  document.body.appendChild(errorOverlay);\n  errorDisplayElement = errorOverlay;\n  return errorOverlay;\n}\n\n/**\n * Shows an error message to the user\n * @param error - Error information to display\n */\nfunction showError(error: ErrorDisplay): void {\n  const overlay = ensureErrorDisplay();\n  const title = overlay.querySelector('#error-display-title') as HTMLElement;\n  const message = overlay.querySelector('#error-display-message') as HTMLElement;\n  const details = overlay.querySelector('#error-display-details') as HTMLElement;\n  const icon = overlay.querySelector('.error-display-icon') as HTMLElement;\n\n  // Set icon based on severity\n  switch (error.severity) {\n    case ErrorSeverity.CRITICAL:\n      icon.textContent = '\ud83d\udea8';\n      icon.style.fontSize = '24px';\n      break;\n    case ErrorSeverity.WARNING:\n      icon.textContent = '\u26a0\ufe0f';\n      icon.style.fontSize = '24px';\n      break;\n    case ErrorSeverity.INFO:\n      icon.textContent = '\u2139\ufe0f';\n      icon.style.fontSize = '24px';\n      break;\n  }\n\n  // Set title based on type and severity\n  const typeTitle = error.type ? error.type.charAt(0).toUpperCase() + error.type.slice(1) : 'Error';\n  title.textContent = `${typeTitle} (${error.severity})`;\n\n  // Set message\n  message.textContent = error.message;\n\n  // Set details if available\n  if (error.context && Object.keys(error.context).length > 0) {\n    const detailsText = Object.entries(error.context)\n      .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)\n      .join('\\n');\n    details.textContent = detailsText;\n    details.style.display = 'block';\n  } else {\n    details.style.display = 'none';\n  }\n\n  // Style based on severity\n  overlay.style.display = 'flex';\n  const content = overlay.querySelector('.error-display-content') as HTMLDivElement;\n\n  switch (error.severity) {\n    case ErrorSeverity.CRITICAL:\n      content.style.borderLeft = '4px solid #d32f2f';\n      content.style.backgroundColor = '#ffebee';\n      break;\n    case ErrorSeverity.WARNING:\n      content.style.borderLeft = '4px solid #ff9800';\n      content.style.backgroundColor = '#fff3e0';\n      break;\n    case ErrorSeverity.INFO:\n      content.style.borderLeft = '4px solid #2196f3';\n      content.style.backgroundColor = '#e3f2fd';\n      break;\n  }\n\n  // Auto-hide info and warning errors after 5 seconds\n  if (error.severity !== ErrorSeverity.CRITICAL) {\n    setTimeout(() => {\n      if (overlay && overlay.parentNode) {\n        overlay.remove();\n        errorDisplayElement = null;\n      }\n    }, 5000);\n  }\n\n  logger.info('Error displayed to user', {\n    severity: error.severity,\n    type: error.type,\n    message: error.message,\n  });\n}\n\n/**\n * Handles error messages from background script\n */\nfunction handleBackgroundError(message: ShowErrorRuntimeMessage): void {\n  showError(message.error);\n}\n\n// ============================================================================\n// RUNTIME MESSAGE HANDLER\n// ============================================================================\n\n/**\n * Enhanced sendMessage function that handles error messages\n */\nasync function sendMessage<T = unknown>(message: BatchRuntimeMessage): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    // Type guard to ensure browser.runtime exists\n    if (typeof window !== 'undefined' && 'browser' in window && window.browser) {\n      window.browser.runtime.sendMessage<T>(message, (response: T) => {\n        const lastError = window.browser.runtime?.lastError;\n        if (lastError) {\n          reject(new Error(lastError.message));\n        } else {\n          resolve(response);\n        }\n      });\n    } else {\n      reject(new Error('Browser runtime not available'));\n    }\n  });\n}\n\n/**\n * Runtime message listener for error display and other messages\n */\nfunction setupRuntimeMessageListener(): void {\n  // Type guard to ensure browser.runtime exists\n  if (typeof window !== 'undefined' && 'browser' in window && window.browser) {\n    window.browser.runtime.onMessage.addListener(\n      (message: unknown, sender: unknown, sendResponse: (response?: unknown) => void) => {\n        // Type guard for BatchRuntimeMessage\n        if (typeof message === 'object' && message !== null && 'action' in message) {\n          const typedMessage = message as BatchRuntimeMessage;\n\n          // Handle error display messages\n          if (typedMessage.action === 'showError') {\n            handleBackgroundError(typedMessage as ShowErrorRuntimeMessage);\n            sendResponse({ success: true });\n            return false;\n          }\n        }\n\n        return false; // Let other handlers process the message\n      }\n    );\n  }\n}\n\n/**\n * Handles kill queue button click\n */\nasync function handleKillQueueClick(killQueueBtn: HTMLButtonElement): Promise<void> {\n  try {\n    killQueueBtn.disabled = true;\n\n    const response = await sendMessage<{ success: boolean; message: string }>({\n      action: 'clearQueue',\n      cancelRunning: true,\n    });\n\n    if (response.success) {\n      setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, response.message);\n    } else {\n      setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, response.message);\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to clear queue', { error: errorMessage });\n    setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, `Fehler: ${errorMessage}`);\n  } finally {\n    killQueueBtn.disabled = false;\n  }\n}\n\n/**\n * Handles clear cache button click\n */\nasync function handleClearCacheClick(elements: CacheManagementElements): Promise<void> {\n  try {\n    elements.clearCacheBtn.disabled = true;\n    elements.cacheStatusMessage.textContent = 'Cache wird geleert...';\n\n    const response = await sendMessage<{ success: boolean; message: string }>({\n      action: 'clearCache',\n    });\n\n    if (response.success) {\n      elements.cacheStatusMessage.textContent = response.message;\n    } else {\n      elements.cacheStatusMessage.textContent = response.message;\n    }\n\n    // Refresh cache stats after clearing\n    await updateCacheStats(elements);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to clear cache', { error: errorMessage });\n    elements.cacheStatusMessage.textContent = `Fehler beim Leeren des Cache: ${errorMessage}`;\n  } finally {\n    elements.clearCacheBtn.disabled = false;\n  }\n}\n\n/**\n * Updates cache statistics display\n */\nasync function updateCacheStats(elements: CacheManagementElements): Promise<void> {\n  try {\n    const response = await sendMessage<{\n      success: boolean;\n      totalEntries?: number;\n      hitRate?: number;\n      message?: string;\n    }>({\n      action: 'getCacheStats',\n    });\n\n    if (response.success && response.totalEntries !== undefined && response.hitRate !== undefined) {\n      elements.cacheStats.textContent = `Cache-Eintr\u00e4ge: ${response.totalEntries} | Hit-Rate: ${response.hitRate}%`;\n    } else {\n      elements.cacheStats.textContent = response.message || 'Cache-Statistiken nicht verf\u00fcgbar';\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to get cache stats', { error: errorMessage });\n    elements.cacheStats.textContent = 'Fehler beim Laden der Statistiken';\n  }\n}\n\n/**\n * Checks if provider is configured\n */\nasync function checkProviderConfigured(): Promise<boolean> {\n  try {\n    const settings = await messenger.storage.local.get(DEFAULTS);\n    const provider = settings.provider;\n\n    if (!provider) {\n      return false;\n    }\n\n    // Check provider-specific settings\n    switch (provider) {\n      case 'ollama':\n        return !!(settings.ollamaApiUrl && settings.ollamaModel);\n      case 'openai':\n        return !!settings.openaiApiKey;\n      case 'gemini':\n        return !!settings.geminiApiKey;\n      case 'claude':\n        return !!settings.claudeApiKey;\n      case 'mistral':\n        return !!settings.mistralApiKey;\n      case 'deepseek':\n        return !!settings.deepseekApiKey;\n      case 'zai-paas':\n        return !!settings.zaiPaasApiKey;\n      case 'zai-coding':\n        return !!settings.zaiCodingApiKey;\n      default:\n        return false;\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to check provider configuration', { error: errorMessage });\n    return false;\n  }\n}\n\n/**\n * Escapes HTML special characters to prevent XSS\n */\nfunction escapeHtml(text: string): string {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n/**\n * Loads custom tags from storage\n */\nasync function loadCustomTags(): Promise<CustomTags> {\n  try {\n    const { customTags } = (await messenger.storage.local.get({\n      customTags: DEFAULTS.customTags,\n    })) as CustomTagsStorage;\n    return customTags || DEFAULTS.customTags;\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error loading custom tags', { error: errorMessage });\n    return DEFAULTS.customTags;\n  }\n}\n\n/**\n * Saves custom tags to storage\n */\nasync function saveCustomTags(customTags: CustomTags): Promise<void> {\n  try {\n    await messenger.storage.local.set({ customTags });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error saving custom tags', { error: errorMessage });\n    throw error;\n  }\n}\n\n/**\n * Opens the tag modal for creating or editing\n */\nfunction openModal(elements: TagManagementElements, context: TagEditContext): void {\n  elements.tagForm.reset();\n  elements.tagIndex.value = context.index.toString();\n\n  if (context.tag) {\n    elements.modalTitle.textContent = 'Edit Tag';\n    elements.tagName.value = context.tag.name;\n    elements.tagKey.value = context.tag.key;\n    elements.tagColor.value = context.tag.color;\n    elements.tagPrompt.value = context.tag.prompt || '';\n  } else {\n    elements.modalTitle.textContent = 'Add New Tag';\n  }\n\n  elements.modal.style.display = 'flex';\n}\n\n/**\n * Closes the tag modal\n */\nfunction closeModal(elements: TagManagementElements): void {\n  elements.modal.style.display = 'none';\n}\n\n/**\n * Handles tag list button clicks (edit/delete)\n */\nfunction handleTagListClick(\n  elements: TagManagementElements,\n  customTags: CustomTags\n): TagListClickHandler {\n  return (event: MouseEvent): void => {\n    const target = event.target;\n\n    if (isButtonWithIndex(target)) {\n      const index = parseInt(target.dataset.index, 10);\n\n      if (isNaN(index) || index < 0 || index >= customTags.length) {\n        logger.warn('Invalid tag index', { index: target.dataset.index });\n        return;\n      }\n\n      if (target.classList.contains('edit-tag-btn')) {\n        openModal(elements, { tag: customTags[index], index });\n      }\n\n      if (target.classList.contains('delete-tag-btn')) {\n        const tag = customTags[index];\n        if (confirm(`Are you sure you want to delete the \"${tag.name}\" tag?`)) {\n          (customTags as Tag[]).splice(index, 1);\n          saveCustomTags(customTags)\n            .then(() => renderTagList(elements.tagListContainer, customTags))\n            .catch((error) => {\n              logger.error('Failed to delete tag', { error });\n            });\n        }\n      }\n    }\n  };\n}\n\n/**\n * Handles tag form submission\n */\nasync function handleTagFormSubmit(\n  elements: TagManagementElements,\n  customTags: CustomTags\n): Promise<void> {\n  const index = parseInt(elements.tagIndex.value, 10);\n  const name = elements.tagName.value.trim();\n  const key = elements.tagKey.value.trim();\n  const color = elements.tagColor.value;\n  const prompt = elements.tagPrompt.value.trim();\n\n  // Validate inputs\n  if (!name) {\n    alert('Fehler: Tag-Name ist erforderlich.');\n    return;\n  }\n\n  if (!key) {\n    alert('Fehler: Tag-Schl\u00fcssel ist erforderlich.');\n    return;\n  }\n\n  if (!isValidTagKey(key)) {\n    alert('Fehler: Tag-Schl\u00fcssel darf nur Kleinbuchstaben, Zahlen und Unterstriche enthalten.');\n    return;\n  }\n\n  if (!isValidHexColor(color)) {\n    alert('Fehler: Tag-Farbe muss ein g\u00fcltiger Hex-Farbwert sein (z.B. #FF5722).');\n    return;\n  }\n\n  if (!prompt) {\n    alert('Fehler: Tag-Prompt ist erforderlich.');\n    return;\n  }\n\n  // Check for duplicate keys (excluding current index for edits)\n  const isDuplicate = customTags.some((tag, i) => tag.key === key && i !== index);\n  if (isDuplicate) {\n    alert('Fehler: Tag-Schl\u00fcssel muss eindeutig sein.');\n    return;\n  }\n\n  const newTag: Tag = { name, key, color, prompt };\n\n  if (index === -1) {\n    // Add new tag\n    (customTags as Tag[]).push(newTag);\n  } else {\n    // Update existing tag\n    (customTags as Tag[])[index] = newTag;\n  }\n\n  try {\n    await saveCustomTags(customTags);\n    renderTagList(elements.tagListContainer, customTags);\n    closeModal(elements);\n  } catch (error) {\n    alert('Fehler: Tag konnte nicht gespeichert werden. Bitte versuchen Sie es erneut.');\n  }\n}\n\n// ============================================================================\n// Initialization\n// ============================================================================\n\n/**\n * Initializes the options page\n */\nfunction initializeOptionsPage(): void {\n  try {\n    // Setup error display listener first\n    setupRuntimeMessageListener();\n\n    const elements = getAllDOMElements();\n\n    // Track custom tags state\n    let currentCustomTags: CustomTags = [];\n\n    // Initialize tabs\n    initializeTabs(elements.tabs, elements.tabContents);\n\n    // Initialize general settings\n    loadGeneralSettings(elements).catch((error) => {\n      logger.error('Failed to load general settings on init', { error });\n    });\n\n    // General settings form handler\n    elements.generalForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const result = await handleGeneralSettingsSubmit(elements);\n\n      setStatusMessage(elements.generalStatusMessage, result.message);\n      if (result.success) {\n        setStatusMessage(elements.statusMessage, 'General settings saved!');\n      } else {\n        setStatusMessage(elements.statusMessage, result.message);\n      }\n    });\n\n    // Provider change handler\n    elements.providerSelect.addEventListener('change', (e) => {\n      const target = e.target as HTMLSelectElement;\n      showRelevantSettings(target.value);\n    });\n\n    // z.ai API key change handler - fetch models when key changes\n    if (elements.zaiPaasApiKey) {\n      const debouncedPopulateZaiPaasModels = debounce(() => populateZaiModels('zaiPaas'), 500);\n      elements.zaiPaasApiKey.addEventListener('input', () => {\n        if (elements.zaiPaasApiKey?.value) {\n          debouncedPopulateZaiPaasModels();\n        }\n      });\n    }\n    if (elements.zaiCodingApiKey) {\n      const debouncedPopulateZaiCodingModels = debounce(() => populateZaiModels('zaiCoding'), 500);\n      elements.zaiCodingApiKey.addEventListener('input', () => {\n        if (elements.zaiCodingApiKey?.value) {\n          debouncedPopulateZaiCodingModels();\n        }\n      });\n    }\n\n    // Initialize cache management\n    updateCacheStats(elements).catch((error) => {\n      logger.error('Failed to initialize cache stats', { error });\n    });\n\n    // Cache management event listeners\n    elements.clearCacheBtn.addEventListener('click', () => {\n      handleClearCacheClick(elements);\n    });\n\n    // Kill queue button event listener\n    const killQueueBtn = document.getElementById('kill-queue-btn');\n    if (killQueueBtn) {\n      killQueueBtn.addEventListener('click', () => {\n        handleKillQueueClick(killQueueBtn as HTMLButtonElement).catch((error) => {\n          logger.error('Failed to handle kill queue click', { error });\n        });\n      });\n    }\n\n    // Load and initialize custom tags\n    loadCustomTags()\n      .then((tags) => {\n        currentCustomTags = tags;\n        renderTagList(elements.tagListContainer, currentCustomTags);\n      })\n      .catch((error) => {\n        logger.error('Failed to load custom tags on init', { error });\n      });\n\n    // Add new tag button handler\n    elements.addNewTagBtn.addEventListener('click', () => {\n      openModal(elements, { tag: null, index: -1 });\n    });\n\n    // Close modal button handler\n    elements.closeModalBtn.addEventListener('click', () => {\n      closeModal(elements);\n    });\n\n    // Close modal on outside click\n    window.addEventListener('click', (e) => {\n      if (e.target === elements.modal) {\n        closeModal(elements);\n      }\n    });\n\n    // Tag list click handler\n    elements.tagListContainer.addEventListener(\n      'click',\n      handleTagListClick(elements, currentCustomTags)\n    );\n\n    // Tag form submit handler\n    elements.tagForm.addEventListener('submit', (e) => {\n      e.preventDefault();\n      handleTagFormSubmit(elements, currentCustomTags).catch((error) => {\n        logger.error('Failed to handle tag form submit', { error });\n      });\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to initialize options page', { error: errorMessage });\n    document.body.innerHTML = `<p style=\"color: red;\">Error initializing options page: ${escapeHtml(errorMessage)}</p>`;\n  }\n}\n\n// Start initialization when DOM is ready\ndocument.addEventListener('DOMContentLoaded', initializeOptionsPage);\n\n// Clean up resources when page unloads\nwindow.addEventListener('beforeunload', cleanupResources);\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "import 'reflect-metadata';\n\nimport {\n  DEFAULTS,\n  Provider,\n  ProviderConfig,\n  CustomTags,\n  Tag,\n  isValidProvider,\n  ModelConcurrencyConfig,\n} from './core/config';\nimport {\n  ErrorSeverity,\n  ErrorType,\n  ErrorDisplay,\n  ShowErrorRuntimeMessage,\n  debounce,\n} from './src/infrastructure/providers/ProviderUtils';\n\n/**\n * Batch processing statistics\n */\ninterface BatchStatistics {\n  total: number;\n  successful: number;\n  failed: number;\n  [key: string]: unknown;\n}\nimport { ensureTagsExist } from './core/tags';\nimport { logger } from './src/infrastructure/providers/ProviderUtils';\nimport { fetchZaiModels } from './src/infrastructure/providers';\n\ndeclare const messenger: {\n  storage: {\n    local: {\n      get(\n        keys: Partial<ProviderConfig> | { customTags?: CustomTags }\n      ): Promise<Partial<ProviderConfig> & { customTags?: CustomTags }>;\n      set(items: Partial<ProviderConfig> & { customTags?: CustomTags }): Promise<void>;\n      get(keys: unknown): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n  runtime: {\n    reload(): void;\n  };\n  permissions: {\n    request(permissions: { permissions?: string[]; origins?: string[] }): Promise<boolean>;\n  };\n};\n\ninterface StorageProviderSettings {\n  [providerId: string]: {\n    apiKey: string;\n    model: string;\n    apiUrl?: string;\n  };\n}\n\ninterface AppSettingsStorage {\n  appConfig?: {\n    defaultProvider?: string;\n    enableNotifications?: boolean;\n    enableLogging?: boolean;\n    confidenceThreshold?: number;\n  };\n  providerSettings?: StorageProviderSettings;\n  customTags?: CustomTags;\n}\n\ninterface BrowserRuntime {\n  sendMessage<T = unknown>(message: unknown, callback?: (response: T) => void): void;\n  onMessage: {\n    addListener(\n      callback: (\n        message: unknown,\n        sender: unknown,\n        sendResponse: (response?: unknown) => void\n      ) => void\n    ): void;\n  };\n  lastError?: { message: string };\n}\n\ninterface BrowserExtension {\n  runtime: BrowserRuntime;\n}\n\ndeclare global {\n  interface Window {\n    browser: BrowserExtension;\n  }\n}\n\n// ============================================================================\n// DOM Element Interfaces\n// ============================================================================\n\n/**\n * General Settings DOM Elements\n */\ninterface GeneralSettingsElements {\n  providerSelect: HTMLSelectElement;\n  generalForm: HTMLFormElement;\n  generalStatusMessage: HTMLSpanElement;\n  statusMessage: HTMLSpanElement;\n  ollamaApiUrl: HTMLInputElement | null;\n  ollamaModel: HTMLInputElement | null;\n  openaiApiKey: HTMLInputElement | null;\n  geminiApiKey: HTMLInputElement | null;\n  claudeApiKey: HTMLInputElement | null;\n  mistralApiKey: HTMLInputElement | null;\n  deepseekApiKey: HTMLInputElement | null;\n  zaiPaasApiKey: HTMLInputElement | null;\n  zaiPaasModel: HTMLSelectElement | null;\n  zaiCodingApiKey: HTMLInputElement | null;\n  zaiCodingModel: HTMLSelectElement | null;\n}\n\n/**\n * Tag Management DOM Elements\n */\ninterface TagManagementElements {\n  tagListContainer: HTMLDivElement;\n  modal: HTMLDivElement;\n  modalTitle: HTMLHeadingElement;\n  tagForm: HTMLFormElement;\n  closeModalBtn: HTMLSpanElement;\n  addNewTagBtn: HTMLButtonElement;\n  tagIndex: HTMLInputElement;\n  tagName: HTMLInputElement;\n  tagKey: HTMLInputElement;\n  tagColor: HTMLInputElement;\n  tagPrompt: HTMLTextAreaElement;\n  tagThreshold: HTMLInputElement;\n  tagThresholdSlider: HTMLInputElement;\n}\n\n/**\n * Tab DOM Elements\n */\ninterface TabElements {\n  tabButtons: NodeListOf<HTMLButtonElement>;\n  tabContents: NodeListOf<HTMLDivElement>;\n}\n\n/**\n * Cache Management DOM Elements\n */\ninterface CacheManagementElements {\n  clearCacheBtn: HTMLButtonElement;\n  cacheStatusMessage: HTMLSpanElement;\n  cacheStats: HTMLSpanElement;\n}\n\n/**\n * Confidence Threshold DOM Elements\n */\ninterface ConfidenceThresholdElements {\n  thresholdSlider: HTMLInputElement;\n  thresholdInput: HTMLInputElement;\n  thresholdValue: HTMLSpanElement;\n  saveThresholdBtn: HTMLButtonElement;\n  resetThresholdBtn: HTMLButtonElement;\n  thresholdStatusMessage: HTMLSpanElement;\n}\n\n/**\n * All DOM Elements\n */\ninterface DOMElements\n  extends GeneralSettingsElements,\n    TagManagementElements,\n    CacheManagementElements,\n    ConfidenceThresholdElements {\n  tabs: TabElements['tabButtons'];\n  tabContents: TabElements['tabContents'];\n}\n\n// ============================================================================\n// UI State Interfaces\n// ============================================================================\n\n/**\n * Tag Form State\n */\ninterface TagFormState {\n  index: number;\n  name: string;\n  key: string;\n  color: string;\n  prompt: string;\n}\n\n/**\n * Settings Save Result\n */\ninterface SettingsSaveResult {\n  success: boolean;\n  message: string;\n}\n\n/**\n * Tag Edit Context\n */\ninterface TagEditContext {\n  tag: Tag | null;\n  index: number;\n}\n\n// ============================================================================\n// Provider Settings Types\n// ============================================================================\n\n/**\n * Settings to save for each provider type\n */\ntype ProviderSettingsData =\n  | { provider: Provider.OLLAMA; ollamaApiUrl: string; ollamaModel: string }\n  | { provider: Provider.OPENAI; openaiApiKey: string }\n  | { provider: Provider.GEMINI; geminiApiKey: string }\n  | { provider: Provider.CLAUDE; claudeApiKey: string }\n  | { provider: Provider.MISTRAL; mistralApiKey: string }\n  | { provider: Provider.DEEPSEEK; deepseekApiKey: string };\n\n/**\n * Partial provider config for saving\n */\ntype PartialProviderConfig = {\n  provider: Provider;\n  ollamaApiUrl?: string;\n  ollamaModel?: string;\n  openaiApiKey?: string;\n  geminiApiKey?: string;\n  claudeApiKey?: string;\n  mistralApiKey?: string;\n  deepseekApiKey?: string;\n  zaiPaasApiKey?: string;\n  zaiPaasModel?: string;\n  zaiCodingApiKey?: string;\n  zaiCodingModel?: string;\n};\n\n// ============================================================================\n// Storage Types\n// ============================================================================\n\n/**\n * Storage response for general settings\n */\ninterface GeneralSettingsStorage {\n  provider?: Provider;\n  ollamaApiUrl?: string;\n  ollamaModel?: string;\n  openaiApiKey?: string;\n  geminiApiKey?: string;\n  claudeApiKey?: string;\n  mistralApiKey?: string;\n  deepseekApiKey?: string;\n  zaiPaasApiKey?: string;\n  zaiPaasModel?: string;\n  zaiCodingApiKey?: string;\n  zaiCodingModel?: string;\n}\n\n/**\n * Storage response for custom tags\n */\ninterface CustomTagsStorage {\n  customTags?: CustomTags;\n}\n\n// ============================================================================\n// Event Handler Types\n// ============================================================================\n\n/**\n * Tab click event handler\n */\ntype TabClickHandler = (event: MouseEvent) => void;\n\n/**\n * Form submit event handler for general settings\n */\ntype GeneralSettingsSubmitHandler = (event: SubmitEvent) => Promise<void>;\n\n/**\n * Provider change event handler\n */\ntype ProviderChangeHandler = (event: Event) => void;\n\n/**\n * Tag list click event handler\n */\ntype TagListClickHandler = (event: MouseEvent) => void;\n\n/**\n * Tag form submit event handler\n */\ntype TagFormSubmitHandler = (event: SubmitEvent) => void;\n\n/**\n * Batch analysis click event handler\n */\ntype BatchAnalysisClickHandler = (event: MouseEvent) => void;\n\n// ============================================================================\n// Batch Analysis Types\n// ============================================================================\n\n/**\n * Batch analysis status\n */\ntype BatchStatus = 'idle' | 'running' | 'completed' | 'cancelled' | 'error';\n\n/**\n * Batch analysis progress data\n */\ninterface BatchProgress {\n  status: BatchStatus;\n  total: number;\n  processed: number;\n  successful: number;\n  failed: number;\n  startTime: number;\n  endTime?: number;\n  errorMessage?: string;\n}\n\n/**\n * Batch analysis response\n */\ninterface BatchAnalysisResponse {\n  success: boolean;\n  statistics?: BatchStatistics;\n  error?: string;\n  message?: string;\n}\n\n/**\n * Batch analysis cancel response\n */\ninterface BatchCancelResponse {\n  success: boolean;\n  message: string;\n}\n\n/**\n * Runtime message types for batch analysis\n */\ntype BatchRuntimeMessage =\n  | { action: 'startBatchAnalysis'; folderId?: string }\n  | { action: 'getBatchProgress' }\n  | { action: 'cancelBatchAnalysis' }\n  | { action: 'clearQueue'; cancelRunning?: boolean }\n  | { action: 'clearCache' }\n  | { action: 'getCacheStats' }\n  | ShowErrorRuntimeMessage;\n\n/**\n * Runtime message response types\n */\ntype BatchRuntimeResponse =\n  | BatchAnalysisResponse\n  | BatchProgress\n  | BatchCancelResponse\n  | { success: boolean; message: string };\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Type guard to check if an element is a valid provider settings element\n */\nfunction isProviderSettingsElement(element: HTMLElement | null): element is HTMLDivElement {\n  return element !== null && element.classList.contains('provider-settings');\n}\n\n/**\n * Type guard to check if an event target is a button with index data\n */\nfunction isButtonWithIndex(\n  target: EventTarget | null\n): target is HTMLButtonElement & { dataset: { index: string } } {\n  if (target === null || !(target instanceof HTMLButtonElement)) {\n    return false;\n  }\n  return 'index' in target.dataset && typeof target.dataset.index === 'string';\n}\n\n/**\n * Validates tag key format\n * Pattern: lowercase letters, numbers, underscores only\n */\nfunction isValidTagKey(key: string): boolean {\n  return /^[a-z0-9_]+$/.test(key);\n}\n\n/**\n * Validates hex color format\n */\nfunction isValidHexColor(color: string): boolean {\n  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n}\n\n/**\n * Gets permission origin for a provider\n */\nfunction getPermissionOrigin(provider: Provider, settings: PartialProviderConfig): string {\n  switch (provider) {\n    case Provider.OLLAMA:\n      if (settings.ollamaApiUrl) {\n        return new URL(settings.ollamaApiUrl).origin + '/*';\n      }\n      throw new Error('Ollama API URL is required for permission request');\n    case Provider.OPENAI:\n      return 'https://api.openai.com/';\n    case Provider.GEMINI:\n      return 'https://generativelanguage.googleapis.com/';\n    case Provider.CLAUDE:\n      return 'https://api.anthropic.com/';\n    case Provider.MISTRAL:\n      return 'https://api.mistral.ai/';\n    case Provider.DEEPSEEK:\n      return 'https://api.deepseek.com/';\n    case Provider.ZAI_PAAS:\n      return 'https://api.z.ai/';\n    case Provider.ZAI_CODING:\n      return 'https://api.z.ai/';\n    default:\n      throw new Error(`Unknown provider: ${provider}`);\n  }\n}\n\n// ============================================================================\n// DOM Element Accessors\n// ============================================================================\n\n/**\n * Safely retrieves an element by ID with type assertion\n */\nfunction getElementById<T extends HTMLElement>(id: string): T | null {\n  return document.getElementById(id) as T | null;\n}\n\n/**\n * Retrieves all general settings DOM elements\n */\nfunction getGeneralSettingsElements(): GeneralSettingsElements {\n  const providerSelect = getElementById<HTMLSelectElement>('provider');\n  const generalForm = getElementById<HTMLFormElement>('provider-options-form');\n  const generalStatusMessage = getElementById<HTMLSpanElement>('provider-status-message');\n  const statusMessage = getElementById<HTMLSpanElement>('provider-status-message');\n  const ollamaApiUrl = getElementById<HTMLInputElement>('ollama-api-url');\n  const ollamaModel = getElementById<HTMLInputElement>('ollama-model');\n  const openaiApiKey = getElementById<HTMLInputElement>('openai-api-key');\n  const geminiApiKey = getElementById<HTMLInputElement>('gemini-api-key');\n  const claudeApiKey = getElementById<HTMLInputElement>('claude-api-key');\n  const mistralApiKey = getElementById<HTMLInputElement>('mistral-api-key');\n  const deepseekApiKey = getElementById<HTMLInputElement>('deepseek-api-key');\n  const zaiPaasApiKey = getElementById<HTMLInputElement>('zaiPaasApiKey');\n  const zaiPaasModel = getElementById<HTMLSelectElement>('zaiPaasModel');\n  const zaiCodingApiKey = getElementById<HTMLInputElement>('zaiCodingApiKey');\n  const zaiCodingModel = getElementById<HTMLSelectElement>('zaiCodingModel');\n\n  if (!providerSelect || !generalForm || !generalStatusMessage || !statusMessage) {\n    throw new Error('Required general settings elements not found');\n  }\n\n  return {\n    providerSelect,\n    generalForm,\n    generalStatusMessage,\n    statusMessage,\n    ollamaApiUrl,\n    ollamaModel,\n    openaiApiKey,\n    geminiApiKey,\n    claudeApiKey,\n    mistralApiKey,\n    deepseekApiKey,\n    zaiPaasApiKey,\n    zaiPaasModel,\n    zaiCodingApiKey,\n    zaiCodingModel,\n  };\n}\n\n/**\n * Retrieves all tag management DOM elements\n */\nfunction getTagManagementElements(): TagManagementElements {\n  const tagListContainer = getElementById<HTMLDivElement>('tag-list-container');\n  const modal = getElementById<HTMLDivElement>('tag-modal');\n  const modalTitle = getElementById<HTMLHeadingElement>('modal-title');\n  const tagForm = getElementById<HTMLFormElement>('tag-form');\n  const closeModalBtn = document.querySelector<HTMLSpanElement>('.close-button');\n  const addNewTagBtn = getElementById<HTMLButtonElement>('add-new-tag-btn');\n  const tagIndex = getElementById<HTMLInputElement>('tag-index');\n  const tagName = getElementById<HTMLInputElement>('tag-name');\n  const tagKey = getElementById<HTMLInputElement>('tag-key');\n  const tagColor = getElementById<HTMLInputElement>('tag-color');\n  const tagPrompt = getElementById<HTMLTextAreaElement>('tag-prompt');\n  const tagThreshold = getElementById<HTMLInputElement>('tag-threshold');\n  const tagThresholdSlider = getElementById<HTMLInputElement>('tag-threshold-slider');\n\n  if (\n    !tagListContainer ||\n    !modal ||\n    !modalTitle ||\n    !tagForm ||\n    !closeModalBtn ||\n    !addNewTagBtn ||\n    !tagIndex ||\n    !tagName ||\n    !tagKey ||\n    !tagColor ||\n    !tagPrompt ||\n    !tagThreshold ||\n    !tagThresholdSlider\n  ) {\n    throw new Error('Required tag management elements not found');\n  }\n\n  return {\n    tagListContainer,\n    modal,\n    modalTitle,\n    tagForm,\n    closeModalBtn,\n    addNewTagBtn,\n    tagIndex,\n    tagName,\n    tagKey,\n    tagColor,\n    tagPrompt,\n    tagThreshold,\n    tagThresholdSlider,\n  };\n}\n\n/**\n * Retrieves all DOM elements\n */\nfunction getAllDOMElements(): DOMElements {\n  const general = getGeneralSettingsElements();\n  const tag = getTagManagementElements();\n\n  const clearCacheBtn = getElementById<HTMLButtonElement>('clear-cache-btn');\n  const cacheStatusMessage = getElementById<HTMLSpanElement>('cache-status-message');\n  const cacheStats = getElementById<HTMLSpanElement>('cache-stats');\n\n  if (!clearCacheBtn || !cacheStatusMessage || !cacheStats) {\n    throw new Error('Required cache management elements not found');\n  }\n\n  const thresholdSlider = getElementById<HTMLInputElement>('confidence-threshold-slider');\n  const thresholdInput = getElementById<HTMLInputElement>('confidence-threshold-input');\n  const thresholdValue = getElementById<HTMLSpanElement>('threshold-value');\n  const saveThresholdBtn = getElementById<HTMLButtonElement>('save-threshold-btn');\n  const resetThresholdBtn = getElementById<HTMLButtonElement>('reset-threshold-btn');\n  const thresholdStatusMessage = getElementById<HTMLSpanElement>('threshold-status-message');\n\n  if (\n    !thresholdSlider ||\n    !thresholdInput ||\n    !thresholdValue ||\n    !saveThresholdBtn ||\n    !resetThresholdBtn ||\n    !thresholdStatusMessage\n  ) {\n    throw new Error('Required confidence threshold elements not found');\n  }\n\n  return {\n    ...general,\n    ...tag,\n    clearCacheBtn,\n    cacheStatusMessage,\n    cacheStats,\n    thresholdSlider,\n    thresholdInput,\n    thresholdValue,\n    saveThresholdBtn,\n    resetThresholdBtn,\n    thresholdStatusMessage,\n    tabs: document.querySelectorAll('.tab-button'),\n    tabContents: document.querySelectorAll('.tab-content'),\n  };\n}\n\n// ============================================================================\n// Tab Management Functions\n// ============================================================================\n\n/**\n * Handles tab switching\n */\nfunction handleTabClick(\n  tabs: NodeListOf<HTMLButtonElement>,\n  tabContents: NodeListOf<HTMLDivElement>\n): TabClickHandler {\n  return (event: MouseEvent): void => {\n    const clickedTab = event.currentTarget as HTMLButtonElement;\n    const targetTabId = clickedTab.dataset.tab;\n\n    if (!targetTabId) {\n      logger.warn('Tab does not have data-tab attribute', { tab: clickedTab });\n      return;\n    }\n\n    tabs.forEach((tab) => tab.classList.remove('active'));\n    clickedTab.classList.add('active');\n\n    tabContents.forEach((content) => content.classList.remove('active'));\n\n    const targetContent = document.getElementById(targetTabId);\n    if (targetContent) {\n      targetContent.classList.add('active');\n    } else {\n      logger.warn('Target tab content not found', { tabId: targetTabId });\n    }\n  };\n}\n\n/**\n * Initializes tab functionality\n */\nfunction initializeTabs(\n  tabs: NodeListOf<HTMLButtonElement>,\n  tabContents: NodeListOf<HTMLDivElement>\n): void {\n  tabs.forEach((tab) => {\n    tab.addEventListener('click', handleTabClick(tabs, tabContents));\n  });\n}\n\n// ============================================================================\n// General Settings Functions\n// ============================================================================\n\n/**\n * Shows/hides provider-specific settings based on selected provider\n */\nfunction showRelevantSettings(provider: string): void {\n  logger.info('[DEBUG-options] showRelevantSettings() called', { provider });\n\n  document.querySelectorAll<HTMLElement>('.provider-settings').forEach((div) => {\n    div.style.display = 'none';\n    div\n      .querySelectorAll<HTMLInputElement | HTMLSelectElement>('input[required], select[required]')\n      .forEach((field) => {\n        field.removeAttribute('required');\n      });\n  });\n\n  const settingsToShow = document.getElementById(`${provider}-settings`);\n  if (settingsToShow && isProviderSettingsElement(settingsToShow)) {\n    logger.info('[DEBUG-options] Showing settings for provider', { provider });\n    settingsToShow.style.display = 'block';\n    settingsToShow\n      .querySelectorAll<HTMLInputElement | HTMLSelectElement>('input, select')\n      .forEach((field) => {\n        field.setAttribute('required', '');\n      });\n  } else {\n    logger.warn('[DEBUG-options] No settings found for provider', { provider });\n  }\n}\n\n/**\n * Loads general settings from storage and populates form fields\n */\nasync function loadGeneralSettings(elements: GeneralSettingsElements): Promise<void> {\n  logger.info('[DEBUG-options] loadGeneralSettings() called');\n\n  try {\n    const data = (await messenger.storage.local.get({\n      appConfig: { defaultProvider: DEFAULTS.provider },\n      providerSettings: {},\n    })) as AppSettingsStorage;\n\n    const appConfig = data.appConfig || {};\n    const providerSettings = data.providerSettings || {};\n\n    logger.info('[DEBUG-options] Storage loaded', {\n      appConfig,\n      providerSettings,\n    });\n\n    elements.providerSelect.value = appConfig.defaultProvider || DEFAULTS.provider;\n\n    if (elements.ollamaApiUrl && providerSettings.ollama) {\n      logger.info('[DEBUG-options] Loaded ollama settings', {\n        apiUrl: providerSettings.ollama.apiUrl,\n        model: providerSettings.ollama.model,\n      });\n      elements.ollamaApiUrl.value = providerSettings.ollama.apiUrl || '';\n    }\n    if (elements.ollamaModel && providerSettings.ollama) {\n      elements.ollamaModel.value = providerSettings.ollama.model || '';\n    }\n    if (elements.openaiApiKey && providerSettings.openai) {\n      logger.info('[DEBUG-options] Loaded openai settings', {\n        apiKey: providerSettings.openai.apiKey ? '***REDACTED***' : '',\n      });\n      elements.openaiApiKey.value = providerSettings.openai.apiKey || '';\n    }\n    if (elements.geminiApiKey && providerSettings.gemini) {\n      logger.info('[DEBUG-options] Loaded gemini settings', {\n        apiKey: providerSettings.gemini.apiKey ? '***REDACTED***' : '',\n      });\n      elements.geminiApiKey.value = providerSettings.gemini.apiKey || '';\n    }\n    if (elements.claudeApiKey && providerSettings.claude) {\n      logger.info('[DEBUG-options] Loaded claude settings', {\n        apiKey: providerSettings.claude.apiKey ? '***REDACTED***' : '',\n      });\n      elements.claudeApiKey.value = providerSettings.claude.apiKey || '';\n    }\n    if (elements.mistralApiKey && providerSettings.mistral) {\n      logger.info('[DEBUG-options] Loaded mistral settings', {\n        apiKey: providerSettings.mistral.apiKey ? '***REDACTED***' : '',\n      });\n      elements.mistralApiKey.value = providerSettings.mistral.apiKey || '';\n    }\n    if (elements.deepseekApiKey && providerSettings.deepseek) {\n      logger.info('[DEBUG-options] Loaded deepseek settings', {\n        apiKey: providerSettings.deepseek.apiKey ? '***REDACTED***' : '',\n      });\n      elements.deepseekApiKey.value = providerSettings.deepseek.apiKey || '';\n    }\n    if (elements.zaiPaasApiKey && providerSettings['zai-paas']) {\n      logger.info('[DEBUG-options] Loaded zai-paas settings', {\n        apiKey: providerSettings['zai-paas'].apiKey ? '***REDACTED***' : '',\n        model: providerSettings['zai-paas'].model,\n      });\n      elements.zaiPaasApiKey.value = providerSettings['zai-paas'].apiKey || '';\n    }\n    if (elements.zaiPaasModel && providerSettings['zai-paas']) {\n      elements.zaiPaasModel.value = providerSettings['zai-paas'].model || '';\n    }\n    if (elements.zaiCodingApiKey && providerSettings['zai-coding']) {\n      logger.info('[DEBUG-options] Loaded zai-coding settings', {\n        apiKey: providerSettings['zai-coding'].apiKey ? '***REDACTED***' : '',\n        model: providerSettings['zai-coding'].model,\n      });\n      elements.zaiCodingApiKey.value = providerSettings['zai-coding'].apiKey || '';\n    }\n    if (elements.zaiCodingModel && providerSettings['zai-coding']) {\n      elements.zaiCodingModel.value = providerSettings['zai-coding'].model || '';\n    }\n\n    showRelevantSettings(appConfig.defaultProvider || DEFAULTS.provider);\n\n    // Populate z.ai models if API key is present\n    if (elements.zaiPaasApiKey && elements.zaiPaasApiKey.value) {\n      logger.info('[DEBUG-options] Populating zaiPaas models on load');\n      populateZaiModels('zaiPaas').catch((error) => {\n        logger.error('Failed to populate z.ai PaaS models on load', { error });\n      });\n    }\n    if (elements.zaiCodingApiKey && elements.zaiCodingApiKey.value) {\n      logger.info('[DEBUG-options] Populating zaiCoding models on load');\n      populateZaiModels('zaiCoding').catch((error) => {\n        logger.error('Failed to populate z.ai Coding models on load', { error });\n      });\n    }\n\n    logger.info('[DEBUG-options] loadGeneralSettings() completed');\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error loading general settings', { error: errorMessage });\n  }\n}\n\n/**\n * Gathers settings data based on selected provider\n */\nfunction gatherProviderSettings(\n  provider: string,\n  elements: GeneralSettingsElements\n): PartialProviderConfig {\n  logger.info('[DEBUG-options] gatherProviderSettings() called', { provider });\n\n  const baseSettings: PartialProviderConfig = { provider: provider as Provider };\n\n  switch (provider) {\n    case Provider.OLLAMA:\n      if (!elements.ollamaApiUrl || !elements.ollamaModel) {\n        throw new Error('Ollama settings elements not found');\n      }\n      const ollamaSettings = {\n        ...baseSettings,\n        ollamaApiUrl: elements.ollamaApiUrl.value.trim(),\n        ollamaModel: elements.ollamaModel.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered ollama settings', {\n        apiUrl: ollamaSettings.ollamaApiUrl,\n        model: ollamaSettings.ollamaModel,\n      });\n      return ollamaSettings;\n\n    case Provider.OPENAI:\n      if (!elements.openaiApiKey) {\n        throw new Error('OpenAI settings element not found');\n      }\n      const openaiSettings = {\n        ...baseSettings,\n        openaiApiKey: elements.openaiApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered openai settings', {\n        apiKey: openaiSettings.openaiApiKey ? '***REDACTED***' : '',\n      });\n      return openaiSettings;\n\n    case Provider.GEMINI:\n      if (!elements.geminiApiKey) {\n        throw new Error('Gemini settings element not found');\n      }\n      const geminiSettings = {\n        ...baseSettings,\n        geminiApiKey: elements.geminiApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered gemini settings', {\n        apiKey: geminiSettings.geminiApiKey ? '***REDACTED***' : '',\n      });\n      return geminiSettings;\n\n    case Provider.CLAUDE:\n      if (!elements.claudeApiKey) {\n        throw new Error('Claude settings element not found');\n      }\n      const claudeSettings = {\n        ...baseSettings,\n        claudeApiKey: elements.claudeApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered claude settings', {\n        apiKey: claudeSettings.claudeApiKey ? '***REDACTED***' : '',\n      });\n      return claudeSettings;\n\n    case Provider.MISTRAL:\n      if (!elements.mistralApiKey) {\n        throw new Error('Mistral settings element not found');\n      }\n      const mistralSettings = {\n        ...baseSettings,\n        mistralApiKey: elements.mistralApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered mistral settings', {\n        apiKey: mistralSettings.mistralApiKey ? '***REDACTED***' : '',\n      });\n      return mistralSettings;\n\n    case Provider.DEEPSEEK:\n      if (!elements.deepseekApiKey) {\n        throw new Error('DeepSeek settings element not found');\n      }\n      const deepseekSettings = {\n        ...baseSettings,\n        deepseekApiKey: elements.deepseekApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered deepseek settings', {\n        apiKey: deepseekSettings.deepseekApiKey ? '***REDACTED***' : '',\n      });\n      return deepseekSettings;\n\n    case Provider.ZAI_PAAS:\n      if (!elements.zaiPaasApiKey || !elements.zaiPaasModel) {\n        throw new Error('Zai PaaS settings element not found');\n      }\n      const zaiPaasSettings = {\n        ...baseSettings,\n        zaiPaasApiKey: elements.zaiPaasApiKey.value.trim(),\n        zaiPaasModel: elements.zaiPaasModel.value,\n      };\n      logger.info('[DEBUG-options] Gathered zai-paas settings', {\n        apiKey: zaiPaasSettings.zaiPaasApiKey ? '***REDACTED***' : '',\n        model: zaiPaasSettings.zaiPaasModel,\n      });\n      return zaiPaasSettings;\n\n    case Provider.ZAI_CODING:\n      if (!elements.zaiCodingApiKey || !elements.zaiCodingModel) {\n        throw new Error('Zai Coding settings element not found');\n      }\n      const zaiCodingSettings = {\n        ...baseSettings,\n        zaiCodingApiKey: elements.zaiCodingApiKey.value.trim(),\n        zaiCodingModel: elements.zaiCodingModel.value,\n      };\n      logger.info('[DEBUG-options] Gathered zai-coding settings', {\n        apiKey: zaiCodingSettings.zaiCodingApiKey ? '***REDACTED***' : '',\n        model: zaiCodingSettings.zaiCodingModel,\n      });\n      return zaiCodingSettings;\n\n    default:\n      throw new Error(`Unknown provider: ${provider}`);\n  }\n}\n\n/**\n * Handles general settings form submission\n */\nasync function handleGeneralSettingsSubmit(\n  elements: GeneralSettingsElements\n): Promise<SettingsSaveResult> {\n  const provider = elements.providerSelect.value;\n\n  logger.info('[DEBUG-options] handleGeneralSettingsSubmit() called', { provider });\n\n  if (!isValidProvider(provider)) {\n    logger.warn('[DEBUG-options] Invalid provider selected', { provider });\n    return {\n      success: false,\n      message: 'Invalid provider selected',\n    };\n  }\n\n  const settingsToSave = gatherProviderSettings(provider, elements);\n  logger.info('[DEBUG-options] Gathered settings', { settingsToSave });\n\n  let permissionGranted = true;\n\n  try {\n    const permissionOrigin = getPermissionOrigin(provider as Provider, settingsToSave);\n    const hasSettings = Object.values(settingsToSave).some((val) => val && val !== '');\n\n    if (hasSettings) {\n      try {\n        logger.info('[DEBUG-options] Requesting permission for origin', {\n          origin: permissionOrigin,\n        });\n        permissionGranted = await messenger.permissions.request({\n          origins: [permissionOrigin],\n        });\n        logger.info('[DEBUG-options] Permission result', {\n          granted: permissionGranted,\n          origin: permissionOrigin,\n        });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        logger.error('[DEBUG-options] Error requesting permission', { error: errorMessage });\n        return {\n          success: false,\n          message: 'Error with permission request',\n        };\n      }\n    } else {\n      logger.info('[DEBUG-options] No settings to save, skipping permission request');\n    }\n\n    if (permissionGranted) {\n      const data = (await messenger.storage.local.get({\n        appConfig: {\n          enableNotifications: DEFAULTS.enableNotifications,\n          enableLogging: DEFAULTS.enableLogging,\n          modelConcurrencyLimits: DEFAULTS.modelConcurrencyLimits,\n        },\n        providerSettings: {},\n      })) as AppSettingsStorage;\n\n      const providerSettings = data.providerSettings || {};\n      const existingAppConfig = data.appConfig || {};\n\n      const convertedSettings = convertToProviderSettings(settingsToSave);\n      providerSettings[provider] = convertedSettings;\n\n      existingAppConfig.defaultProvider = provider as Provider;\n\n      logger.info('[DEBUG-options] Saving to storage', {\n        appConfig: existingAppConfig,\n        providerSettings,\n      });\n\n      await messenger.storage.local.set({\n        appConfig: existingAppConfig,\n        providerSettings,\n      });\n\n      logger.info('[DEBUG-options] Settings saved successfully');\n\n      return {\n        success: true,\n        message: 'Settings saved!',\n      };\n    } else {\n      logger.warn('[DEBUG-options] Permission denied, settings not saved');\n      return {\n        success: false,\n        message: 'Permission denied. Settings not saved.',\n      };\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('[DEBUG-options] Save failed', { error: errorMessage });\n    return {\n      success: false,\n      message: 'Error saving settings',\n    };\n  }\n}\n\nfunction convertToProviderSettings(settings: PartialProviderConfig) {\n  logger.info('[DEBUG-options] convertToProviderSettings() called', {\n    provider: settings.provider,\n    input: settings,\n  });\n\n  let result: { apiKey: string; model: string; apiUrl?: string };\n\n  switch (settings.provider) {\n    case Provider.OLLAMA:\n      result = {\n        apiKey: '',\n        model: settings.ollamaModel || '',\n        apiUrl: settings.ollamaApiUrl || '',\n      };\n      logger.info('[DEBUG-options] Converted ollama settings', { result });\n      return result;\n\n    case Provider.OPENAI:\n      result = {\n        apiKey: settings.openaiApiKey || '',\n        model: 'gpt-4o-mini',\n      };\n      logger.info('[DEBUG-options] Converted openai settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.GEMINI:\n      result = {\n        apiKey: settings.geminiApiKey || '',\n        model: 'gemini-2.0-flash-exp',\n      };\n      logger.info('[DEBUG-options] Converted gemini settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.CLAUDE:\n      result = {\n        apiKey: settings.claudeApiKey || '',\n        model: 'claude-3-5-sonnet-20241022',\n      };\n      logger.info('[DEBUG-options] Converted claude settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.MISTRAL:\n      result = {\n        apiKey: settings.mistralApiKey || '',\n        model: 'mistral-large-latest',\n      };\n      logger.info('[DEBUG-options] Converted mistral settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.DEEPSEEK:\n      result = {\n        apiKey: settings.deepseekApiKey || '',\n        model: 'deepseek-chat',\n      };\n      logger.info('[DEBUG-options] Converted deepseek settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.ZAI_PAAS:\n      result = {\n        apiKey: settings.zaiPaasApiKey || '',\n        model: settings.zaiPaasModel || 'glm-4.5',\n        apiUrl: 'https://api.z.ai/api/paas/v4/chat/completions',\n      };\n      logger.info('[DEBUG-options] Converted zai-paas settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n        apiUrl: result.apiUrl,\n      });\n      return result;\n\n    case Provider.ZAI_CODING:\n      result = {\n        apiKey: settings.zaiCodingApiKey || '',\n        model: settings.zaiCodingModel || 'glm-4.7',\n        apiUrl: 'https://api.z.ai/api/coding/paas/v4/chat/completions',\n      };\n      logger.info('[DEBUG-options] Converted zai-coding settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n        apiUrl: result.apiUrl,\n      });\n      return result;\n\n    default:\n      throw new Error(`Unknown provider: ${settings.provider}`);\n  }\n}\n\n/**\n * Sets a status message and clears it after a delay\n */\nfunction setStatusMessage(element: HTMLSpanElement, message: string, delay: number = 3000): void {\n  element.textContent = message;\n  setTimeout(() => {\n    element.textContent = '';\n  }, delay);\n}\n\n/**\n * Populates the z.ai model dropdown with available models from the API\n */\nasync function populateZaiModels(provider: 'zaiPaas' | 'zaiCoding'): Promise<void> {\n  const zaiKeyInput = document.getElementById(`${provider}ApiKey`) as HTMLInputElement;\n  const zaiModelSelect = document.getElementById(`${provider}Model`) as HTMLSelectElement;\n\n  if (!zaiKeyInput?.value) {\n    return; // Kein API-Key, nichts zu tun\n  }\n\n  try {\n    logger.info(`[DEBUG-options] Fetching ${provider} models`);\n    const models = await fetchZaiModels(zaiKeyInput.value);\n\n    // Clear existing options\n    zaiModelSelect.innerHTML = '';\n\n    // Add new options\n    models.forEach((model) => {\n      const option = document.createElement('option');\n      option.value = model;\n      option.textContent = model;\n      zaiModelSelect.appendChild(option);\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error(`Failed to populate ${provider} models`, { error: errorMessage });\n  }\n}\n\n// ============================================================================\n// Tag Management Functions\n// ============================================================================\n\n/**\n * Renders the tag list to the DOM\n */\nfunction renderTagList(container: HTMLDivElement, customTags: CustomTags): void {\n  container.innerHTML = '';\n\n  customTags.forEach((tag, index) => {\n    const item = document.createElement('div');\n    item.className = 'tag-item';\n\n    const thresholdDisplay =\n      tag.thresholdOverride !== undefined\n        ? `<span class=\"threshold-badge\">${tag.thresholdOverride}%</span>`\n        : '<span class=\"threshold-badge threshold-global\">Global</span>';\n\n    item.innerHTML = `\n      <div class=\"tag-color-preview\" style=\"background-color: ${escapeHtml(tag.color)};\"></div>\n      <div class=\"tag-details\">\n        <div class=\"tag-name\">${escapeHtml(tag.name)}</div>\n        <div class=\"tag-key\">Key: ${escapeHtml(tag.key)}</div>\n        <div class=\"tag-prompt\">Prompt: ${escapeHtml(tag.prompt || '')}</div>\n        <div class=\"tag-threshold\">Schwellenwert: ${thresholdDisplay}</div>\n      </div>\n      <div class=\"tag-actions\">\n        <button class=\"edit-tag-btn\" data-index=\"${index}\">Edit</button>\n        <button class=\"delete-tag-btn\" data-index=\"${index}\">Delete</button>\n      </div>\n    `;\n    container.appendChild(item);\n  });\n}\n\n/**\n * Cleans up resources when the page is unloaded\n */\nfunction cleanupResources(): void {\n  // No resources to clean up\n}\n\n// ============================================================================\n// ERROR DISPLAY FUNCTIONALITY\n// ============================================================================\n\n/**\n * Error display element in the options page\n */\nlet errorDisplayElement: HTMLDivElement | null = null;\n\n/**\n * Creates the error display overlay if it doesn't exist\n */\nfunction ensureErrorDisplay(): HTMLDivElement {\n  if (errorDisplayElement) {\n    return errorDisplayElement;\n  }\n\n  const errorOverlay = document.createElement('div');\n  errorOverlay.id = 'error-display-overlay';\n  errorOverlay.className = 'error-display-overlay';\n  errorOverlay.innerHTML = `\n    <div class=\"error-display-content\">\n      <div class=\"error-display-header\">\n        <span class=\"error-display-icon\"></span>\n        <h3 id=\"error-display-title\"></h3>\n        <button class=\"error-display-close\">&times;</button>\n      </div>\n      <p id=\"error-display-message\"></p>\n      <div id=\"error-display-details\" style=\"margin-top: 10px; font-size: 12px; color: #666;\"></div>\n    </div>\n  `;\n\n  const closeButton = errorOverlay.querySelector('.error-display-close') as HTMLButtonElement;\n  if (closeButton) {\n    closeButton.addEventListener('click', () => {\n      if (errorDisplayElement) {\n        errorDisplayElement.remove();\n        errorDisplayElement = null;\n      }\n    });\n  }\n\n  document.body.appendChild(errorOverlay);\n  errorDisplayElement = errorOverlay;\n  return errorOverlay;\n}\n\n/**\n * Shows an error message to the user\n * @param error - Error information to display\n */\nfunction showError(error: ErrorDisplay): void {\n  const overlay = ensureErrorDisplay();\n  const title = overlay.querySelector('#error-display-title') as HTMLElement;\n  const message = overlay.querySelector('#error-display-message') as HTMLElement;\n  const details = overlay.querySelector('#error-display-details') as HTMLElement;\n  const icon = overlay.querySelector('.error-display-icon') as HTMLElement;\n\n  // Set icon based on severity\n  switch (error.severity) {\n    case ErrorSeverity.CRITICAL:\n      icon.textContent = '\ud83d\udea8';\n      icon.style.fontSize = '24px';\n      break;\n    case ErrorSeverity.WARNING:\n      icon.textContent = '\u26a0\ufe0f';\n      icon.style.fontSize = '24px';\n      break;\n    case ErrorSeverity.INFO:\n      icon.textContent = '\u2139\ufe0f';\n      icon.style.fontSize = '24px';\n      break;\n  }\n\n  // Set title based on type and severity\n  const typeTitle = error.type ? error.type.charAt(0).toUpperCase() + error.type.slice(1) : 'Error';\n  title.textContent = `${typeTitle} (${error.severity})`;\n\n  // Set message\n  message.textContent = error.message;\n\n  // Set details if available\n  if (error.context && Object.keys(error.context).length > 0) {\n    const detailsText = Object.entries(error.context)\n      .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)\n      .join('\\n');\n    details.textContent = detailsText;\n    details.style.display = 'block';\n  } else {\n    details.style.display = 'none';\n  }\n\n  // Style based on severity\n  overlay.style.display = 'flex';\n  const content = overlay.querySelector('.error-display-content') as HTMLDivElement;\n\n  switch (error.severity) {\n    case ErrorSeverity.CRITICAL:\n      content.style.borderLeft = '4px solid #d32f2f';\n      content.style.backgroundColor = '#ffebee';\n      break;\n    case ErrorSeverity.WARNING:\n      content.style.borderLeft = '4px solid #ff9800';\n      content.style.backgroundColor = '#fff3e0';\n      break;\n    case ErrorSeverity.INFO:\n      content.style.borderLeft = '4px solid #2196f3';\n      content.style.backgroundColor = '#e3f2fd';\n      break;\n  }\n\n  // Auto-hide info and warning errors after 5 seconds\n  if (error.severity !== ErrorSeverity.CRITICAL) {\n    setTimeout(() => {\n      if (overlay && overlay.parentNode) {\n        overlay.remove();\n        errorDisplayElement = null;\n      }\n    }, 5000);\n  }\n\n  logger.info('Error displayed to user', {\n    severity: error.severity,\n    type: error.type,\n    message: error.message,\n  });\n}\n\n/**\n * Handles error messages from background script\n */\nfunction handleBackgroundError(message: ShowErrorRuntimeMessage): void {\n  showError(message.error);\n}\n\n// ============================================================================\n// RUNTIME MESSAGE HANDLER\n// ============================================================================\n\n/**\n * Enhanced sendMessage function that handles error messages\n */\nasync function sendMessage<T = unknown>(message: BatchRuntimeMessage): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    // Type guard to ensure browser.runtime exists\n    if (typeof window !== 'undefined' && 'browser' in window && window.browser) {\n      window.browser.runtime.sendMessage<T>(message, (response: T) => {\n        const lastError = window.browser.runtime?.lastError;\n        if (lastError) {\n          reject(new Error(lastError.message));\n        } else {\n          resolve(response);\n        }\n      });\n    } else {\n      reject(new Error('Browser runtime not available'));\n    }\n  });\n}\n\n/**\n * Runtime message listener for error display and other messages\n */\nfunction setupRuntimeMessageListener(): void {\n  // Type guard to ensure browser.runtime exists\n  if (typeof window !== 'undefined' && 'browser' in window && window.browser) {\n    window.browser.runtime.onMessage.addListener(\n      (message: unknown, sender: unknown, sendResponse: (response?: unknown) => void) => {\n        // Type guard for BatchRuntimeMessage\n        if (typeof message === 'object' && message !== null && 'action' in message) {\n          const typedMessage = message as BatchRuntimeMessage;\n\n          // Handle error display messages\n          if (typedMessage.action === 'showError') {\n            handleBackgroundError(typedMessage as ShowErrorRuntimeMessage);\n            sendResponse({ success: true });\n            return false;\n          }\n        }\n\n        return false; // Let other handlers process the message\n      }\n    );\n  }\n}\n\n/**\n * Handles kill queue button click\n */\nasync function handleKillQueueClick(killQueueBtn: HTMLButtonElement): Promise<void> {\n  try {\n    killQueueBtn.disabled = true;\n\n    const response = await sendMessage<{ success: boolean; message: string }>({\n      action: 'clearQueue',\n      cancelRunning: true,\n    });\n\n    if (response.success) {\n      setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, response.message);\n    } else {\n      setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, response.message);\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to clear queue', { error: errorMessage });\n    setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, `Fehler: ${errorMessage}`);\n  } finally {\n    killQueueBtn.disabled = false;\n  }\n}\n\n/**\n * Handles clear cache button click\n */\nasync function handleClearCacheClick(elements: CacheManagementElements): Promise<void> {\n  try {\n    elements.clearCacheBtn.disabled = true;\n    elements.cacheStatusMessage.textContent = 'Cache wird geleert...';\n\n    const response = await sendMessage<{ success: boolean; message: string }>({\n      action: 'clearCache',\n    });\n\n    if (response.success) {\n      elements.cacheStatusMessage.textContent = response.message;\n    } else {\n      elements.cacheStatusMessage.textContent = response.message;\n    }\n\n    // Refresh cache stats after clearing\n    await updateCacheStats(elements);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to clear cache', { error: errorMessage });\n    elements.cacheStatusMessage.textContent = `Fehler beim Leeren des Cache: ${errorMessage}`;\n  } finally {\n    elements.clearCacheBtn.disabled = false;\n  }\n}\n\n/**\n * Updates cache statistics display\n */\nasync function updateCacheStats(elements: CacheManagementElements): Promise<void> {\n  try {\n    const response = await sendMessage<{\n      success: boolean;\n      totalEntries?: number;\n      hitRate?: number;\n      message?: string;\n    }>({\n      action: 'getCacheStats',\n    });\n\n    if (response.success && response.totalEntries !== undefined && response.hitRate !== undefined) {\n      elements.cacheStats.textContent = `Cache-Eintr\u00e4ge: ${response.totalEntries} | Hit-Rate: ${response.hitRate}%`;\n    } else {\n      elements.cacheStats.textContent = response.message || 'Cache-Statistiken nicht verf\u00fcgbar';\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to get cache stats', { error: errorMessage });\n    elements.cacheStats.textContent = 'Fehler beim Laden der Statistiken';\n  }\n}\n\n/**\n * Checks if provider is configured\n */\nasync function checkProviderConfigured(): Promise<boolean> {\n  try {\n    const settings = await messenger.storage.local.get(DEFAULTS);\n    const provider = settings.provider;\n\n    if (!provider) {\n      return false;\n    }\n\n    // Check provider-specific settings\n    switch (provider) {\n      case 'ollama':\n        return !!(settings.ollamaApiUrl && settings.ollamaModel);\n      case 'openai':\n        return !!settings.openaiApiKey;\n      case 'gemini':\n        return !!settings.geminiApiKey;\n      case 'claude':\n        return !!settings.claudeApiKey;\n      case 'mistral':\n        return !!settings.mistralApiKey;\n      case 'deepseek':\n        return !!settings.deepseekApiKey;\n      case 'zai-paas':\n        return !!settings.zaiPaasApiKey;\n      case 'zai-coding':\n        return !!settings.zaiCodingApiKey;\n      default:\n        return false;\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to check provider configuration', { error: errorMessage });\n    return false;\n  }\n}\n\n/**\n * Escapes HTML special characters to prevent XSS\n */\nfunction escapeHtml(text: string): string {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n/**\n * Loads custom tags from storage\n */\nasync function loadCustomTags(): Promise<CustomTags> {\n  try {\n    const { customTags } = (await messenger.storage.local.get({\n      customTags: DEFAULTS.customTags,\n    })) as CustomTagsStorage;\n\n    const tags = customTags || DEFAULTS.customTags;\n\n    // Load tag thresholds from separate storage and merge with tags\n    const { tagThresholds } = await messenger.storage.local.get({ tagThresholds: {} }) as {\n      tagThresholds: Record<string, number>;\n    };\n\n    // Merge threshold overrides from tagThresholds storage\n    if (tagThresholds && Object.keys(tagThresholds).length > 0) {\n      return tags.map((tag) => ({\n        ...tag,\n        thresholdOverride: tagThresholds[tag.key],\n      }));\n    }\n\n    return tags;\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error loading custom tags', { error: errorMessage });\n    return DEFAULTS.customTags;\n  }\n}\n\n/**\n * Saves custom tags to storage\n */\nasync function saveCustomTags(customTags: CustomTags): Promise<void> {\n  try {\n    // Save custom tags\n    await messenger.storage.local.set({ customTags });\n\n    // Extract and save threshold overrides separately for backend compatibility\n    const tagThresholds: Record<string, number> = {};\n    customTags.forEach((tag) => {\n      if (tag.thresholdOverride !== undefined && tag.thresholdOverride !== null) {\n        tagThresholds[tag.key] = tag.thresholdOverride;\n      }\n    });\n\n    // Always save tagThresholds (empty object if no overrides)\n    await messenger.storage.local.set({ tagThresholds });\n\n    logger.info('Saved custom tags with threshold overrides', {\n      tagCount: customTags.length,\n      thresholdOverrideCount: Object.keys(tagThresholds).length,\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error saving custom tags', { error: errorMessage });\n    throw error;\n  }\n}\n\n/**\n * Opens the tag modal for creating or editing\n */\nfunction openModal(elements: TagManagementElements, context: TagEditContext): void {\n  elements.tagForm.reset();\n  elements.tagIndex.value = context.index.toString();\n\n  if (context.tag) {\n    elements.modalTitle.textContent = 'Edit Tag';\n    elements.tagName.value = context.tag.name;\n    elements.tagKey.value = context.tag.key;\n    elements.tagColor.value = context.tag.color;\n    elements.tagPrompt.value = context.tag.prompt || '';\n\n    // Load threshold override if set\n    if (context.tag.thresholdOverride !== undefined) {\n      elements.tagThreshold.value = context.tag.thresholdOverride.toString();\n      elements.tagThresholdSlider.value = context.tag.thresholdOverride.toString();\n    } else {\n      elements.tagThreshold.value = '';\n      elements.tagThresholdSlider.value = '';\n    }\n  } else {\n    elements.modalTitle.textContent = 'Add New Tag';\n    // Reset threshold fields\n    elements.tagThreshold.value = '';\n    elements.tagThresholdSlider.value = '';\n  }\n\n  elements.modal.style.display = 'flex';\n}\n\n/**\n * Closes the tag modal\n */\nfunction closeModal(elements: TagManagementElements): void {\n  elements.modal.style.display = 'none';\n}\n\n/**\n * Handles tag list button clicks (edit/delete)\n */\nfunction handleTagListClick(\n  elements: TagManagementElements,\n  customTags: CustomTags\n): TagListClickHandler {\n  return (event: MouseEvent): void => {\n    const target = event.target;\n\n    if (isButtonWithIndex(target)) {\n      const index = parseInt(target.dataset.index, 10);\n\n      if (isNaN(index) || index < 0 || index >= customTags.length) {\n        logger.warn('Invalid tag index', { index: target.dataset.index });\n        return;\n      }\n\n      if (target.classList.contains('edit-tag-btn')) {\n        openModal(elements, { tag: customTags[index], index });\n      }\n\n      if (target.classList.contains('delete-tag-btn')) {\n        const tag = customTags[index];\n        if (confirm(`Are you sure you want to delete the \"${tag.name}\" tag?`)) {\n          (customTags as Tag[]).splice(index, 1);\n          saveCustomTags(customTags)\n            .then(() => renderTagList(elements.tagListContainer, customTags))\n            .catch((error) => {\n              logger.error('Failed to delete tag', { error });\n            });\n        }\n      }\n    }\n  };\n}\n\n/**\n * Handles tag form submission\n */\nasync function handleTagFormSubmit(\n  elements: TagManagementElements,\n  customTags: CustomTags\n): Promise<void> {\n  const index = parseInt(elements.tagIndex.value, 10);\n  const name = elements.tagName.value.trim();\n  const key = elements.tagKey.value.trim();\n  const color = elements.tagColor.value;\n  const prompt = elements.tagPrompt.value.trim();\n  const thresholdValue = elements.tagThreshold.value.trim();\n  const thresholdSliderValue = elements.tagThresholdSlider.value.trim();\n\n  // Validate inputs\n  if (!name) {\n    alert('Fehler: Tag-Name ist erforderlich.');\n    return;\n  }\n\n  if (!key) {\n    alert('Fehler: Tag-Schl\u00fcssel ist erforderlich.');\n    return;\n  }\n\n  if (!isValidTagKey(key)) {\n    alert('Fehler: Tag-Schl\u00fcssel darf nur Kleinbuchstaben, Zahlen und Unterstriche enthalten.');\n    return;\n  }\n\n  if (!isValidHexColor(color)) {\n    alert('Fehler: Tag-Farbe muss ein g\u00fcltiger Hex-Farbwert sein (z.B. #FF5722).');\n    return;\n  }\n\n  if (!prompt) {\n    alert('Fehler: Tag-Prompt ist erforderlich.');\n    return;\n  }\n\n  // Check for duplicate keys (excluding current index for edits)\n  const isDuplicate = customTags.some((tag, i) => tag.key === key && i !== index);\n  if (isDuplicate) {\n    alert('Fehler: Tag-Schl\u00fcssel muss eindeutig sein.');\n    return;\n  }\n\n  // Build tag object with threshold override if provided\n  const newTag: Tag = { name, key, color, prompt };\n\n  // Use the number input value (prioritize it over slider)\n  const thresholdInput = thresholdValue || thresholdSliderValue;\n  if (thresholdInput && thresholdInput !== '') {\n    const threshold = parseInt(thresholdInput, 10);\n    if (!isNaN(threshold) && threshold >= 0 && threshold <= 100) {\n      newTag.thresholdOverride = threshold;\n    }\n  }\n\n  if (index === -1) {\n    // Add new tag\n    (customTags as Tag[]).push(newTag);\n  } else {\n    // Update existing tag\n    (customTags as Tag[])[index] = newTag;\n  }\n\n  try {\n    await saveCustomTags(customTags);\n    renderTagList(elements.tagListContainer, customTags);\n    closeModal(elements);\n  } catch (error) {\n    alert('Fehler: Tag konnte nicht gespeichert werden. Bitte versuchen Sie es erneut.');\n  }\n}\n\n// ============================================================================\n// Confidence Threshold Functions\n// ============================================================================\n\n/**\n * Loads the confidence threshold from storage and updates the UI\n */\nasync function loadConfidenceThreshold(elements: ConfidenceThresholdElements): Promise<void> {\n  logger.info('[DEBUG-options] loadConfidenceThreshold() called');\n\n  try {\n    const data = (await messenger.storage.local.get({\n      appConfig: { confidenceThreshold: 70 },\n    })) as AppSettingsStorage;\n\n    const threshold = data.appConfig?.confidenceThreshold ?? 70;\n\n    logger.info('[DEBUG-options] Loaded confidence threshold', { threshold });\n\n    // Update UI elements\n    elements.thresholdSlider.value = threshold.toString();\n    elements.thresholdInput.value = threshold.toString();\n    elements.thresholdValue.textContent = threshold.toString();\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error loading confidence threshold', { error: errorMessage });\n    // Set default value on error\n    elements.thresholdSlider.value = '70';\n    elements.thresholdInput.value = '70';\n    elements.thresholdValue.textContent = '70';\n  }\n}\n\n/**\n * Validates threshold value\n */\nfunction validateThreshold(value: number): boolean {\n  return !isNaN(value) && value >= 0 && value <= 100;\n}\n\n/**\n * Saves the confidence threshold to storage\n */\nasync function saveConfidenceThreshold(elements: ConfidenceThresholdElements): Promise<void> {\n  const thresholdValue = parseInt(elements.thresholdInput.value, 10);\n\n  logger.info('[DEBUG-options] saveConfidenceThreshold() called', { thresholdValue });\n\n  if (!validateThreshold(thresholdValue)) {\n    setStatusMessage(\n      elements.thresholdStatusMessage,\n      'Fehler: Ung\u00fcltiger Schwellenwert. Muss zwischen 0 und 100 liegen.'\n    );\n    return;\n  }\n\n  try {\n    const data = (await messenger.storage.local.get({\n      appConfig: {\n        enableNotifications: DEFAULTS.enableNotifications,\n        enableLogging: DEFAULTS.enableLogging,\n        modelConcurrencyLimits: DEFAULTS.modelConcurrencyLimits,\n        confidenceThreshold: 70,\n      },\n    })) as AppSettingsStorage;\n\n    const existingAppConfig = data.appConfig || {};\n    existingAppConfig.confidenceThreshold = thresholdValue;\n\n    await messenger.storage.local.set({\n      appConfig: existingAppConfig,\n    });\n\n    logger.info('[DEBUG-options] Confidence threshold saved successfully', { thresholdValue });\n\n    setStatusMessage(elements.thresholdStatusMessage, 'Schwellenwert gespeichert!');\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error saving confidence threshold', { error: errorMessage });\n    setStatusMessage(elements.thresholdStatusMessage, `Fehler: ${errorMessage}`);\n  }\n}\n\n/**\n * Resets the confidence threshold to default value (70%)\n */\nasync function resetConfidenceThreshold(elements: ConfidenceThresholdElements): Promise<void> {\n  logger.info('[DEBUG-options] resetConfidenceThreshold() called');\n\n  const defaultValue = 70;\n  elements.thresholdSlider.value = defaultValue.toString();\n  elements.thresholdInput.value = defaultValue.toString();\n  elements.thresholdValue.textContent = defaultValue.toString();\n\n  await saveConfidenceThreshold(elements);\n  setStatusMessage(elements.thresholdStatusMessage, 'Schwellenwert auf Standard zur\u00fcckgesetzt!');\n}\n\n/**\n * Syncs tag modal threshold slider and input values\n */\nfunction syncTagModalThreshold(elements: TagManagementElements, source: 'slider' | 'input'): void {\n  const value = source === 'slider' ? elements.tagThresholdSlider.value : elements.tagThreshold.value;\n  const numValue = parseInt(value, 10);\n\n  if (value === '' || (!isNaN(numValue) && numValue >= 0 && numValue <= 100)) {\n    if (source === 'slider') {\n      elements.tagThreshold.value = value;\n    } else {\n      elements.tagThresholdSlider.value = value;\n    }\n  }\n}\n\n/**\n * Syncs slider and number input values\n */\nfunction syncThresholdValues(\n  source: 'slider' | 'input',\n  elements: ConfidenceThresholdElements\n): void {\n  const value =\n    source === 'slider' ? elements.thresholdSlider.value : elements.thresholdInput.value;\n  const numValue = parseInt(value, 10);\n\n  if (validateThreshold(numValue)) {\n    if (source === 'slider') {\n      elements.thresholdInput.value = value;\n    } else {\n      elements.thresholdSlider.value = value;\n    }\n    elements.thresholdValue.textContent = value;\n  }\n}\n\n// ============================================================================\n// Initialization\n// ============================================================================\n\n/**\n * Initializes the options page\n */\nfunction initializeOptionsPage(): void {\n  try {\n    // Setup error display listener first\n    setupRuntimeMessageListener();\n\n    const elements = getAllDOMElements();\n\n    // Track custom tags state\n    let currentCustomTags: CustomTags = [];\n\n    // Initialize tabs\n    initializeTabs(elements.tabs, elements.tabContents);\n\n    // Initialize general settings\n    loadGeneralSettings(elements).catch((error) => {\n      logger.error('Failed to load general settings on init', { error });\n    });\n\n    // General settings form handler\n    elements.generalForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const result = await handleGeneralSettingsSubmit(elements);\n\n      setStatusMessage(elements.generalStatusMessage, result.message);\n      if (result.success) {\n        setStatusMessage(elements.statusMessage, 'General settings saved!');\n      } else {\n        setStatusMessage(elements.statusMessage, result.message);\n      }\n    });\n\n    // Provider change handler\n    elements.providerSelect.addEventListener('change', (e) => {\n      const target = e.target as HTMLSelectElement;\n      showRelevantSettings(target.value);\n    });\n\n    // z.ai API key change handler - fetch models when key changes\n    if (elements.zaiPaasApiKey) {\n      const debouncedPopulateZaiPaasModels = debounce(() => populateZaiModels('zaiPaas'), 500);\n      elements.zaiPaasApiKey.addEventListener('input', () => {\n        if (elements.zaiPaasApiKey?.value) {\n          debouncedPopulateZaiPaasModels();\n        }\n      });\n    }\n    if (elements.zaiCodingApiKey) {\n      const debouncedPopulateZaiCodingModels = debounce(() => populateZaiModels('zaiCoding'), 500);\n      elements.zaiCodingApiKey.addEventListener('input', () => {\n        if (elements.zaiCodingApiKey?.value) {\n          debouncedPopulateZaiCodingModels();\n        }\n      });\n    }\n\n    // Initialize cache management\n    updateCacheStats(elements).catch((error) => {\n      logger.error('Failed to initialize cache stats', { error });\n    });\n\n    // Cache management event listeners\n    elements.clearCacheBtn.addEventListener('click', () => {\n      handleClearCacheClick(elements);\n    });\n\n    // Kill queue button event listener\n    const killQueueBtn = document.getElementById('kill-queue-btn');\n    if (killQueueBtn) {\n      killQueueBtn.addEventListener('click', () => {\n        handleKillQueueClick(killQueueBtn as HTMLButtonElement).catch((error) => {\n          logger.error('Failed to handle kill queue click', { error });\n        });\n      });\n    }\n\n    // Load and initialize custom tags\n    loadCustomTags()\n      .then((tags) => {\n        currentCustomTags = tags;\n        renderTagList(elements.tagListContainer, currentCustomTags);\n      })\n      .catch((error) => {\n        logger.error('Failed to load custom tags on init', { error });\n      });\n\n    // Add new tag button handler\n    elements.addNewTagBtn.addEventListener('click', () => {\n      openModal(elements, { tag: null, index: -1 });\n    });\n\n    // Close modal button handler\n    elements.closeModalBtn.addEventListener('click', () => {\n      closeModal(elements);\n    });\n\n    // Close modal on outside click\n    window.addEventListener('click', (e) => {\n      if (e.target === elements.modal) {\n        closeModal(elements);\n      }\n    });\n\n    // Tag list click handler\n    elements.tagListContainer.addEventListener(\n      'click',\n      handleTagListClick(elements, currentCustomTags)\n    );\n\n    // Tag form submit handler\n    elements.tagForm.addEventListener('submit', (e) => {\n      e.preventDefault();\n      handleTagFormSubmit(elements, currentCustomTags).catch((error) => {\n        logger.error('Failed to handle tag form submit', { error });\n      });\n    });\n\n    // Tag threshold slider sync handler\n    elements.tagThresholdSlider.addEventListener('input', () => {\n      syncTagModalThreshold(elements, 'slider');\n    });\n\n    // Tag threshold number input sync handler\n    elements.tagThreshold.addEventListener('input', () => {\n      syncTagModalThreshold(elements, 'input');\n    });\n\n    // Initialize confidence threshold\n    loadConfidenceThreshold(elements).catch((error) => {\n      logger.error('Failed to load confidence threshold on init', { error });\n    });\n\n    // Confidence threshold slider change handler\n    elements.thresholdSlider.addEventListener('input', () => {\n      syncThresholdValues('slider', elements);\n    });\n\n    // Confidence threshold number input change handler\n    elements.thresholdInput.addEventListener('input', () => {\n      syncThresholdValues('input', elements);\n    });\n\n    // Save threshold button handler\n    elements.saveThresholdBtn.addEventListener('click', () => {\n      saveConfidenceThreshold(elements).catch((error) => {\n        logger.error('Failed to save confidence threshold', { error });\n      });\n    });\n\n    // Reset threshold button handler\n    elements.resetThresholdBtn.addEventListener('click', () => {\n      resetConfidenceThreshold(elements).catch((error) => {\n        logger.error('Failed to reset confidence threshold', { error });\n      });\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to initialize options page', { error: errorMessage });\n    document.body.innerHTML = `<p style=\"color: red;\">Error initializing options page: ${escapeHtml(errorMessage)}</p>`;\n  }\n}\n\n// Start initialization when DOM is ready\ndocument.addEventListener('DOMContentLoaded', initializeOptionsPage);\n\n// Clean up resources when page unloads\nwindow.addEventListener('beforeunload', cleanupResources);\n",
        "last_modified": "2026-01-05T19:59:00.204229"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "010-confidence-score-display-and-threshold-configurati": {
      "task_id": "010-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "bdfad3eb512d2cde785819b3e597f39d954633f3",
        "content": "import 'reflect-metadata';\n\nimport {\n  DEFAULTS,\n  Provider,\n  ProviderConfig,\n  CustomTags,\n  Tag,\n  isValidProvider,\n  ModelConcurrencyConfig,\n} from './core/config';\nimport {\n  ErrorSeverity,\n  ErrorType,\n  ErrorDisplay,\n  ShowErrorRuntimeMessage,\n  debounce,\n} from './src/infrastructure/providers/ProviderUtils';\n\n/**\n * Batch processing statistics\n */\ninterface BatchStatistics {\n  total: number;\n  successful: number;\n  failed: number;\n  [key: string]: unknown;\n}\nimport { ensureTagsExist } from './core/tags';\nimport { logger } from './src/infrastructure/providers/ProviderUtils';\nimport { fetchZaiModels } from './src/infrastructure/providers';\n\ndeclare const messenger: {\n  storage: {\n    local: {\n      get(\n        keys: Partial<ProviderConfig> | { customTags?: CustomTags }\n      ): Promise<Partial<ProviderConfig> & { customTags?: CustomTags }>;\n      set(items: Partial<ProviderConfig> & { customTags?: CustomTags }): Promise<void>;\n      get(keys: unknown): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n  runtime: {\n    reload(): void;\n  };\n  permissions: {\n    request(permissions: { permissions?: string[]; origins?: string[] }): Promise<boolean>;\n  };\n};\n\ninterface StorageProviderSettings {\n  [providerId: string]: {\n    apiKey: string;\n    model: string;\n    apiUrl?: string;\n  };\n}\n\ninterface AppSettingsStorage {\n  appConfig?: {\n    defaultProvider?: string;\n    enableNotifications?: boolean;\n    enableLogging?: boolean;\n  };\n  providerSettings?: StorageProviderSettings;\n  customTags?: CustomTags;\n}\n\ninterface BrowserRuntime {\n  sendMessage<T = unknown>(message: unknown, callback?: (response: T) => void): void;\n  onMessage: {\n    addListener(\n      callback: (\n        message: unknown,\n        sender: unknown,\n        sendResponse: (response?: unknown) => void\n      ) => void\n    ): void;\n  };\n  lastError?: { message: string };\n}\n\ninterface BrowserExtension {\n  runtime: BrowserRuntime;\n}\n\ndeclare global {\n  interface Window {\n    browser: BrowserExtension;\n  }\n}\n\n// ============================================================================\n// DOM Element Interfaces\n// ============================================================================\n\n/**\n * General Settings DOM Elements\n */\ninterface GeneralSettingsElements {\n  providerSelect: HTMLSelectElement;\n  generalForm: HTMLFormElement;\n  generalStatusMessage: HTMLSpanElement;\n  statusMessage: HTMLSpanElement;\n  ollamaApiUrl: HTMLInputElement | null;\n  ollamaModel: HTMLInputElement | null;\n  openaiApiKey: HTMLInputElement | null;\n  geminiApiKey: HTMLInputElement | null;\n  claudeApiKey: HTMLInputElement | null;\n  mistralApiKey: HTMLInputElement | null;\n  deepseekApiKey: HTMLInputElement | null;\n  zaiPaasApiKey: HTMLInputElement | null;\n  zaiPaasModel: HTMLSelectElement | null;\n  zaiCodingApiKey: HTMLInputElement | null;\n  zaiCodingModel: HTMLSelectElement | null;\n}\n\n/**\n * Tag Management DOM Elements\n */\ninterface TagManagementElements {\n  tagListContainer: HTMLDivElement;\n  modal: HTMLDivElement;\n  modalTitle: HTMLHeadingElement;\n  tagForm: HTMLFormElement;\n  closeModalBtn: HTMLSpanElement;\n  addNewTagBtn: HTMLButtonElement;\n  tagIndex: HTMLInputElement;\n  tagName: HTMLInputElement;\n  tagKey: HTMLInputElement;\n  tagColor: HTMLInputElement;\n  tagPrompt: HTMLTextAreaElement;\n}\n\n/**\n * Tab DOM Elements\n */\ninterface TabElements {\n  tabButtons: NodeListOf<HTMLButtonElement>;\n  tabContents: NodeListOf<HTMLDivElement>;\n}\n\n/**\n * Cache Management DOM Elements\n */\ninterface CacheManagementElements {\n  clearCacheBtn: HTMLButtonElement;\n  cacheStatusMessage: HTMLSpanElement;\n  cacheStats: HTMLSpanElement;\n}\n\n/**\n * All DOM Elements\n */\ninterface DOMElements\n  extends GeneralSettingsElements, TagManagementElements, CacheManagementElements {\n  tabs: TabElements['tabButtons'];\n  tabContents: TabElements['tabContents'];\n}\n\n// ============================================================================\n// UI State Interfaces\n// ============================================================================\n\n/**\n * Tag Form State\n */\ninterface TagFormState {\n  index: number;\n  name: string;\n  key: string;\n  color: string;\n  prompt: string;\n}\n\n/**\n * Settings Save Result\n */\ninterface SettingsSaveResult {\n  success: boolean;\n  message: string;\n}\n\n/**\n * Tag Edit Context\n */\ninterface TagEditContext {\n  tag: Tag | null;\n  index: number;\n}\n\n// ============================================================================\n// Provider Settings Types\n// ============================================================================\n\n/**\n * Settings to save for each provider type\n */\ntype ProviderSettingsData =\n  | { provider: Provider.OLLAMA; ollamaApiUrl: string; ollamaModel: string }\n  | { provider: Provider.OPENAI; openaiApiKey: string }\n  | { provider: Provider.GEMINI; geminiApiKey: string }\n  | { provider: Provider.CLAUDE; claudeApiKey: string }\n  | { provider: Provider.MISTRAL; mistralApiKey: string }\n  | { provider: Provider.DEEPSEEK; deepseekApiKey: string };\n\n/**\n * Partial provider config for saving\n */\ntype PartialProviderConfig = {\n  provider: Provider;\n  ollamaApiUrl?: string;\n  ollamaModel?: string;\n  openaiApiKey?: string;\n  geminiApiKey?: string;\n  claudeApiKey?: string;\n  mistralApiKey?: string;\n  deepseekApiKey?: string;\n  zaiPaasApiKey?: string;\n  zaiPaasModel?: string;\n  zaiCodingApiKey?: string;\n  zaiCodingModel?: string;\n};\n\n// ============================================================================\n// Storage Types\n// ============================================================================\n\n/**\n * Storage response for general settings\n */\ninterface GeneralSettingsStorage {\n  provider?: Provider;\n  ollamaApiUrl?: string;\n  ollamaModel?: string;\n  openaiApiKey?: string;\n  geminiApiKey?: string;\n  claudeApiKey?: string;\n  mistralApiKey?: string;\n  deepseekApiKey?: string;\n  zaiPaasApiKey?: string;\n  zaiPaasModel?: string;\n  zaiCodingApiKey?: string;\n  zaiCodingModel?: string;\n}\n\n/**\n * Storage response for custom tags\n */\ninterface CustomTagsStorage {\n  customTags?: CustomTags;\n}\n\n// ============================================================================\n// Event Handler Types\n// ============================================================================\n\n/**\n * Tab click event handler\n */\ntype TabClickHandler = (event: MouseEvent) => void;\n\n/**\n * Form submit event handler for general settings\n */\ntype GeneralSettingsSubmitHandler = (event: SubmitEvent) => Promise<void>;\n\n/**\n * Provider change event handler\n */\ntype ProviderChangeHandler = (event: Event) => void;\n\n/**\n * Tag list click event handler\n */\ntype TagListClickHandler = (event: MouseEvent) => void;\n\n/**\n * Tag form submit event handler\n */\ntype TagFormSubmitHandler = (event: SubmitEvent) => void;\n\n/**\n * Batch analysis click event handler\n */\ntype BatchAnalysisClickHandler = (event: MouseEvent) => void;\n\n// ============================================================================\n// Batch Analysis Types\n// ============================================================================\n\n/**\n * Batch analysis status\n */\ntype BatchStatus = 'idle' | 'running' | 'completed' | 'cancelled' | 'error';\n\n/**\n * Batch analysis progress data\n */\ninterface BatchProgress {\n  status: BatchStatus;\n  total: number;\n  processed: number;\n  successful: number;\n  failed: number;\n  startTime: number;\n  endTime?: number;\n  errorMessage?: string;\n}\n\n/**\n * Batch analysis response\n */\ninterface BatchAnalysisResponse {\n  success: boolean;\n  statistics?: BatchStatistics;\n  error?: string;\n  message?: string;\n}\n\n/**\n * Batch analysis cancel response\n */\ninterface BatchCancelResponse {\n  success: boolean;\n  message: string;\n}\n\n/**\n * Runtime message types for batch analysis\n */\ntype BatchRuntimeMessage =\n  | { action: 'startBatchAnalysis'; folderId?: string }\n  | { action: 'getBatchProgress' }\n  | { action: 'cancelBatchAnalysis' }\n  | { action: 'clearQueue'; cancelRunning?: boolean }\n  | { action: 'clearCache' }\n  | { action: 'getCacheStats' }\n  | ShowErrorRuntimeMessage;\n\n/**\n * Runtime message response types\n */\ntype BatchRuntimeResponse =\n  | BatchAnalysisResponse\n  | BatchProgress\n  | BatchCancelResponse\n  | { success: boolean; message: string };\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Type guard to check if an element is a valid provider settings element\n */\nfunction isProviderSettingsElement(element: HTMLElement | null): element is HTMLDivElement {\n  return element !== null && element.classList.contains('provider-settings');\n}\n\n/**\n * Type guard to check if an event target is a button with index data\n */\nfunction isButtonWithIndex(\n  target: EventTarget | null\n): target is HTMLButtonElement & { dataset: { index: string } } {\n  if (target === null || !(target instanceof HTMLButtonElement)) {\n    return false;\n  }\n  return 'index' in target.dataset && typeof target.dataset.index === 'string';\n}\n\n/**\n * Validates tag key format\n * Pattern: lowercase letters, numbers, underscores only\n */\nfunction isValidTagKey(key: string): boolean {\n  return /^[a-z0-9_]+$/.test(key);\n}\n\n/**\n * Validates hex color format\n */\nfunction isValidHexColor(color: string): boolean {\n  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n}\n\n/**\n * Gets permission origin for a provider\n */\nfunction getPermissionOrigin(provider: Provider, settings: PartialProviderConfig): string {\n  switch (provider) {\n    case Provider.OLLAMA:\n      if (settings.ollamaApiUrl) {\n        return new URL(settings.ollamaApiUrl).origin + '/*';\n      }\n      throw new Error('Ollama API URL is required for permission request');\n    case Provider.OPENAI:\n      return 'https://api.openai.com/';\n    case Provider.GEMINI:\n      return 'https://generativelanguage.googleapis.com/';\n    case Provider.CLAUDE:\n      return 'https://api.anthropic.com/';\n    case Provider.MISTRAL:\n      return 'https://api.mistral.ai/';\n    case Provider.DEEPSEEK:\n      return 'https://api.deepseek.com/';\n    case Provider.ZAI_PAAS:\n      return 'https://api.z.ai/';\n    case Provider.ZAI_CODING:\n      return 'https://api.z.ai/';\n    default:\n      throw new Error(`Unknown provider: ${provider}`);\n  }\n}\n\n// ============================================================================\n// DOM Element Accessors\n// ============================================================================\n\n/**\n * Safely retrieves an element by ID with type assertion\n */\nfunction getElementById<T extends HTMLElement>(id: string): T | null {\n  return document.getElementById(id) as T | null;\n}\n\n/**\n * Retrieves all general settings DOM elements\n */\nfunction getGeneralSettingsElements(): GeneralSettingsElements {\n  const providerSelect = getElementById<HTMLSelectElement>('provider');\n  const generalForm = getElementById<HTMLFormElement>('provider-options-form');\n  const generalStatusMessage = getElementById<HTMLSpanElement>('provider-status-message');\n  const statusMessage = getElementById<HTMLSpanElement>('provider-status-message');\n  const ollamaApiUrl = getElementById<HTMLInputElement>('ollama-api-url');\n  const ollamaModel = getElementById<HTMLInputElement>('ollama-model');\n  const openaiApiKey = getElementById<HTMLInputElement>('openai-api-key');\n  const geminiApiKey = getElementById<HTMLInputElement>('gemini-api-key');\n  const claudeApiKey = getElementById<HTMLInputElement>('claude-api-key');\n  const mistralApiKey = getElementById<HTMLInputElement>('mistral-api-key');\n  const deepseekApiKey = getElementById<HTMLInputElement>('deepseek-api-key');\n  const zaiPaasApiKey = getElementById<HTMLInputElement>('zaiPaasApiKey');\n  const zaiPaasModel = getElementById<HTMLSelectElement>('zaiPaasModel');\n  const zaiCodingApiKey = getElementById<HTMLInputElement>('zaiCodingApiKey');\n  const zaiCodingModel = getElementById<HTMLSelectElement>('zaiCodingModel');\n\n  if (!providerSelect || !generalForm || !generalStatusMessage || !statusMessage) {\n    throw new Error('Required general settings elements not found');\n  }\n\n  return {\n    providerSelect,\n    generalForm,\n    generalStatusMessage,\n    statusMessage,\n    ollamaApiUrl,\n    ollamaModel,\n    openaiApiKey,\n    geminiApiKey,\n    claudeApiKey,\n    mistralApiKey,\n    deepseekApiKey,\n    zaiPaasApiKey,\n    zaiPaasModel,\n    zaiCodingApiKey,\n    zaiCodingModel,\n  };\n}\n\n/**\n * Retrieves all tag management DOM elements\n */\nfunction getTagManagementElements(): TagManagementElements {\n  const tagListContainer = getElementById<HTMLDivElement>('tag-list-container');\n  const modal = getElementById<HTMLDivElement>('tag-modal');\n  const modalTitle = getElementById<HTMLHeadingElement>('modal-title');\n  const tagForm = getElementById<HTMLFormElement>('tag-form');\n  const closeModalBtn = document.querySelector<HTMLSpanElement>('.close-button');\n  const addNewTagBtn = getElementById<HTMLButtonElement>('add-new-tag-btn');\n  const tagIndex = getElementById<HTMLInputElement>('tag-index');\n  const tagName = getElementById<HTMLInputElement>('tag-name');\n  const tagKey = getElementById<HTMLInputElement>('tag-key');\n  const tagColor = getElementById<HTMLInputElement>('tag-color');\n  const tagPrompt = getElementById<HTMLTextAreaElement>('tag-prompt');\n\n  if (\n    !tagListContainer ||\n    !modal ||\n    !modalTitle ||\n    !tagForm ||\n    !closeModalBtn ||\n    !addNewTagBtn ||\n    !tagIndex ||\n    !tagName ||\n    !tagKey ||\n    !tagColor ||\n    !tagPrompt\n  ) {\n    throw new Error('Required tag management elements not found');\n  }\n\n  return {\n    tagListContainer,\n    modal,\n    modalTitle,\n    tagForm,\n    closeModalBtn,\n    addNewTagBtn,\n    tagIndex,\n    tagName,\n    tagKey,\n    tagColor,\n    tagPrompt,\n  };\n}\n\n/**\n * Retrieves all DOM elements\n */\nfunction getAllDOMElements(): DOMElements {\n  const general = getGeneralSettingsElements();\n  const tag = getTagManagementElements();\n\n  const clearCacheBtn = getElementById<HTMLButtonElement>('clear-cache-btn');\n  const cacheStatusMessage = getElementById<HTMLSpanElement>('cache-status-message');\n  const cacheStats = getElementById<HTMLSpanElement>('cache-stats');\n\n  if (!clearCacheBtn || !cacheStatusMessage || !cacheStats) {\n    throw new Error('Required cache management elements not found');\n  }\n\n  return {\n    ...general,\n    ...tag,\n    clearCacheBtn,\n    cacheStatusMessage,\n    cacheStats,\n    tabs: document.querySelectorAll('.tab-button'),\n    tabContents: document.querySelectorAll('.tab-content'),\n  };\n}\n\n// ============================================================================\n// Tab Management Functions\n// ============================================================================\n\n/**\n * Handles tab switching\n */\nfunction handleTabClick(\n  tabs: NodeListOf<HTMLButtonElement>,\n  tabContents: NodeListOf<HTMLDivElement>\n): TabClickHandler {\n  return (event: MouseEvent): void => {\n    const clickedTab = event.currentTarget as HTMLButtonElement;\n    const targetTabId = clickedTab.dataset.tab;\n\n    if (!targetTabId) {\n      logger.warn('Tab does not have data-tab attribute', { tab: clickedTab });\n      return;\n    }\n\n    tabs.forEach((tab) => tab.classList.remove('active'));\n    clickedTab.classList.add('active');\n\n    tabContents.forEach((content) => content.classList.remove('active'));\n\n    const targetContent = document.getElementById(targetTabId);\n    if (targetContent) {\n      targetContent.classList.add('active');\n    } else {\n      logger.warn('Target tab content not found', { tabId: targetTabId });\n    }\n  };\n}\n\n/**\n * Initializes tab functionality\n */\nfunction initializeTabs(\n  tabs: NodeListOf<HTMLButtonElement>,\n  tabContents: NodeListOf<HTMLDivElement>\n): void {\n  tabs.forEach((tab) => {\n    tab.addEventListener('click', handleTabClick(tabs, tabContents));\n  });\n}\n\n// ============================================================================\n// General Settings Functions\n// ============================================================================\n\n/**\n * Shows/hides provider-specific settings based on selected provider\n */\nfunction showRelevantSettings(provider: string): void {\n  logger.info('[DEBUG-options] showRelevantSettings() called', { provider });\n\n  document.querySelectorAll<HTMLElement>('.provider-settings').forEach((div) => {\n    div.style.display = 'none';\n    div\n      .querySelectorAll<HTMLInputElement | HTMLSelectElement>('input[required], select[required]')\n      .forEach((field) => {\n        field.removeAttribute('required');\n      });\n  });\n\n  const settingsToShow = document.getElementById(`${provider}-settings`);\n  if (settingsToShow && isProviderSettingsElement(settingsToShow)) {\n    logger.info('[DEBUG-options] Showing settings for provider', { provider });\n    settingsToShow.style.display = 'block';\n    settingsToShow\n      .querySelectorAll<HTMLInputElement | HTMLSelectElement>('input, select')\n      .forEach((field) => {\n        field.setAttribute('required', '');\n      });\n  } else {\n    logger.warn('[DEBUG-options] No settings found for provider', { provider });\n  }\n}\n\n/**\n * Loads general settings from storage and populates form fields\n */\nasync function loadGeneralSettings(elements: GeneralSettingsElements): Promise<void> {\n  logger.info('[DEBUG-options] loadGeneralSettings() called');\n\n  try {\n    const data = (await messenger.storage.local.get({\n      appConfig: { defaultProvider: DEFAULTS.provider },\n      providerSettings: {},\n    })) as AppSettingsStorage;\n\n    const appConfig = data.appConfig || {};\n    const providerSettings = data.providerSettings || {};\n\n    logger.info('[DEBUG-options] Storage loaded', {\n      appConfig,\n      providerSettings,\n    });\n\n    elements.providerSelect.value = appConfig.defaultProvider || DEFAULTS.provider;\n\n    if (elements.ollamaApiUrl && providerSettings.ollama) {\n      logger.info('[DEBUG-options] Loaded ollama settings', {\n        apiUrl: providerSettings.ollama.apiUrl,\n        model: providerSettings.ollama.model,\n      });\n      elements.ollamaApiUrl.value = providerSettings.ollama.apiUrl || '';\n    }\n    if (elements.ollamaModel && providerSettings.ollama) {\n      elements.ollamaModel.value = providerSettings.ollama.model || '';\n    }\n    if (elements.openaiApiKey && providerSettings.openai) {\n      logger.info('[DEBUG-options] Loaded openai settings', {\n        apiKey: providerSettings.openai.apiKey ? '***REDACTED***' : '',\n      });\n      elements.openaiApiKey.value = providerSettings.openai.apiKey || '';\n    }\n    if (elements.geminiApiKey && providerSettings.gemini) {\n      logger.info('[DEBUG-options] Loaded gemini settings', {\n        apiKey: providerSettings.gemini.apiKey ? '***REDACTED***' : '',\n      });\n      elements.geminiApiKey.value = providerSettings.gemini.apiKey || '';\n    }\n    if (elements.claudeApiKey && providerSettings.claude) {\n      logger.info('[DEBUG-options] Loaded claude settings', {\n        apiKey: providerSettings.claude.apiKey ? '***REDACTED***' : '',\n      });\n      elements.claudeApiKey.value = providerSettings.claude.apiKey || '';\n    }\n    if (elements.mistralApiKey && providerSettings.mistral) {\n      logger.info('[DEBUG-options] Loaded mistral settings', {\n        apiKey: providerSettings.mistral.apiKey ? '***REDACTED***' : '',\n      });\n      elements.mistralApiKey.value = providerSettings.mistral.apiKey || '';\n    }\n    if (elements.deepseekApiKey && providerSettings.deepseek) {\n      logger.info('[DEBUG-options] Loaded deepseek settings', {\n        apiKey: providerSettings.deepseek.apiKey ? '***REDACTED***' : '',\n      });\n      elements.deepseekApiKey.value = providerSettings.deepseek.apiKey || '';\n    }\n    if (elements.zaiPaasApiKey && providerSettings['zai-paas']) {\n      logger.info('[DEBUG-options] Loaded zai-paas settings', {\n        apiKey: providerSettings['zai-paas'].apiKey ? '***REDACTED***' : '',\n        model: providerSettings['zai-paas'].model,\n      });\n      elements.zaiPaasApiKey.value = providerSettings['zai-paas'].apiKey || '';\n    }\n    if (elements.zaiPaasModel && providerSettings['zai-paas']) {\n      elements.zaiPaasModel.value = providerSettings['zai-paas'].model || '';\n    }\n    if (elements.zaiCodingApiKey && providerSettings['zai-coding']) {\n      logger.info('[DEBUG-options] Loaded zai-coding settings', {\n        apiKey: providerSettings['zai-coding'].apiKey ? '***REDACTED***' : '',\n        model: providerSettings['zai-coding'].model,\n      });\n      elements.zaiCodingApiKey.value = providerSettings['zai-coding'].apiKey || '';\n    }\n    if (elements.zaiCodingModel && providerSettings['zai-coding']) {\n      elements.zaiCodingModel.value = providerSettings['zai-coding'].model || '';\n    }\n\n    showRelevantSettings(appConfig.defaultProvider || DEFAULTS.provider);\n\n    // Populate z.ai models if API key is present\n    if (elements.zaiPaasApiKey && elements.zaiPaasApiKey.value) {\n      logger.info('[DEBUG-options] Populating zaiPaas models on load');\n      populateZaiModels('zaiPaas').catch((error) => {\n        logger.error('Failed to populate z.ai PaaS models on load', { error });\n      });\n    }\n    if (elements.zaiCodingApiKey && elements.zaiCodingApiKey.value) {\n      logger.info('[DEBUG-options] Populating zaiCoding models on load');\n      populateZaiModels('zaiCoding').catch((error) => {\n        logger.error('Failed to populate z.ai Coding models on load', { error });\n      });\n    }\n\n    logger.info('[DEBUG-options] loadGeneralSettings() completed');\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error loading general settings', { error: errorMessage });\n  }\n}\n\n/**\n * Gathers settings data based on selected provider\n */\nfunction gatherProviderSettings(\n  provider: string,\n  elements: GeneralSettingsElements\n): PartialProviderConfig {\n  logger.info('[DEBUG-options] gatherProviderSettings() called', { provider });\n\n  const baseSettings: PartialProviderConfig = { provider: provider as Provider };\n\n  switch (provider) {\n    case Provider.OLLAMA:\n      if (!elements.ollamaApiUrl || !elements.ollamaModel) {\n        throw new Error('Ollama settings elements not found');\n      }\n      const ollamaSettings = {\n        ...baseSettings,\n        ollamaApiUrl: elements.ollamaApiUrl.value.trim(),\n        ollamaModel: elements.ollamaModel.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered ollama settings', {\n        apiUrl: ollamaSettings.ollamaApiUrl,\n        model: ollamaSettings.ollamaModel,\n      });\n      return ollamaSettings;\n\n    case Provider.OPENAI:\n      if (!elements.openaiApiKey) {\n        throw new Error('OpenAI settings element not found');\n      }\n      const openaiSettings = {\n        ...baseSettings,\n        openaiApiKey: elements.openaiApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered openai settings', {\n        apiKey: openaiSettings.openaiApiKey ? '***REDACTED***' : '',\n      });\n      return openaiSettings;\n\n    case Provider.GEMINI:\n      if (!elements.geminiApiKey) {\n        throw new Error('Gemini settings element not found');\n      }\n      const geminiSettings = {\n        ...baseSettings,\n        geminiApiKey: elements.geminiApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered gemini settings', {\n        apiKey: geminiSettings.geminiApiKey ? '***REDACTED***' : '',\n      });\n      return geminiSettings;\n\n    case Provider.CLAUDE:\n      if (!elements.claudeApiKey) {\n        throw new Error('Claude settings element not found');\n      }\n      const claudeSettings = {\n        ...baseSettings,\n        claudeApiKey: elements.claudeApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered claude settings', {\n        apiKey: claudeSettings.claudeApiKey ? '***REDACTED***' : '',\n      });\n      return claudeSettings;\n\n    case Provider.MISTRAL:\n      if (!elements.mistralApiKey) {\n        throw new Error('Mistral settings element not found');\n      }\n      const mistralSettings = {\n        ...baseSettings,\n        mistralApiKey: elements.mistralApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered mistral settings', {\n        apiKey: mistralSettings.mistralApiKey ? '***REDACTED***' : '',\n      });\n      return mistralSettings;\n\n    case Provider.DEEPSEEK:\n      if (!elements.deepseekApiKey) {\n        throw new Error('DeepSeek settings element not found');\n      }\n      const deepseekSettings = {\n        ...baseSettings,\n        deepseekApiKey: elements.deepseekApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered deepseek settings', {\n        apiKey: deepseekSettings.deepseekApiKey ? '***REDACTED***' : '',\n      });\n      return deepseekSettings;\n\n    case Provider.ZAI_PAAS:\n      if (!elements.zaiPaasApiKey || !elements.zaiPaasModel) {\n        throw new Error('Zai PaaS settings element not found');\n      }\n      const zaiPaasSettings = {\n        ...baseSettings,\n        zaiPaasApiKey: elements.zaiPaasApiKey.value.trim(),\n        zaiPaasModel: elements.zaiPaasModel.value,\n      };\n      logger.info('[DEBUG-options] Gathered zai-paas settings', {\n        apiKey: zaiPaasSettings.zaiPaasApiKey ? '***REDACTED***' : '',\n        model: zaiPaasSettings.zaiPaasModel,\n      });\n      return zaiPaasSettings;\n\n    case Provider.ZAI_CODING:\n      if (!elements.zaiCodingApiKey || !elements.zaiCodingModel) {\n        throw new Error('Zai Coding settings element not found');\n      }\n      const zaiCodingSettings = {\n        ...baseSettings,\n        zaiCodingApiKey: elements.zaiCodingApiKey.value.trim(),\n        zaiCodingModel: elements.zaiCodingModel.value,\n      };\n      logger.info('[DEBUG-options] Gathered zai-coding settings', {\n        apiKey: zaiCodingSettings.zaiCodingApiKey ? '***REDACTED***' : '',\n        model: zaiCodingSettings.zaiCodingModel,\n      });\n      return zaiCodingSettings;\n\n    default:\n      throw new Error(`Unknown provider: ${provider}`);\n  }\n}\n\n/**\n * Handles general settings form submission\n */\nasync function handleGeneralSettingsSubmit(\n  elements: GeneralSettingsElements\n): Promise<SettingsSaveResult> {\n  const provider = elements.providerSelect.value;\n\n  logger.info('[DEBUG-options] handleGeneralSettingsSubmit() called', { provider });\n\n  if (!isValidProvider(provider)) {\n    logger.warn('[DEBUG-options] Invalid provider selected', { provider });\n    return {\n      success: false,\n      message: 'Invalid provider selected',\n    };\n  }\n\n  const settingsToSave = gatherProviderSettings(provider, elements);\n  logger.info('[DEBUG-options] Gathered settings', { settingsToSave });\n\n  let permissionGranted = true;\n\n  try {\n    const permissionOrigin = getPermissionOrigin(provider as Provider, settingsToSave);\n    const hasSettings = Object.values(settingsToSave).some((val) => val && val !== '');\n\n    if (hasSettings) {\n      try {\n        logger.info('[DEBUG-options] Requesting permission for origin', {\n          origin: permissionOrigin,\n        });\n        permissionGranted = await messenger.permissions.request({\n          origins: [permissionOrigin],\n        });\n        logger.info('[DEBUG-options] Permission result', {\n          granted: permissionGranted,\n          origin: permissionOrigin,\n        });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        logger.error('[DEBUG-options] Error requesting permission', { error: errorMessage });\n        return {\n          success: false,\n          message: 'Error with permission request',\n        };\n      }\n    } else {\n      logger.info('[DEBUG-options] No settings to save, skipping permission request');\n    }\n\n    if (permissionGranted) {\n      const data = (await messenger.storage.local.get({\n        appConfig: {\n          enableNotifications: DEFAULTS.enableNotifications,\n          enableLogging: DEFAULTS.enableLogging,\n          modelConcurrencyLimits: DEFAULTS.modelConcurrencyLimits,\n        },\n        providerSettings: {},\n      })) as AppSettingsStorage;\n\n      const providerSettings = data.providerSettings || {};\n      const existingAppConfig = data.appConfig || {};\n\n      const convertedSettings = convertToProviderSettings(settingsToSave);\n      providerSettings[provider] = convertedSettings;\n\n      existingAppConfig.defaultProvider = provider as Provider;\n\n      logger.info('[DEBUG-options] Saving to storage', {\n        appConfig: existingAppConfig,\n        providerSettings,\n      });\n\n      await messenger.storage.local.set({\n        appConfig: existingAppConfig,\n        providerSettings,\n      });\n\n      logger.info('[DEBUG-options] Settings saved successfully');\n\n      return {\n        success: true,\n        message: 'Settings saved!',\n      };\n    } else {\n      logger.warn('[DEBUG-options] Permission denied, settings not saved');\n      return {\n        success: false,\n        message: 'Permission denied. Settings not saved.',\n      };\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('[DEBUG-options] Save failed', { error: errorMessage });\n    return {\n      success: false,\n      message: 'Error saving settings',\n    };\n  }\n}\n\nfunction convertToProviderSettings(settings: PartialProviderConfig) {\n  logger.info('[DEBUG-options] convertToProviderSettings() called', {\n    provider: settings.provider,\n    input: settings,\n  });\n\n  let result: { apiKey: string; model: string; apiUrl?: string };\n\n  switch (settings.provider) {\n    case Provider.OLLAMA:\n      result = {\n        apiKey: '',\n        model: settings.ollamaModel || '',\n        apiUrl: settings.ollamaApiUrl || '',\n      };\n      logger.info('[DEBUG-options] Converted ollama settings', { result });\n      return result;\n\n    case Provider.OPENAI:\n      result = {\n        apiKey: settings.openaiApiKey || '',\n        model: 'gpt-4o-mini',\n      };\n      logger.info('[DEBUG-options] Converted openai settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.GEMINI:\n      result = {\n        apiKey: settings.geminiApiKey || '',\n        model: 'gemini-2.0-flash-exp',\n      };\n      logger.info('[DEBUG-options] Converted gemini settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.CLAUDE:\n      result = {\n        apiKey: settings.claudeApiKey || '',\n        model: 'claude-3-5-sonnet-20241022',\n      };\n      logger.info('[DEBUG-options] Converted claude settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.MISTRAL:\n      result = {\n        apiKey: settings.mistralApiKey || '',\n        model: 'mistral-large-latest',\n      };\n      logger.info('[DEBUG-options] Converted mistral settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.DEEPSEEK:\n      result = {\n        apiKey: settings.deepseekApiKey || '',\n        model: 'deepseek-chat',\n      };\n      logger.info('[DEBUG-options] Converted deepseek settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.ZAI_PAAS:\n      result = {\n        apiKey: settings.zaiPaasApiKey || '',\n        model: settings.zaiPaasModel || 'glm-4.5',\n        apiUrl: 'https://api.z.ai/api/paas/v4/chat/completions',\n      };\n      logger.info('[DEBUG-options] Converted zai-paas settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n        apiUrl: result.apiUrl,\n      });\n      return result;\n\n    case Provider.ZAI_CODING:\n      result = {\n        apiKey: settings.zaiCodingApiKey || '',\n        model: settings.zaiCodingModel || 'glm-4.7',\n        apiUrl: 'https://api.z.ai/api/coding/paas/v4/chat/completions',\n      };\n      logger.info('[DEBUG-options] Converted zai-coding settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n        apiUrl: result.apiUrl,\n      });\n      return result;\n\n    default:\n      throw new Error(`Unknown provider: ${settings.provider}`);\n  }\n}\n\n/**\n * Sets a status message and clears it after a delay\n */\nfunction setStatusMessage(element: HTMLSpanElement, message: string, delay: number = 3000): void {\n  element.textContent = message;\n  setTimeout(() => {\n    element.textContent = '';\n  }, delay);\n}\n\n/**\n * Populates the z.ai model dropdown with available models from the API\n */\nasync function populateZaiModels(provider: 'zaiPaas' | 'zaiCoding'): Promise<void> {\n  const zaiKeyInput = document.getElementById(`${provider}ApiKey`) as HTMLInputElement;\n  const zaiModelSelect = document.getElementById(`${provider}Model`) as HTMLSelectElement;\n\n  if (!zaiKeyInput?.value) {\n    return; // Kein API-Key, nichts zu tun\n  }\n\n  try {\n    logger.info(`[DEBUG-options] Fetching ${provider} models`);\n    const models = await fetchZaiModels(zaiKeyInput.value);\n\n    // Clear existing options\n    zaiModelSelect.innerHTML = '';\n\n    // Add new options\n    models.forEach((model) => {\n      const option = document.createElement('option');\n      option.value = model;\n      option.textContent = model;\n      zaiModelSelect.appendChild(option);\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error(`Failed to populate ${provider} models`, { error: errorMessage });\n  }\n}\n\n// ============================================================================\n// Tag Management Functions\n// ============================================================================\n\n/**\n * Renders the tag list to the DOM\n */\nfunction renderTagList(container: HTMLDivElement, customTags: CustomTags): void {\n  container.innerHTML = '';\n\n  customTags.forEach((tag, index) => {\n    const item = document.createElement('div');\n    item.className = 'tag-item';\n    item.innerHTML = `\n      <div class=\"tag-color-preview\" style=\"background-color: ${escapeHtml(tag.color)};\"></div>\n      <div class=\"tag-details\">\n        <div class=\"tag-name\">${escapeHtml(tag.name)}</div>\n        <div class=\"tag-key\">Key: ${escapeHtml(tag.key)}</div>\n        <div class=\"tag-prompt\">Prompt: ${escapeHtml(tag.prompt || '')}</div>\n      </div>\n      <div class=\"tag-actions\">\n        <button class=\"edit-tag-btn\" data-index=\"${index}\">Edit</button>\n        <button class=\"delete-tag-btn\" data-index=\"${index}\">Delete</button>\n      </div>\n    `;\n    container.appendChild(item);\n  });\n}\n\n/**\n * Cleans up resources when the page is unloaded\n */\nfunction cleanupResources(): void {\n  // No resources to clean up\n}\n\n// ============================================================================\n// ERROR DISPLAY FUNCTIONALITY\n// ============================================================================\n\n/**\n * Error display element in the options page\n */\nlet errorDisplayElement: HTMLDivElement | null = null;\n\n/**\n * Creates the error display overlay if it doesn't exist\n */\nfunction ensureErrorDisplay(): HTMLDivElement {\n  if (errorDisplayElement) {\n    return errorDisplayElement;\n  }\n\n  const errorOverlay = document.createElement('div');\n  errorOverlay.id = 'error-display-overlay';\n  errorOverlay.className = 'error-display-overlay';\n  errorOverlay.innerHTML = `\n    <div class=\"error-display-content\">\n      <div class=\"error-display-header\">\n        <span class=\"error-display-icon\"></span>\n        <h3 id=\"error-display-title\"></h3>\n        <button class=\"error-display-close\">&times;</button>\n      </div>\n      <p id=\"error-display-message\"></p>\n      <div id=\"error-display-details\" style=\"margin-top: 10px; font-size: 12px; color: #666;\"></div>\n    </div>\n  `;\n\n  const closeButton = errorOverlay.querySelector('.error-display-close') as HTMLButtonElement;\n  if (closeButton) {\n    closeButton.addEventListener('click', () => {\n      if (errorDisplayElement) {\n        errorDisplayElement.remove();\n        errorDisplayElement = null;\n      }\n    });\n  }\n\n  document.body.appendChild(errorOverlay);\n  errorDisplayElement = errorOverlay;\n  return errorOverlay;\n}\n\n/**\n * Shows an error message to the user\n * @param error - Error information to display\n */\nfunction showError(error: ErrorDisplay): void {\n  const overlay = ensureErrorDisplay();\n  const title = overlay.querySelector('#error-display-title') as HTMLElement;\n  const message = overlay.querySelector('#error-display-message') as HTMLElement;\n  const details = overlay.querySelector('#error-display-details') as HTMLElement;\n  const icon = overlay.querySelector('.error-display-icon') as HTMLElement;\n\n  // Set icon based on severity\n  switch (error.severity) {\n    case ErrorSeverity.CRITICAL:\n      icon.textContent = '\ud83d\udea8';\n      icon.style.fontSize = '24px';\n      break;\n    case ErrorSeverity.WARNING:\n      icon.textContent = '\u26a0\ufe0f';\n      icon.style.fontSize = '24px';\n      break;\n    case ErrorSeverity.INFO:\n      icon.textContent = '\u2139\ufe0f';\n      icon.style.fontSize = '24px';\n      break;\n  }\n\n  // Set title based on type and severity\n  const typeTitle = error.type ? error.type.charAt(0).toUpperCase() + error.type.slice(1) : 'Error';\n  title.textContent = `${typeTitle} (${error.severity})`;\n\n  // Set message\n  message.textContent = error.message;\n\n  // Set details if available\n  if (error.context && Object.keys(error.context).length > 0) {\n    const detailsText = Object.entries(error.context)\n      .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)\n      .join('\\n');\n    details.textContent = detailsText;\n    details.style.display = 'block';\n  } else {\n    details.style.display = 'none';\n  }\n\n  // Style based on severity\n  overlay.style.display = 'flex';\n  const content = overlay.querySelector('.error-display-content') as HTMLDivElement;\n\n  switch (error.severity) {\n    case ErrorSeverity.CRITICAL:\n      content.style.borderLeft = '4px solid #d32f2f';\n      content.style.backgroundColor = '#ffebee';\n      break;\n    case ErrorSeverity.WARNING:\n      content.style.borderLeft = '4px solid #ff9800';\n      content.style.backgroundColor = '#fff3e0';\n      break;\n    case ErrorSeverity.INFO:\n      content.style.borderLeft = '4px solid #2196f3';\n      content.style.backgroundColor = '#e3f2fd';\n      break;\n  }\n\n  // Auto-hide info and warning errors after 5 seconds\n  if (error.severity !== ErrorSeverity.CRITICAL) {\n    setTimeout(() => {\n      if (overlay && overlay.parentNode) {\n        overlay.remove();\n        errorDisplayElement = null;\n      }\n    }, 5000);\n  }\n\n  logger.info('Error displayed to user', {\n    severity: error.severity,\n    type: error.type,\n    message: error.message,\n  });\n}\n\n/**\n * Handles error messages from background script\n */\nfunction handleBackgroundError(message: ShowErrorRuntimeMessage): void {\n  showError(message.error);\n}\n\n// ============================================================================\n// RUNTIME MESSAGE HANDLER\n// ============================================================================\n\n/**\n * Enhanced sendMessage function that handles error messages\n */\nasync function sendMessage<T = unknown>(message: BatchRuntimeMessage): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    // Type guard to ensure browser.runtime exists\n    if (typeof window !== 'undefined' && 'browser' in window && window.browser) {\n      window.browser.runtime.sendMessage<T>(message, (response: T) => {\n        const lastError = window.browser.runtime?.lastError;\n        if (lastError) {\n          reject(new Error(lastError.message));\n        } else {\n          resolve(response);\n        }\n      });\n    } else {\n      reject(new Error('Browser runtime not available'));\n    }\n  });\n}\n\n/**\n * Runtime message listener for error display and other messages\n */\nfunction setupRuntimeMessageListener(): void {\n  // Type guard to ensure browser.runtime exists\n  if (typeof window !== 'undefined' && 'browser' in window && window.browser) {\n    window.browser.runtime.onMessage.addListener(\n      (message: unknown, sender: unknown, sendResponse: (response?: unknown) => void) => {\n        // Type guard for BatchRuntimeMessage\n        if (typeof message === 'object' && message !== null && 'action' in message) {\n          const typedMessage = message as BatchRuntimeMessage;\n\n          // Handle error display messages\n          if (typedMessage.action === 'showError') {\n            handleBackgroundError(typedMessage as ShowErrorRuntimeMessage);\n            sendResponse({ success: true });\n            return false;\n          }\n        }\n\n        return false; // Let other handlers process the message\n      }\n    );\n  }\n}\n\n/**\n * Handles kill queue button click\n */\nasync function handleKillQueueClick(killQueueBtn: HTMLButtonElement): Promise<void> {\n  try {\n    killQueueBtn.disabled = true;\n\n    const response = await sendMessage<{ success: boolean; message: string }>({\n      action: 'clearQueue',\n      cancelRunning: true,\n    });\n\n    if (response.success) {\n      setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, response.message);\n    } else {\n      setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, response.message);\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to clear queue', { error: errorMessage });\n    setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, `Fehler: ${errorMessage}`);\n  } finally {\n    killQueueBtn.disabled = false;\n  }\n}\n\n/**\n * Handles clear cache button click\n */\nasync function handleClearCacheClick(elements: CacheManagementElements): Promise<void> {\n  try {\n    elements.clearCacheBtn.disabled = true;\n    elements.cacheStatusMessage.textContent = 'Cache wird geleert...';\n\n    const response = await sendMessage<{ success: boolean; message: string }>({\n      action: 'clearCache',\n    });\n\n    if (response.success) {\n      elements.cacheStatusMessage.textContent = response.message;\n    } else {\n      elements.cacheStatusMessage.textContent = response.message;\n    }\n\n    // Refresh cache stats after clearing\n    await updateCacheStats(elements);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to clear cache', { error: errorMessage });\n    elements.cacheStatusMessage.textContent = `Fehler beim Leeren des Cache: ${errorMessage}`;\n  } finally {\n    elements.clearCacheBtn.disabled = false;\n  }\n}\n\n/**\n * Updates cache statistics display\n */\nasync function updateCacheStats(elements: CacheManagementElements): Promise<void> {\n  try {\n    const response = await sendMessage<{\n      success: boolean;\n      totalEntries?: number;\n      hitRate?: number;\n      message?: string;\n    }>({\n      action: 'getCacheStats',\n    });\n\n    if (response.success && response.totalEntries !== undefined && response.hitRate !== undefined) {\n      elements.cacheStats.textContent = `Cache-Eintr\u00e4ge: ${response.totalEntries} | Hit-Rate: ${response.hitRate}%`;\n    } else {\n      elements.cacheStats.textContent = response.message || 'Cache-Statistiken nicht verf\u00fcgbar';\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to get cache stats', { error: errorMessage });\n    elements.cacheStats.textContent = 'Fehler beim Laden der Statistiken';\n  }\n}\n\n/**\n * Checks if provider is configured\n */\nasync function checkProviderConfigured(): Promise<boolean> {\n  try {\n    const settings = await messenger.storage.local.get(DEFAULTS);\n    const provider = settings.provider;\n\n    if (!provider) {\n      return false;\n    }\n\n    // Check provider-specific settings\n    switch (provider) {\n      case 'ollama':\n        return !!(settings.ollamaApiUrl && settings.ollamaModel);\n      case 'openai':\n        return !!settings.openaiApiKey;\n      case 'gemini':\n        return !!settings.geminiApiKey;\n      case 'claude':\n        return !!settings.claudeApiKey;\n      case 'mistral':\n        return !!settings.mistralApiKey;\n      case 'deepseek':\n        return !!settings.deepseekApiKey;\n      case 'zai-paas':\n        return !!settings.zaiPaasApiKey;\n      case 'zai-coding':\n        return !!settings.zaiCodingApiKey;\n      default:\n        return false;\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to check provider configuration', { error: errorMessage });\n    return false;\n  }\n}\n\n/**\n * Escapes HTML special characters to prevent XSS\n */\nfunction escapeHtml(text: string): string {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n/**\n * Loads custom tags from storage\n */\nasync function loadCustomTags(): Promise<CustomTags> {\n  try {\n    const { customTags } = (await messenger.storage.local.get({\n      customTags: DEFAULTS.customTags,\n    })) as CustomTagsStorage;\n    return customTags || DEFAULTS.customTags;\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error loading custom tags', { error: errorMessage });\n    return DEFAULTS.customTags;\n  }\n}\n\n/**\n * Saves custom tags to storage\n */\nasync function saveCustomTags(customTags: CustomTags): Promise<void> {\n  try {\n    await messenger.storage.local.set({ customTags });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error saving custom tags', { error: errorMessage });\n    throw error;\n  }\n}\n\n/**\n * Opens the tag modal for creating or editing\n */\nfunction openModal(elements: TagManagementElements, context: TagEditContext): void {\n  elements.tagForm.reset();\n  elements.tagIndex.value = context.index.toString();\n\n  if (context.tag) {\n    elements.modalTitle.textContent = 'Edit Tag';\n    elements.tagName.value = context.tag.name;\n    elements.tagKey.value = context.tag.key;\n    elements.tagColor.value = context.tag.color;\n    elements.tagPrompt.value = context.tag.prompt || '';\n  } else {\n    elements.modalTitle.textContent = 'Add New Tag';\n  }\n\n  elements.modal.style.display = 'flex';\n}\n\n/**\n * Closes the tag modal\n */\nfunction closeModal(elements: TagManagementElements): void {\n  elements.modal.style.display = 'none';\n}\n\n/**\n * Handles tag list button clicks (edit/delete)\n */\nfunction handleTagListClick(\n  elements: TagManagementElements,\n  customTags: CustomTags\n): TagListClickHandler {\n  return (event: MouseEvent): void => {\n    const target = event.target;\n\n    if (isButtonWithIndex(target)) {\n      const index = parseInt(target.dataset.index, 10);\n\n      if (isNaN(index) || index < 0 || index >= customTags.length) {\n        logger.warn('Invalid tag index', { index: target.dataset.index });\n        return;\n      }\n\n      if (target.classList.contains('edit-tag-btn')) {\n        openModal(elements, { tag: customTags[index], index });\n      }\n\n      if (target.classList.contains('delete-tag-btn')) {\n        const tag = customTags[index];\n        if (confirm(`Are you sure you want to delete the \"${tag.name}\" tag?`)) {\n          (customTags as Tag[]).splice(index, 1);\n          saveCustomTags(customTags)\n            .then(() => renderTagList(elements.tagListContainer, customTags))\n            .catch((error) => {\n              logger.error('Failed to delete tag', { error });\n            });\n        }\n      }\n    }\n  };\n}\n\n/**\n * Handles tag form submission\n */\nasync function handleTagFormSubmit(\n  elements: TagManagementElements,\n  customTags: CustomTags\n): Promise<void> {\n  const index = parseInt(elements.tagIndex.value, 10);\n  const name = elements.tagName.value.trim();\n  const key = elements.tagKey.value.trim();\n  const color = elements.tagColor.value;\n  const prompt = elements.tagPrompt.value.trim();\n\n  // Validate inputs\n  if (!name) {\n    alert('Fehler: Tag-Name ist erforderlich.');\n    return;\n  }\n\n  if (!key) {\n    alert('Fehler: Tag-Schl\u00fcssel ist erforderlich.');\n    return;\n  }\n\n  if (!isValidTagKey(key)) {\n    alert('Fehler: Tag-Schl\u00fcssel darf nur Kleinbuchstaben, Zahlen und Unterstriche enthalten.');\n    return;\n  }\n\n  if (!isValidHexColor(color)) {\n    alert('Fehler: Tag-Farbe muss ein g\u00fcltiger Hex-Farbwert sein (z.B. #FF5722).');\n    return;\n  }\n\n  if (!prompt) {\n    alert('Fehler: Tag-Prompt ist erforderlich.');\n    return;\n  }\n\n  // Check for duplicate keys (excluding current index for edits)\n  const isDuplicate = customTags.some((tag, i) => tag.key === key && i !== index);\n  if (isDuplicate) {\n    alert('Fehler: Tag-Schl\u00fcssel muss eindeutig sein.');\n    return;\n  }\n\n  const newTag: Tag = { name, key, color, prompt };\n\n  if (index === -1) {\n    // Add new tag\n    (customTags as Tag[]).push(newTag);\n  } else {\n    // Update existing tag\n    (customTags as Tag[])[index] = newTag;\n  }\n\n  try {\n    await saveCustomTags(customTags);\n    renderTagList(elements.tagListContainer, customTags);\n    closeModal(elements);\n  } catch (error) {\n    alert('Fehler: Tag konnte nicht gespeichert werden. Bitte versuchen Sie es erneut.');\n  }\n}\n\n// ============================================================================\n// Initialization\n// ============================================================================\n\n/**\n * Initializes the options page\n */\nfunction initializeOptionsPage(): void {\n  try {\n    // Setup error display listener first\n    setupRuntimeMessageListener();\n\n    const elements = getAllDOMElements();\n\n    // Track custom tags state\n    let currentCustomTags: CustomTags = [];\n\n    // Initialize tabs\n    initializeTabs(elements.tabs, elements.tabContents);\n\n    // Initialize general settings\n    loadGeneralSettings(elements).catch((error) => {\n      logger.error('Failed to load general settings on init', { error });\n    });\n\n    // General settings form handler\n    elements.generalForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const result = await handleGeneralSettingsSubmit(elements);\n\n      setStatusMessage(elements.generalStatusMessage, result.message);\n      if (result.success) {\n        setStatusMessage(elements.statusMessage, 'General settings saved!');\n      } else {\n        setStatusMessage(elements.statusMessage, result.message);\n      }\n    });\n\n    // Provider change handler\n    elements.providerSelect.addEventListener('change', (e) => {\n      const target = e.target as HTMLSelectElement;\n      showRelevantSettings(target.value);\n    });\n\n    // z.ai API key change handler - fetch models when key changes\n    if (elements.zaiPaasApiKey) {\n      const debouncedPopulateZaiPaasModels = debounce(() => populateZaiModels('zaiPaas'), 500);\n      elements.zaiPaasApiKey.addEventListener('input', () => {\n        if (elements.zaiPaasApiKey?.value) {\n          debouncedPopulateZaiPaasModels();\n        }\n      });\n    }\n    if (elements.zaiCodingApiKey) {\n      const debouncedPopulateZaiCodingModels = debounce(() => populateZaiModels('zaiCoding'), 500);\n      elements.zaiCodingApiKey.addEventListener('input', () => {\n        if (elements.zaiCodingApiKey?.value) {\n          debouncedPopulateZaiCodingModels();\n        }\n      });\n    }\n\n    // Initialize cache management\n    updateCacheStats(elements).catch((error) => {\n      logger.error('Failed to initialize cache stats', { error });\n    });\n\n    // Cache management event listeners\n    elements.clearCacheBtn.addEventListener('click', () => {\n      handleClearCacheClick(elements);\n    });\n\n    // Kill queue button event listener\n    const killQueueBtn = document.getElementById('kill-queue-btn');\n    if (killQueueBtn) {\n      killQueueBtn.addEventListener('click', () => {\n        handleKillQueueClick(killQueueBtn as HTMLButtonElement).catch((error) => {\n          logger.error('Failed to handle kill queue click', { error });\n        });\n      });\n    }\n\n    // Load and initialize custom tags\n    loadCustomTags()\n      .then((tags) => {\n        currentCustomTags = tags;\n        renderTagList(elements.tagListContainer, currentCustomTags);\n      })\n      .catch((error) => {\n        logger.error('Failed to load custom tags on init', { error });\n      });\n\n    // Add new tag button handler\n    elements.addNewTagBtn.addEventListener('click', () => {\n      openModal(elements, { tag: null, index: -1 });\n    });\n\n    // Close modal button handler\n    elements.closeModalBtn.addEventListener('click', () => {\n      closeModal(elements);\n    });\n\n    // Close modal on outside click\n    window.addEventListener('click', (e) => {\n      if (e.target === elements.modal) {\n        closeModal(elements);\n      }\n    });\n\n    // Tag list click handler\n    elements.tagListContainer.addEventListener(\n      'click',\n      handleTagListClick(elements, currentCustomTags)\n    );\n\n    // Tag form submit handler\n    elements.tagForm.addEventListener('submit', (e) => {\n      e.preventDefault();\n      handleTagFormSubmit(elements, currentCustomTags).catch((error) => {\n        logger.error('Failed to handle tag form submit', { error });\n      });\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to initialize options page', { error: errorMessage });\n    document.body.innerHTML = `<p style=\"color: red;\">Error initializing options page: ${escapeHtml(errorMessage)}</p>`;\n  }\n}\n\n// Start initialization when DOM is ready\ndocument.addEventListener('DOMContentLoaded', initializeOptionsPage);\n\n// Clean up resources when page unloads\nwindow.addEventListener('beforeunload', cleanupResources);\n",
        "timestamp": "2026-01-06T07:24:51.082736"
      },
      "worktree_state": {
        "content": "import 'reflect-metadata';\n\nimport {\n  DEFAULTS,\n  Provider,\n  ProviderConfig,\n  CustomTags,\n  Tag,\n  isValidProvider,\n  ModelConcurrencyConfig,\n} from './core/config';\nimport {\n  ErrorSeverity,\n  ErrorType,\n  ErrorDisplay,\n  ShowErrorRuntimeMessage,\n  debounce,\n} from './src/infrastructure/providers/ProviderUtils';\n\n/**\n * Batch processing statistics\n */\ninterface BatchStatistics {\n  total: number;\n  successful: number;\n  failed: number;\n  [key: string]: unknown;\n}\nimport { ensureTagsExist } from './core/tags';\nimport { logger } from './src/infrastructure/providers/ProviderUtils';\nimport { fetchZaiModels } from './src/infrastructure/providers';\n\ndeclare const messenger: {\n  storage: {\n    local: {\n      get(\n        keys: Partial<ProviderConfig> | { customTags?: CustomTags }\n      ): Promise<Partial<ProviderConfig> & { customTags?: CustomTags }>;\n      set(items: Partial<ProviderConfig> & { customTags?: CustomTags }): Promise<void>;\n      get(keys: unknown): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n  runtime: {\n    reload(): void;\n  };\n  permissions: {\n    request(permissions: { permissions?: string[]; origins?: string[] }): Promise<boolean>;\n  };\n};\n\ninterface StorageProviderSettings {\n  [providerId: string]: {\n    apiKey: string;\n    model: string;\n    apiUrl?: string;\n  };\n}\n\ninterface AppSettingsStorage {\n  appConfig?: {\n    defaultProvider?: string;\n    enableNotifications?: boolean;\n    enableLogging?: boolean;\n    minConfidenceThreshold?: number;\n  };\n  providerSettings?: StorageProviderSettings;\n  customTags?: CustomTags;\n}\n\ninterface BrowserRuntime {\n  sendMessage<T = unknown>(message: unknown, callback?: (response: T) => void): void;\n  onMessage: {\n    addListener(\n      callback: (\n        message: unknown,\n        sender: unknown,\n        sendResponse: (response?: unknown) => void\n      ) => void\n    ): void;\n  };\n  lastError?: { message: string };\n}\n\ninterface BrowserExtension {\n  runtime: BrowserRuntime;\n}\n\ndeclare global {\n  interface Window {\n    browser: BrowserExtension;\n  }\n}\n\n// ============================================================================\n// DOM Element Interfaces\n// ============================================================================\n\n/**\n * General Settings DOM Elements\n */\ninterface GeneralSettingsElements {\n  providerSelect: HTMLSelectElement;\n  generalForm: HTMLFormElement;\n  generalStatusMessage: HTMLSpanElement;\n  statusMessage: HTMLSpanElement;\n  ollamaApiUrl: HTMLInputElement | null;\n  ollamaModel: HTMLInputElement | null;\n  openaiApiKey: HTMLInputElement | null;\n  geminiApiKey: HTMLInputElement | null;\n  claudeApiKey: HTMLInputElement | null;\n  mistralApiKey: HTMLInputElement | null;\n  deepseekApiKey: HTMLInputElement | null;\n  zaiPaasApiKey: HTMLInputElement | null;\n  zaiPaasModel: HTMLSelectElement | null;\n  zaiCodingApiKey: HTMLInputElement | null;\n  zaiCodingModel: HTMLSelectElement | null;\n  minConfidenceThreshold: HTMLInputElement | null;\n  minConfidenceThresholdSlider: HTMLInputElement | null;\n  confidenceValue: HTMLSpanElement | null;\n}\n\n/**\n * Tag Management DOM Elements\n */\ninterface TagManagementElements {\n  tagListContainer: HTMLDivElement;\n  modal: HTMLDivElement;\n  modalTitle: HTMLHeadingElement;\n  tagForm: HTMLFormElement;\n  closeModalBtn: HTMLSpanElement;\n  addNewTagBtn: HTMLButtonElement;\n  tagIndex: HTMLInputElement;\n  tagName: HTMLInputElement;\n  tagKey: HTMLInputElement;\n  tagColor: HTMLInputElement;\n  tagPrompt: HTMLTextAreaElement;\n  tagThreshold: HTMLInputElement;\n}\n\n/**\n * Tab DOM Elements\n */\ninterface TabElements {\n  tabButtons: NodeListOf<HTMLButtonElement>;\n  tabContents: NodeListOf<HTMLDivElement>;\n}\n\n/**\n * Cache Management DOM Elements\n */\ninterface CacheManagementElements {\n  clearCacheBtn: HTMLButtonElement;\n  cacheStatusMessage: HTMLSpanElement;\n  cacheStats: HTMLSpanElement;\n}\n\n/**\n * All DOM Elements\n */\ninterface DOMElements\n  extends GeneralSettingsElements, TagManagementElements, CacheManagementElements {\n  tabs: TabElements['tabButtons'];\n  tabContents: TabElements['tabContents'];\n}\n\n// ============================================================================\n// UI State Interfaces\n// ============================================================================\n\n/**\n * Tag Form State\n */\ninterface TagFormState {\n  index: number;\n  name: string;\n  key: string;\n  color: string;\n  prompt: string;\n}\n\n/**\n * Settings Save Result\n */\ninterface SettingsSaveResult {\n  success: boolean;\n  message: string;\n}\n\n/**\n * Tag Edit Context\n */\ninterface TagEditContext {\n  tag: Tag | null;\n  index: number;\n}\n\n// ============================================================================\n// Provider Settings Types\n// ============================================================================\n\n/**\n * Settings to save for each provider type\n */\ntype ProviderSettingsData =\n  | { provider: Provider.OLLAMA; ollamaApiUrl: string; ollamaModel: string }\n  | { provider: Provider.OPENAI; openaiApiKey: string }\n  | { provider: Provider.GEMINI; geminiApiKey: string }\n  | { provider: Provider.CLAUDE; claudeApiKey: string }\n  | { provider: Provider.MISTRAL; mistralApiKey: string }\n  | { provider: Provider.DEEPSEEK; deepseekApiKey: string };\n\n/**\n * Partial provider config for saving\n */\ntype PartialProviderConfig = {\n  provider: Provider;\n  ollamaApiUrl?: string;\n  ollamaModel?: string;\n  openaiApiKey?: string;\n  geminiApiKey?: string;\n  claudeApiKey?: string;\n  mistralApiKey?: string;\n  deepseekApiKey?: string;\n  zaiPaasApiKey?: string;\n  zaiPaasModel?: string;\n  zaiCodingApiKey?: string;\n  zaiCodingModel?: string;\n};\n\n// ============================================================================\n// Storage Types\n// ============================================================================\n\n/**\n * Storage response for general settings\n */\ninterface GeneralSettingsStorage {\n  provider?: Provider;\n  ollamaApiUrl?: string;\n  ollamaModel?: string;\n  openaiApiKey?: string;\n  geminiApiKey?: string;\n  claudeApiKey?: string;\n  mistralApiKey?: string;\n  deepseekApiKey?: string;\n  zaiPaasApiKey?: string;\n  zaiPaasModel?: string;\n  zaiCodingApiKey?: string;\n  zaiCodingModel?: string;\n}\n\n/**\n * Storage response for custom tags\n */\ninterface CustomTagsStorage {\n  customTags?: CustomTags;\n}\n\n// ============================================================================\n// Event Handler Types\n// ============================================================================\n\n/**\n * Tab click event handler\n */\ntype TabClickHandler = (event: MouseEvent) => void;\n\n/**\n * Form submit event handler for general settings\n */\ntype GeneralSettingsSubmitHandler = (event: SubmitEvent) => Promise<void>;\n\n/**\n * Provider change event handler\n */\ntype ProviderChangeHandler = (event: Event) => void;\n\n/**\n * Tag list click event handler\n */\ntype TagListClickHandler = (event: MouseEvent) => void;\n\n/**\n * Tag form submit event handler\n */\ntype TagFormSubmitHandler = (event: SubmitEvent) => void;\n\n/**\n * Batch analysis click event handler\n */\ntype BatchAnalysisClickHandler = (event: MouseEvent) => void;\n\n// ============================================================================\n// Batch Analysis Types\n// ============================================================================\n\n/**\n * Batch analysis status\n */\ntype BatchStatus = 'idle' | 'running' | 'completed' | 'cancelled' | 'error';\n\n/**\n * Batch analysis progress data\n */\ninterface BatchProgress {\n  status: BatchStatus;\n  total: number;\n  processed: number;\n  successful: number;\n  failed: number;\n  startTime: number;\n  endTime?: number;\n  errorMessage?: string;\n}\n\n/**\n * Batch analysis response\n */\ninterface BatchAnalysisResponse {\n  success: boolean;\n  statistics?: BatchStatistics;\n  error?: string;\n  message?: string;\n}\n\n/**\n * Batch analysis cancel response\n */\ninterface BatchCancelResponse {\n  success: boolean;\n  message: string;\n}\n\n/**\n * Runtime message types for batch analysis\n */\ntype BatchRuntimeMessage =\n  | { action: 'startBatchAnalysis'; folderId?: string }\n  | { action: 'getBatchProgress' }\n  | { action: 'cancelBatchAnalysis' }\n  | { action: 'clearQueue'; cancelRunning?: boolean }\n  | { action: 'clearCache' }\n  | { action: 'getCacheStats' }\n  | ShowErrorRuntimeMessage;\n\n/**\n * Runtime message response types\n */\ntype BatchRuntimeResponse =\n  | BatchAnalysisResponse\n  | BatchProgress\n  | BatchCancelResponse\n  | { success: boolean; message: string };\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Type guard to check if an element is a valid provider settings element\n */\nfunction isProviderSettingsElement(element: HTMLElement | null): element is HTMLDivElement {\n  return element !== null && element.classList.contains('provider-settings');\n}\n\n/**\n * Type guard to check if an event target is a button with index data\n */\nfunction isButtonWithIndex(\n  target: EventTarget | null\n): target is HTMLButtonElement & { dataset: { index: string } } {\n  if (target === null || !(target instanceof HTMLButtonElement)) {\n    return false;\n  }\n  return 'index' in target.dataset && typeof target.dataset.index === 'string';\n}\n\n/**\n * Validates tag key format\n * Pattern: lowercase letters, numbers, underscores only\n */\nfunction isValidTagKey(key: string): boolean {\n  return /^[a-z0-9_]+$/.test(key);\n}\n\n/**\n * Validates hex color format\n */\nfunction isValidHexColor(color: string): boolean {\n  return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(color);\n}\n\n/**\n * Gets permission origin for a provider\n */\nfunction getPermissionOrigin(provider: Provider, settings: PartialProviderConfig): string {\n  switch (provider) {\n    case Provider.OLLAMA:\n      if (settings.ollamaApiUrl) {\n        return new URL(settings.ollamaApiUrl).origin + '/*';\n      }\n      throw new Error('Ollama API URL is required for permission request');\n    case Provider.OPENAI:\n      return 'https://api.openai.com/';\n    case Provider.GEMINI:\n      return 'https://generativelanguage.googleapis.com/';\n    case Provider.CLAUDE:\n      return 'https://api.anthropic.com/';\n    case Provider.MISTRAL:\n      return 'https://api.mistral.ai/';\n    case Provider.DEEPSEEK:\n      return 'https://api.deepseek.com/';\n    case Provider.ZAI_PAAS:\n      return 'https://api.z.ai/';\n    case Provider.ZAI_CODING:\n      return 'https://api.z.ai/';\n    default:\n      throw new Error(`Unknown provider: ${provider}`);\n  }\n}\n\n// ============================================================================\n// DOM Element Accessors\n// ============================================================================\n\n/**\n * Safely retrieves an element by ID with type assertion\n */\nfunction getElementById<T extends HTMLElement>(id: string): T | null {\n  return document.getElementById(id) as T | null;\n}\n\n/**\n * Retrieves all general settings DOM elements\n */\nfunction getGeneralSettingsElements(): GeneralSettingsElements {\n  const providerSelect = getElementById<HTMLSelectElement>('provider');\n  const generalForm = getElementById<HTMLFormElement>('provider-options-form');\n  const generalStatusMessage = getElementById<HTMLSpanElement>('provider-status-message');\n  const statusMessage = getElementById<HTMLSpanElement>('provider-status-message');\n  const ollamaApiUrl = getElementById<HTMLInputElement>('ollama-api-url');\n  const ollamaModel = getElementById<HTMLInputElement>('ollama-model');\n  const openaiApiKey = getElementById<HTMLInputElement>('openai-api-key');\n  const geminiApiKey = getElementById<HTMLInputElement>('gemini-api-key');\n  const claudeApiKey = getElementById<HTMLInputElement>('claude-api-key');\n  const mistralApiKey = getElementById<HTMLInputElement>('mistral-api-key');\n  const deepseekApiKey = getElementById<HTMLInputElement>('deepseek-api-key');\n  const zaiPaasApiKey = getElementById<HTMLInputElement>('zaiPaasApiKey');\n  const zaiPaasModel = getElementById<HTMLSelectElement>('zaiPaasModel');\n  const zaiCodingApiKey = getElementById<HTMLInputElement>('zaiCodingApiKey');\n  const zaiCodingModel = getElementById<HTMLSelectElement>('zaiCodingModel');\n  const minConfidenceThreshold = getElementById<HTMLInputElement>('min-confidence-threshold');\n  const minConfidenceThresholdSlider = getElementById<HTMLInputElement>('min-confidence-threshold-slider');\n  const confidenceValue = getElementById<HTMLSpanElement>('confidence-value');\n\n  if (!providerSelect || !generalForm || !generalStatusMessage || !statusMessage) {\n    throw new Error('Required general settings elements not found');\n  }\n\n  return {\n    providerSelect,\n    generalForm,\n    generalStatusMessage,\n    statusMessage,\n    ollamaApiUrl,\n    ollamaModel,\n    openaiApiKey,\n    geminiApiKey,\n    claudeApiKey,\n    mistralApiKey,\n    deepseekApiKey,\n    zaiPaasApiKey,\n    zaiPaasModel,\n    zaiCodingApiKey,\n    zaiCodingModel,\n    minConfidenceThreshold,\n    minConfidenceThresholdSlider,\n    confidenceValue,\n  };\n}\n\n/**\n * Retrieves all tag management DOM elements\n */\nfunction getTagManagementElements(): TagManagementElements {\n  const tagListContainer = getElementById<HTMLDivElement>('tag-list-container');\n  const modal = getElementById<HTMLDivElement>('tag-modal');\n  const modalTitle = getElementById<HTMLHeadingElement>('modal-title');\n  const tagForm = getElementById<HTMLFormElement>('tag-form');\n  const closeModalBtn = document.querySelector<HTMLSpanElement>('.close-button');\n  const addNewTagBtn = getElementById<HTMLButtonElement>('add-new-tag-btn');\n  const tagIndex = getElementById<HTMLInputElement>('tag-index');\n  const tagName = getElementById<HTMLInputElement>('tag-name');\n  const tagKey = getElementById<HTMLInputElement>('tag-key');\n  const tagColor = getElementById<HTMLInputElement>('tag-color');\n  const tagPrompt = getElementById<HTMLTextAreaElement>('tag-prompt');\n  const tagThreshold = getElementById<HTMLInputElement>('tag-threshold');\n\n  if (\n    !tagListContainer ||\n    !modal ||\n    !modalTitle ||\n    !tagForm ||\n    !closeModalBtn ||\n    !addNewTagBtn ||\n    !tagIndex ||\n    !tagName ||\n    !tagKey ||\n    !tagColor ||\n    !tagPrompt ||\n    !tagThreshold\n  ) {\n    throw new Error('Required tag management elements not found');\n  }\n\n  return {\n    tagListContainer,\n    modal,\n    modalTitle,\n    tagForm,\n    closeModalBtn,\n    addNewTagBtn,\n    tagIndex,\n    tagName,\n    tagKey,\n    tagColor,\n    tagPrompt,\n    tagThreshold,\n  };\n}\n\n/**\n * Retrieves all DOM elements\n */\nfunction getAllDOMElements(): DOMElements {\n  const general = getGeneralSettingsElements();\n  const tag = getTagManagementElements();\n\n  const clearCacheBtn = getElementById<HTMLButtonElement>('clear-cache-btn');\n  const cacheStatusMessage = getElementById<HTMLSpanElement>('cache-status-message');\n  const cacheStats = getElementById<HTMLSpanElement>('cache-stats');\n\n  if (!clearCacheBtn || !cacheStatusMessage || !cacheStats) {\n    throw new Error('Required cache management elements not found');\n  }\n\n  return {\n    ...general,\n    ...tag,\n    clearCacheBtn,\n    cacheStatusMessage,\n    cacheStats,\n    tabs: document.querySelectorAll('.tab-button'),\n    tabContents: document.querySelectorAll('.tab-content'),\n  };\n}\n\n// ============================================================================\n// Tab Management Functions\n// ============================================================================\n\n/**\n * Handles tab switching\n */\nfunction handleTabClick(\n  tabs: NodeListOf<HTMLButtonElement>,\n  tabContents: NodeListOf<HTMLDivElement>\n): TabClickHandler {\n  return (event: MouseEvent): void => {\n    const clickedTab = event.currentTarget as HTMLButtonElement;\n    const targetTabId = clickedTab.dataset.tab;\n\n    if (!targetTabId) {\n      logger.warn('Tab does not have data-tab attribute', { tab: clickedTab });\n      return;\n    }\n\n    tabs.forEach((tab) => tab.classList.remove('active'));\n    clickedTab.classList.add('active');\n\n    tabContents.forEach((content) => content.classList.remove('active'));\n\n    const targetContent = document.getElementById(targetTabId);\n    if (targetContent) {\n      targetContent.classList.add('active');\n    } else {\n      logger.warn('Target tab content not found', { tabId: targetTabId });\n    }\n  };\n}\n\n/**\n * Initializes tab functionality\n */\nfunction initializeTabs(\n  tabs: NodeListOf<HTMLButtonElement>,\n  tabContents: NodeListOf<HTMLDivElement>\n): void {\n  tabs.forEach((tab) => {\n    tab.addEventListener('click', handleTabClick(tabs, tabContents));\n  });\n}\n\n// ============================================================================\n// General Settings Functions\n// ============================================================================\n\n/**\n * Shows/hides provider-specific settings based on selected provider\n */\nfunction showRelevantSettings(provider: string): void {\n  logger.info('[DEBUG-options] showRelevantSettings() called', { provider });\n\n  document.querySelectorAll<HTMLElement>('.provider-settings').forEach((div) => {\n    div.style.display = 'none';\n    div\n      .querySelectorAll<HTMLInputElement | HTMLSelectElement>('input[required], select[required]')\n      .forEach((field) => {\n        field.removeAttribute('required');\n      });\n  });\n\n  const settingsToShow = document.getElementById(`${provider}-settings`);\n  if (settingsToShow && isProviderSettingsElement(settingsToShow)) {\n    logger.info('[DEBUG-options] Showing settings for provider', { provider });\n    settingsToShow.style.display = 'block';\n    settingsToShow\n      .querySelectorAll<HTMLInputElement | HTMLSelectElement>('input, select')\n      .forEach((field) => {\n        field.setAttribute('required', '');\n      });\n  } else {\n    logger.warn('[DEBUG-options] No settings found for provider', { provider });\n  }\n}\n\n/**\n * Loads general settings from storage and populates form fields\n */\nasync function loadGeneralSettings(elements: GeneralSettingsElements): Promise<void> {\n  logger.info('[DEBUG-options] loadGeneralSettings() called');\n\n  try {\n    const data = (await messenger.storage.local.get({\n      appConfig: { defaultProvider: DEFAULTS.provider },\n      providerSettings: {},\n    })) as AppSettingsStorage;\n\n    const appConfig = data.appConfig || {};\n    const providerSettings = data.providerSettings || {};\n\n    logger.info('[DEBUG-options] Storage loaded', {\n      appConfig,\n      providerSettings,\n    });\n\n    elements.providerSelect.value = appConfig.defaultProvider || DEFAULTS.provider;\n\n    // Load min confidence threshold\n    const minConfidenceThreshold = appConfig.minConfidenceThreshold ?? DEFAULTS.minConfidenceThreshold;\n    if (elements.minConfidenceThreshold) {\n      elements.minConfidenceThreshold.value = minConfidenceThreshold.toString();\n    }\n    if (elements.minConfidenceThresholdSlider) {\n      elements.minConfidenceThresholdSlider.value = minConfidenceThreshold.toString();\n    }\n    if (elements.confidenceValue) {\n      elements.confidenceValue.textContent = minConfidenceThreshold.toString();\n    }\n    logger.info('[DEBUG-options] Loaded minConfidenceThreshold', {\n      threshold: minConfidenceThreshold,\n    });\n\n    if (elements.ollamaApiUrl && providerSettings.ollama) {\n      logger.info('[DEBUG-options] Loaded ollama settings', {\n        apiUrl: providerSettings.ollama.apiUrl,\n        model: providerSettings.ollama.model,\n      });\n      elements.ollamaApiUrl.value = providerSettings.ollama.apiUrl || '';\n    }\n    if (elements.ollamaModel && providerSettings.ollama) {\n      elements.ollamaModel.value = providerSettings.ollama.model || '';\n    }\n    if (elements.openaiApiKey && providerSettings.openai) {\n      logger.info('[DEBUG-options] Loaded openai settings', {\n        apiKey: providerSettings.openai.apiKey ? '***REDACTED***' : '',\n      });\n      elements.openaiApiKey.value = providerSettings.openai.apiKey || '';\n    }\n    if (elements.geminiApiKey && providerSettings.gemini) {\n      logger.info('[DEBUG-options] Loaded gemini settings', {\n        apiKey: providerSettings.gemini.apiKey ? '***REDACTED***' : '',\n      });\n      elements.geminiApiKey.value = providerSettings.gemini.apiKey || '';\n    }\n    if (elements.claudeApiKey && providerSettings.claude) {\n      logger.info('[DEBUG-options] Loaded claude settings', {\n        apiKey: providerSettings.claude.apiKey ? '***REDACTED***' : '',\n      });\n      elements.claudeApiKey.value = providerSettings.claude.apiKey || '';\n    }\n    if (elements.mistralApiKey && providerSettings.mistral) {\n      logger.info('[DEBUG-options] Loaded mistral settings', {\n        apiKey: providerSettings.mistral.apiKey ? '***REDACTED***' : '',\n      });\n      elements.mistralApiKey.value = providerSettings.mistral.apiKey || '';\n    }\n    if (elements.deepseekApiKey && providerSettings.deepseek) {\n      logger.info('[DEBUG-options] Loaded deepseek settings', {\n        apiKey: providerSettings.deepseek.apiKey ? '***REDACTED***' : '',\n      });\n      elements.deepseekApiKey.value = providerSettings.deepseek.apiKey || '';\n    }\n    if (elements.zaiPaasApiKey && providerSettings['zai-paas']) {\n      logger.info('[DEBUG-options] Loaded zai-paas settings', {\n        apiKey: providerSettings['zai-paas'].apiKey ? '***REDACTED***' : '',\n        model: providerSettings['zai-paas'].model,\n      });\n      elements.zaiPaasApiKey.value = providerSettings['zai-paas'].apiKey || '';\n    }\n    if (elements.zaiPaasModel && providerSettings['zai-paas']) {\n      elements.zaiPaasModel.value = providerSettings['zai-paas'].model || '';\n    }\n    if (elements.zaiCodingApiKey && providerSettings['zai-coding']) {\n      logger.info('[DEBUG-options] Loaded zai-coding settings', {\n        apiKey: providerSettings['zai-coding'].apiKey ? '***REDACTED***' : '',\n        model: providerSettings['zai-coding'].model,\n      });\n      elements.zaiCodingApiKey.value = providerSettings['zai-coding'].apiKey || '';\n    }\n    if (elements.zaiCodingModel && providerSettings['zai-coding']) {\n      elements.zaiCodingModel.value = providerSettings['zai-coding'].model || '';\n    }\n\n    showRelevantSettings(appConfig.defaultProvider || DEFAULTS.provider);\n\n    // Populate z.ai models if API key is present\n    if (elements.zaiPaasApiKey && elements.zaiPaasApiKey.value) {\n      logger.info('[DEBUG-options] Populating zaiPaas models on load');\n      populateZaiModels('zaiPaas').catch((error) => {\n        logger.error('Failed to populate z.ai PaaS models on load', { error });\n      });\n    }\n    if (elements.zaiCodingApiKey && elements.zaiCodingApiKey.value) {\n      logger.info('[DEBUG-options] Populating zaiCoding models on load');\n      populateZaiModels('zaiCoding').catch((error) => {\n        logger.error('Failed to populate z.ai Coding models on load', { error });\n      });\n    }\n\n    logger.info('[DEBUG-options] loadGeneralSettings() completed');\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error loading general settings', { error: errorMessage });\n  }\n}\n\n/**\n * Gathers settings data based on selected provider\n */\nfunction gatherProviderSettings(\n  provider: string,\n  elements: GeneralSettingsElements\n): PartialProviderConfig {\n  logger.info('[DEBUG-options] gatherProviderSettings() called', { provider });\n\n  const baseSettings: PartialProviderConfig = { provider: provider as Provider };\n\n  switch (provider) {\n    case Provider.OLLAMA:\n      if (!elements.ollamaApiUrl || !elements.ollamaModel) {\n        throw new Error('Ollama settings elements not found');\n      }\n      const ollamaSettings = {\n        ...baseSettings,\n        ollamaApiUrl: elements.ollamaApiUrl.value.trim(),\n        ollamaModel: elements.ollamaModel.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered ollama settings', {\n        apiUrl: ollamaSettings.ollamaApiUrl,\n        model: ollamaSettings.ollamaModel,\n      });\n      return ollamaSettings;\n\n    case Provider.OPENAI:\n      if (!elements.openaiApiKey) {\n        throw new Error('OpenAI settings element not found');\n      }\n      const openaiSettings = {\n        ...baseSettings,\n        openaiApiKey: elements.openaiApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered openai settings', {\n        apiKey: openaiSettings.openaiApiKey ? '***REDACTED***' : '',\n      });\n      return openaiSettings;\n\n    case Provider.GEMINI:\n      if (!elements.geminiApiKey) {\n        throw new Error('Gemini settings element not found');\n      }\n      const geminiSettings = {\n        ...baseSettings,\n        geminiApiKey: elements.geminiApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered gemini settings', {\n        apiKey: geminiSettings.geminiApiKey ? '***REDACTED***' : '',\n      });\n      return geminiSettings;\n\n    case Provider.CLAUDE:\n      if (!elements.claudeApiKey) {\n        throw new Error('Claude settings element not found');\n      }\n      const claudeSettings = {\n        ...baseSettings,\n        claudeApiKey: elements.claudeApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered claude settings', {\n        apiKey: claudeSettings.claudeApiKey ? '***REDACTED***' : '',\n      });\n      return claudeSettings;\n\n    case Provider.MISTRAL:\n      if (!elements.mistralApiKey) {\n        throw new Error('Mistral settings element not found');\n      }\n      const mistralSettings = {\n        ...baseSettings,\n        mistralApiKey: elements.mistralApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered mistral settings', {\n        apiKey: mistralSettings.mistralApiKey ? '***REDACTED***' : '',\n      });\n      return mistralSettings;\n\n    case Provider.DEEPSEEK:\n      if (!elements.deepseekApiKey) {\n        throw new Error('DeepSeek settings element not found');\n      }\n      const deepseekSettings = {\n        ...baseSettings,\n        deepseekApiKey: elements.deepseekApiKey.value.trim(),\n      };\n      logger.info('[DEBUG-options] Gathered deepseek settings', {\n        apiKey: deepseekSettings.deepseekApiKey ? '***REDACTED***' : '',\n      });\n      return deepseekSettings;\n\n    case Provider.ZAI_PAAS:\n      if (!elements.zaiPaasApiKey || !elements.zaiPaasModel) {\n        throw new Error('Zai PaaS settings element not found');\n      }\n      const zaiPaasSettings = {\n        ...baseSettings,\n        zaiPaasApiKey: elements.zaiPaasApiKey.value.trim(),\n        zaiPaasModel: elements.zaiPaasModel.value,\n      };\n      logger.info('[DEBUG-options] Gathered zai-paas settings', {\n        apiKey: zaiPaasSettings.zaiPaasApiKey ? '***REDACTED***' : '',\n        model: zaiPaasSettings.zaiPaasModel,\n      });\n      return zaiPaasSettings;\n\n    case Provider.ZAI_CODING:\n      if (!elements.zaiCodingApiKey || !elements.zaiCodingModel) {\n        throw new Error('Zai Coding settings element not found');\n      }\n      const zaiCodingSettings = {\n        ...baseSettings,\n        zaiCodingApiKey: elements.zaiCodingApiKey.value.trim(),\n        zaiCodingModel: elements.zaiCodingModel.value,\n      };\n      logger.info('[DEBUG-options] Gathered zai-coding settings', {\n        apiKey: zaiCodingSettings.zaiCodingApiKey ? '***REDACTED***' : '',\n        model: zaiCodingSettings.zaiCodingModel,\n      });\n      return zaiCodingSettings;\n\n    default:\n      throw new Error(`Unknown provider: ${provider}`);\n  }\n}\n\n/**\n * Handles general settings form submission\n */\nasync function handleGeneralSettingsSubmit(\n  elements: GeneralSettingsElements\n): Promise<SettingsSaveResult> {\n  const provider = elements.providerSelect.value;\n\n  logger.info('[DEBUG-options] handleGeneralSettingsSubmit() called', { provider });\n\n  if (!isValidProvider(provider)) {\n    logger.warn('[DEBUG-options] Invalid provider selected', { provider });\n    return {\n      success: false,\n      message: 'Invalid provider selected',\n    };\n  }\n\n  const settingsToSave = gatherProviderSettings(provider, elements);\n  logger.info('[DEBUG-options] Gathered settings', { settingsToSave });\n\n  let permissionGranted = true;\n\n  try {\n    const permissionOrigin = getPermissionOrigin(provider as Provider, settingsToSave);\n    const hasSettings = Object.values(settingsToSave).some((val) => val && val !== '');\n\n    if (hasSettings) {\n      try {\n        logger.info('[DEBUG-options] Requesting permission for origin', {\n          origin: permissionOrigin,\n        });\n        permissionGranted = await messenger.permissions.request({\n          origins: [permissionOrigin],\n        });\n        logger.info('[DEBUG-options] Permission result', {\n          granted: permissionGranted,\n          origin: permissionOrigin,\n        });\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        logger.error('[DEBUG-options] Error requesting permission', { error: errorMessage });\n        return {\n          success: false,\n          message: 'Error with permission request',\n        };\n      }\n    } else {\n      logger.info('[DEBUG-options] No settings to save, skipping permission request');\n    }\n\n    if (permissionGranted) {\n      const data = (await messenger.storage.local.get({\n        appConfig: {\n          enableNotifications: DEFAULTS.enableNotifications,\n          enableLogging: DEFAULTS.enableLogging,\n          modelConcurrencyLimits: DEFAULTS.modelConcurrencyLimits,\n        },\n        providerSettings: {},\n      })) as AppSettingsStorage;\n\n      const providerSettings = data.providerSettings || {};\n      const existingAppConfig = data.appConfig || {};\n\n      const convertedSettings = convertToProviderSettings(settingsToSave);\n      providerSettings[provider] = convertedSettings;\n\n      existingAppConfig.defaultProvider = provider as Provider;\n\n      // Save min confidence threshold\n      if (elements.minConfidenceThreshold && elements.minConfidenceThreshold.value !== '') {\n        const threshold = parseInt(elements.minConfidenceThreshold.value, 10);\n        if (!isNaN(threshold) && threshold >= 0 && threshold <= 100) {\n          existingAppConfig.minConfidenceThreshold = threshold;\n          logger.info('[DEBUG-options] Saving minConfidenceThreshold', {\n            threshold,\n          });\n        } else {\n          logger.warn('[DEBUG-options] Invalid minConfidenceThreshold, using default', {\n            threshold,\n          });\n          existingAppConfig.minConfidenceThreshold = DEFAULTS.minConfidenceThreshold;\n        }\n      } else {\n        existingAppConfig.minConfidenceThreshold = DEFAULTS.minConfidenceThreshold;\n      }\n\n      logger.info('[DEBUG-options] Saving to storage', {\n        appConfig: existingAppConfig,\n        providerSettings,\n      });\n\n      await messenger.storage.local.set({\n        appConfig: existingAppConfig,\n        providerSettings,\n      });\n\n      logger.info('[DEBUG-options] Settings saved successfully');\n\n      return {\n        success: true,\n        message: 'Settings saved!',\n      };\n    } else {\n      logger.warn('[DEBUG-options] Permission denied, settings not saved');\n      return {\n        success: false,\n        message: 'Permission denied. Settings not saved.',\n      };\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('[DEBUG-options] Save failed', { error: errorMessage });\n    return {\n      success: false,\n      message: 'Error saving settings',\n    };\n  }\n}\n\nfunction convertToProviderSettings(settings: PartialProviderConfig) {\n  logger.info('[DEBUG-options] convertToProviderSettings() called', {\n    provider: settings.provider,\n    input: settings,\n  });\n\n  let result: { apiKey: string; model: string; apiUrl?: string };\n\n  switch (settings.provider) {\n    case Provider.OLLAMA:\n      result = {\n        apiKey: '',\n        model: settings.ollamaModel || '',\n        apiUrl: settings.ollamaApiUrl || '',\n      };\n      logger.info('[DEBUG-options] Converted ollama settings', { result });\n      return result;\n\n    case Provider.OPENAI:\n      result = {\n        apiKey: settings.openaiApiKey || '',\n        model: 'gpt-4o-mini',\n      };\n      logger.info('[DEBUG-options] Converted openai settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.GEMINI:\n      result = {\n        apiKey: settings.geminiApiKey || '',\n        model: 'gemini-2.0-flash-exp',\n      };\n      logger.info('[DEBUG-options] Converted gemini settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.CLAUDE:\n      result = {\n        apiKey: settings.claudeApiKey || '',\n        model: 'claude-3-5-sonnet-20241022',\n      };\n      logger.info('[DEBUG-options] Converted claude settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.MISTRAL:\n      result = {\n        apiKey: settings.mistralApiKey || '',\n        model: 'mistral-large-latest',\n      };\n      logger.info('[DEBUG-options] Converted mistral settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.DEEPSEEK:\n      result = {\n        apiKey: settings.deepseekApiKey || '',\n        model: 'deepseek-chat',\n      };\n      logger.info('[DEBUG-options] Converted deepseek settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n      });\n      return result;\n\n    case Provider.ZAI_PAAS:\n      result = {\n        apiKey: settings.zaiPaasApiKey || '',\n        model: settings.zaiPaasModel || 'glm-4.5',\n        apiUrl: 'https://api.z.ai/api/paas/v4/chat/completions',\n      };\n      logger.info('[DEBUG-options] Converted zai-paas settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n        apiUrl: result.apiUrl,\n      });\n      return result;\n\n    case Provider.ZAI_CODING:\n      result = {\n        apiKey: settings.zaiCodingApiKey || '',\n        model: settings.zaiCodingModel || 'glm-4.7',\n        apiUrl: 'https://api.z.ai/api/coding/paas/v4/chat/completions',\n      };\n      logger.info('[DEBUG-options] Converted zai-coding settings', {\n        apiKey: result.apiKey ? '***REDACTED***' : '',\n        model: result.model,\n        apiUrl: result.apiUrl,\n      });\n      return result;\n\n    default:\n      throw new Error(`Unknown provider: ${settings.provider}`);\n  }\n}\n\n/**\n * Sets a status message and clears it after a delay\n */\nfunction setStatusMessage(element: HTMLSpanElement, message: string, delay: number = 3000): void {\n  element.textContent = message;\n  setTimeout(() => {\n    element.textContent = '';\n  }, delay);\n}\n\n/**\n * Populates the z.ai model dropdown with available models from the API\n */\nasync function populateZaiModels(provider: 'zaiPaas' | 'zaiCoding'): Promise<void> {\n  const zaiKeyInput = document.getElementById(`${provider}ApiKey`) as HTMLInputElement;\n  const zaiModelSelect = document.getElementById(`${provider}Model`) as HTMLSelectElement;\n\n  if (!zaiKeyInput?.value) {\n    return; // Kein API-Key, nichts zu tun\n  }\n\n  try {\n    logger.info(`[DEBUG-options] Fetching ${provider} models`);\n    const models = await fetchZaiModels(zaiKeyInput.value);\n\n    // Clear existing options\n    zaiModelSelect.innerHTML = '';\n\n    // Add new options\n    models.forEach((model) => {\n      const option = document.createElement('option');\n      option.value = model;\n      option.textContent = model;\n      zaiModelSelect.appendChild(option);\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error(`Failed to populate ${provider} models`, { error: errorMessage });\n  }\n}\n\n// ============================================================================\n// Tag Management Functions\n// ============================================================================\n\n/**\n * Renders the tag list to the DOM\n */\nfunction renderTagList(\n  container: HTMLDivElement,\n  customTags: CustomTags,\n  globalThreshold: number = DEFAULTS.minConfidenceThreshold\n): void {\n  container.innerHTML = '';\n\n  customTags.forEach((tag, index) => {\n    const item = document.createElement('div');\n    item.className = 'tag-item';\n\n    // Determine threshold display\n    const hasCustomThreshold = tag.minConfidenceThreshold !== undefined;\n    const thresholdDisplay = hasCustomThreshold\n      ? `${tag.minConfidenceThreshold}%`\n      : `Global (${globalThreshold}%)`;\n    const thresholdClass = hasCustomThreshold ? 'tag-threshold-custom' : 'tag-threshold-global';\n\n    item.innerHTML = `\n      <div class=\"tag-color-preview\" style=\"background-color: ${escapeHtml(tag.color)};\"></div>\n      <div class=\"tag-details\">\n        <div class=\"tag-name\">${escapeHtml(tag.name)}</div>\n        <div class=\"tag-key\">Key: ${escapeHtml(tag.key)}</div>\n        <div class=\"tag-prompt\">Prompt: ${escapeHtml(tag.prompt || '')}</div>\n        <div class=\"tag-threshold ${thresholdClass}\">Threshold: ${escapeHtml(thresholdDisplay)}</div>\n      </div>\n      <div class=\"tag-actions\">\n        <button class=\"edit-tag-btn\" data-index=\"${index}\">Edit</button>\n        <button class=\"delete-tag-btn\" data-index=\"${index}\">Delete</button>\n      </div>\n    `;\n    container.appendChild(item);\n  });\n}\n\n/**\n * Cleans up resources when the page is unloaded\n */\nfunction cleanupResources(): void {\n  // No resources to clean up\n}\n\n// ============================================================================\n// ERROR DISPLAY FUNCTIONALITY\n// ============================================================================\n\n/**\n * Error display element in the options page\n */\nlet errorDisplayElement: HTMLDivElement | null = null;\n\n/**\n * Creates the error display overlay if it doesn't exist\n */\nfunction ensureErrorDisplay(): HTMLDivElement {\n  if (errorDisplayElement) {\n    return errorDisplayElement;\n  }\n\n  const errorOverlay = document.createElement('div');\n  errorOverlay.id = 'error-display-overlay';\n  errorOverlay.className = 'error-display-overlay';\n  errorOverlay.innerHTML = `\n    <div class=\"error-display-content\">\n      <div class=\"error-display-header\">\n        <span class=\"error-display-icon\"></span>\n        <h3 id=\"error-display-title\"></h3>\n        <button class=\"error-display-close\">&times;</button>\n      </div>\n      <p id=\"error-display-message\"></p>\n      <div id=\"error-display-details\" style=\"margin-top: 10px; font-size: 12px; color: #666;\"></div>\n    </div>\n  `;\n\n  const closeButton = errorOverlay.querySelector('.error-display-close') as HTMLButtonElement;\n  if (closeButton) {\n    closeButton.addEventListener('click', () => {\n      if (errorDisplayElement) {\n        errorDisplayElement.remove();\n        errorDisplayElement = null;\n      }\n    });\n  }\n\n  document.body.appendChild(errorOverlay);\n  errorDisplayElement = errorOverlay;\n  return errorOverlay;\n}\n\n/**\n * Shows an error message to the user\n * @param error - Error information to display\n */\nfunction showError(error: ErrorDisplay): void {\n  const overlay = ensureErrorDisplay();\n  const title = overlay.querySelector('#error-display-title') as HTMLElement;\n  const message = overlay.querySelector('#error-display-message') as HTMLElement;\n  const details = overlay.querySelector('#error-display-details') as HTMLElement;\n  const icon = overlay.querySelector('.error-display-icon') as HTMLElement;\n\n  // Set icon based on severity\n  switch (error.severity) {\n    case ErrorSeverity.CRITICAL:\n      icon.textContent = '\ud83d\udea8';\n      icon.style.fontSize = '24px';\n      break;\n    case ErrorSeverity.WARNING:\n      icon.textContent = '\u26a0\ufe0f';\n      icon.style.fontSize = '24px';\n      break;\n    case ErrorSeverity.INFO:\n      icon.textContent = '\u2139\ufe0f';\n      icon.style.fontSize = '24px';\n      break;\n  }\n\n  // Set title based on type and severity\n  const typeTitle = error.type ? error.type.charAt(0).toUpperCase() + error.type.slice(1) : 'Error';\n  title.textContent = `${typeTitle} (${error.severity})`;\n\n  // Set message\n  message.textContent = error.message;\n\n  // Set details if available\n  if (error.context && Object.keys(error.context).length > 0) {\n    const detailsText = Object.entries(error.context)\n      .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)\n      .join('\\n');\n    details.textContent = detailsText;\n    details.style.display = 'block';\n  } else {\n    details.style.display = 'none';\n  }\n\n  // Style based on severity\n  overlay.style.display = 'flex';\n  const content = overlay.querySelector('.error-display-content') as HTMLDivElement;\n\n  switch (error.severity) {\n    case ErrorSeverity.CRITICAL:\n      content.style.borderLeft = '4px solid #d32f2f';\n      content.style.backgroundColor = '#ffebee';\n      break;\n    case ErrorSeverity.WARNING:\n      content.style.borderLeft = '4px solid #ff9800';\n      content.style.backgroundColor = '#fff3e0';\n      break;\n    case ErrorSeverity.INFO:\n      content.style.borderLeft = '4px solid #2196f3';\n      content.style.backgroundColor = '#e3f2fd';\n      break;\n  }\n\n  // Auto-hide info and warning errors after 5 seconds\n  if (error.severity !== ErrorSeverity.CRITICAL) {\n    setTimeout(() => {\n      if (overlay && overlay.parentNode) {\n        overlay.remove();\n        errorDisplayElement = null;\n      }\n    }, 5000);\n  }\n\n  logger.info('Error displayed to user', {\n    severity: error.severity,\n    type: error.type,\n    message: error.message,\n  });\n}\n\n/**\n * Handles error messages from background script\n */\nfunction handleBackgroundError(message: ShowErrorRuntimeMessage): void {\n  showError(message.error);\n}\n\n// ============================================================================\n// RUNTIME MESSAGE HANDLER\n// ============================================================================\n\n/**\n * Enhanced sendMessage function that handles error messages\n */\nasync function sendMessage<T = unknown>(message: BatchRuntimeMessage): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    // Type guard to ensure browser.runtime exists\n    if (typeof window !== 'undefined' && 'browser' in window && window.browser) {\n      window.browser.runtime.sendMessage<T>(message, (response: T) => {\n        const lastError = window.browser.runtime?.lastError;\n        if (lastError) {\n          reject(new Error(lastError.message));\n        } else {\n          resolve(response);\n        }\n      });\n    } else {\n      reject(new Error('Browser runtime not available'));\n    }\n  });\n}\n\n/**\n * Runtime message listener for error display and other messages\n */\nfunction setupRuntimeMessageListener(): void {\n  // Type guard to ensure browser.runtime exists\n  if (typeof window !== 'undefined' && 'browser' in window && window.browser) {\n    window.browser.runtime.onMessage.addListener(\n      (message: unknown, sender: unknown, sendResponse: (response?: unknown) => void) => {\n        // Type guard for BatchRuntimeMessage\n        if (typeof message === 'object' && message !== null && 'action' in message) {\n          const typedMessage = message as BatchRuntimeMessage;\n\n          // Handle error display messages\n          if (typedMessage.action === 'showError') {\n            handleBackgroundError(typedMessage as ShowErrorRuntimeMessage);\n            sendResponse({ success: true });\n            return false;\n          }\n        }\n\n        return false; // Let other handlers process the message\n      }\n    );\n  }\n}\n\n/**\n * Handles kill queue button click\n */\nasync function handleKillQueueClick(killQueueBtn: HTMLButtonElement): Promise<void> {\n  try {\n    killQueueBtn.disabled = true;\n\n    const response = await sendMessage<{ success: boolean; message: string }>({\n      action: 'clearQueue',\n      cancelRunning: true,\n    });\n\n    if (response.success) {\n      setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, response.message);\n    } else {\n      setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, response.message);\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to clear queue', { error: errorMessage });\n    setStatusMessage(killQueueBtn.nextElementSibling as HTMLSpanElement, `Fehler: ${errorMessage}`);\n  } finally {\n    killQueueBtn.disabled = false;\n  }\n}\n\n/**\n * Handles clear cache button click\n */\nasync function handleClearCacheClick(elements: CacheManagementElements): Promise<void> {\n  try {\n    elements.clearCacheBtn.disabled = true;\n    elements.cacheStatusMessage.textContent = 'Cache wird geleert...';\n\n    const response = await sendMessage<{ success: boolean; message: string }>({\n      action: 'clearCache',\n    });\n\n    if (response.success) {\n      elements.cacheStatusMessage.textContent = response.message;\n    } else {\n      elements.cacheStatusMessage.textContent = response.message;\n    }\n\n    // Refresh cache stats after clearing\n    await updateCacheStats(elements);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to clear cache', { error: errorMessage });\n    elements.cacheStatusMessage.textContent = `Fehler beim Leeren des Cache: ${errorMessage}`;\n  } finally {\n    elements.clearCacheBtn.disabled = false;\n  }\n}\n\n/**\n * Updates cache statistics display\n */\nasync function updateCacheStats(elements: CacheManagementElements): Promise<void> {\n  try {\n    const response = await sendMessage<{\n      success: boolean;\n      totalEntries?: number;\n      hitRate?: number;\n      message?: string;\n    }>({\n      action: 'getCacheStats',\n    });\n\n    if (response.success && response.totalEntries !== undefined && response.hitRate !== undefined) {\n      elements.cacheStats.textContent = `Cache-Eintr\u00e4ge: ${response.totalEntries} | Hit-Rate: ${response.hitRate}%`;\n    } else {\n      elements.cacheStats.textContent = response.message || 'Cache-Statistiken nicht verf\u00fcgbar';\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to get cache stats', { error: errorMessage });\n    elements.cacheStats.textContent = 'Fehler beim Laden der Statistiken';\n  }\n}\n\n/**\n * Checks if provider is configured\n */\nasync function checkProviderConfigured(): Promise<boolean> {\n  try {\n    const settings = await messenger.storage.local.get(DEFAULTS);\n    const provider = settings.provider;\n\n    if (!provider) {\n      return false;\n    }\n\n    // Check provider-specific settings\n    switch (provider) {\n      case 'ollama':\n        return !!(settings.ollamaApiUrl && settings.ollamaModel);\n      case 'openai':\n        return !!settings.openaiApiKey;\n      case 'gemini':\n        return !!settings.geminiApiKey;\n      case 'claude':\n        return !!settings.claudeApiKey;\n      case 'mistral':\n        return !!settings.mistralApiKey;\n      case 'deepseek':\n        return !!settings.deepseekApiKey;\n      case 'zai-paas':\n        return !!settings.zaiPaasApiKey;\n      case 'zai-coding':\n        return !!settings.zaiCodingApiKey;\n      default:\n        return false;\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to check provider configuration', { error: errorMessage });\n    return false;\n  }\n}\n\n/**\n * Escapes HTML special characters to prevent XSS\n */\nfunction escapeHtml(text: string): string {\n  const div = document.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n/**\n * Loads custom tags from storage\n */\nasync function loadCustomTags(): Promise<CustomTags> {\n  try {\n    const { customTags } = (await messenger.storage.local.get({\n      customTags: DEFAULTS.customTags,\n    })) as CustomTagsStorage;\n    return customTags || DEFAULTS.customTags;\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error loading custom tags', { error: errorMessage });\n    return DEFAULTS.customTags;\n  }\n}\n\n/**\n * Saves custom tags to storage\n */\nasync function saveCustomTags(customTags: CustomTags): Promise<void> {\n  try {\n    await messenger.storage.local.set({ customTags });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Error saving custom tags', { error: errorMessage });\n    throw error;\n  }\n}\n\n/**\n * Opens the tag modal for creating or editing\n */\nfunction openModal(elements: TagManagementElements, context: TagEditContext): void {\n  elements.tagForm.reset();\n  elements.tagIndex.value = context.index.toString();\n\n  if (context.tag) {\n    elements.modalTitle.textContent = 'Edit Tag';\n    elements.tagName.value = context.tag.name;\n    elements.tagKey.value = context.tag.key;\n    elements.tagColor.value = context.tag.color;\n    elements.tagPrompt.value = context.tag.prompt || '';\n    // Set threshold value if it exists\n    if (context.tag.minConfidenceThreshold !== undefined) {\n      elements.tagThreshold.value = context.tag.minConfidenceThreshold.toString();\n    }\n  } else {\n    elements.modalTitle.textContent = 'Add New Tag';\n  }\n\n  elements.modal.style.display = 'flex';\n}\n\n/**\n * Closes the tag modal\n */\nfunction closeModal(elements: TagManagementElements): void {\n  elements.modal.style.display = 'none';\n}\n\n/**\n * Handles tag list button clicks (edit/delete)\n */\nfunction handleTagListClick(\n  elements: TagManagementElements,\n  customTags: CustomTags\n): TagListClickHandler {\n  return (event: MouseEvent): void => {\n    const target = event.target;\n\n    if (isButtonWithIndex(target)) {\n      const index = parseInt(target.dataset.index, 10);\n\n      if (isNaN(index) || index < 0 || index >= customTags.length) {\n        logger.warn('Invalid tag index', { index: target.dataset.index });\n        return;\n      }\n\n      if (target.classList.contains('edit-tag-btn')) {\n        openModal(elements, { tag: customTags[index], index });\n      }\n\n      if (target.classList.contains('delete-tag-btn')) {\n        const tag = customTags[index];\n        if (confirm(`Are you sure you want to delete the \"${tag.name}\" tag?`)) {\n          (customTags as Tag[]).splice(index, 1);\n          saveCustomTags(customTags)\n            .then(async () => {\n              // Load global threshold for rendering\n              const data = await messenger.storage.local.get({\n                appConfig: { minConfidenceThreshold: DEFAULTS.minConfidenceThreshold },\n              });\n              const appConfig = (data as AppSettingsStorage).appConfig || {};\n              const globalThreshold =\n                appConfig.minConfidenceThreshold ?? DEFAULTS.minConfidenceThreshold;\n\n              renderTagList(elements.tagListContainer, customTags, globalThreshold);\n            })\n            .catch((error) => {\n              logger.error('Failed to delete tag', { error });\n            });\n        }\n      }\n    }\n  };\n}\n\n/**\n * Handles tag form submission\n */\nasync function handleTagFormSubmit(\n  elements: TagManagementElements,\n  customTags: CustomTags\n): Promise<void> {\n  const index = parseInt(elements.tagIndex.value, 10);\n  const name = elements.tagName.value.trim();\n  const key = elements.tagKey.value.trim();\n  const color = elements.tagColor.value;\n  const prompt = elements.tagPrompt.value.trim();\n  const thresholdValue = elements.tagThreshold.value.trim();\n\n  // Validate inputs\n  if (!name) {\n    alert('Fehler: Tag-Name ist erforderlich.');\n    return;\n  }\n\n  if (!key) {\n    alert('Fehler: Tag-Schl\u00fcssel ist erforderlich.');\n    return;\n  }\n\n  if (!isValidTagKey(key)) {\n    alert('Fehler: Tag-Schl\u00fcssel darf nur Kleinbuchstaben, Zahlen und Unterstriche enthalten.');\n    return;\n  }\n\n  if (!isValidHexColor(color)) {\n    alert('Fehler: Tag-Farbe muss ein g\u00fcltiger Hex-Farbwert sein (z.B. #FF5722).');\n    return;\n  }\n\n  if (!prompt) {\n    alert('Fehler: Tag-Prompt ist erforderlich.');\n    return;\n  }\n\n  // Validate threshold if provided\n  let minConfidenceThreshold: number | undefined = undefined;\n  if (thresholdValue) {\n    const threshold = parseInt(thresholdValue, 10);\n    if (isNaN(threshold) || threshold < 0 || threshold > 100) {\n      alert('Fehler: Konfidenz-Schwellenwert muss eine Zahl zwischen 0 und 100 sein.');\n      return;\n    }\n    minConfidenceThreshold = threshold;\n  }\n\n  // Check for duplicate keys (excluding current index for edits)\n  const isDuplicate = customTags.some((tag, i) => tag.key === key && i !== index);\n  if (isDuplicate) {\n    alert('Fehler: Tag-Schl\u00fcssel muss eindeutig sein.');\n    return;\n  }\n\n  const newTag: Tag = { name, key, color, prompt, minConfidenceThreshold };\n\n  if (index === -1) {\n    // Add new tag\n    (customTags as Tag[]).push(newTag);\n  } else {\n    // Update existing tag\n    (customTags as Tag[])[index] = newTag;\n  }\n\n  try {\n    await saveCustomTags(customTags);\n\n    // Load global threshold for rendering\n    const data = await messenger.storage.local.get({\n      appConfig: { minConfidenceThreshold: DEFAULTS.minConfidenceThreshold },\n    });\n    const appConfig = (data as AppSettingsStorage).appConfig || {};\n    const globalThreshold = appConfig.minConfidenceThreshold ?? DEFAULTS.minConfidenceThreshold;\n\n    renderTagList(elements.tagListContainer, customTags, globalThreshold);\n    closeModal(elements);\n  } catch (error) {\n    alert('Fehler: Tag konnte nicht gespeichert werden. Bitte versuchen Sie es erneut.');\n  }\n}\n\n// ============================================================================\n// Initialization\n// ============================================================================\n\n/**\n * Initializes the options page\n */\nfunction initializeOptionsPage(): void {\n  try {\n    // Setup error display listener first\n    setupRuntimeMessageListener();\n\n    const elements = getAllDOMElements();\n\n    // Track custom tags state\n    let currentCustomTags: CustomTags = [];\n\n    // Initialize tabs\n    initializeTabs(elements.tabs, elements.tabContents);\n\n    // Initialize general settings\n    loadGeneralSettings(elements).catch((error) => {\n      logger.error('Failed to load general settings on init', { error });\n    });\n\n    // General settings form handler\n    elements.generalForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const result = await handleGeneralSettingsSubmit(elements);\n\n      setStatusMessage(elements.generalStatusMessage, result.message);\n      if (result.success) {\n        setStatusMessage(elements.statusMessage, 'General settings saved!');\n      } else {\n        setStatusMessage(elements.statusMessage, result.message);\n      }\n    });\n\n    // Provider change handler\n    elements.providerSelect.addEventListener('change', (e) => {\n      const target = e.target as HTMLSelectElement;\n      showRelevantSettings(target.value);\n    });\n\n    // Confidence threshold slider synchronization\n    if (elements.minConfidenceThresholdSlider && elements.minConfidenceThreshold && elements.confidenceValue) {\n      elements.minConfidenceThresholdSlider.addEventListener('input', (e) => {\n        const target = e.target as HTMLInputElement;\n        elements.minConfidenceThreshold!.value = target.value;\n        elements.confidenceValue!.textContent = target.value;\n      });\n\n      elements.minConfidenceThreshold.addEventListener('input', (e) => {\n        const target = e.target as HTMLInputElement;\n        let value = parseInt(target.value, 10);\n\n        // Clamp value between 0 and 100\n        if (isNaN(value)) {\n          value = 0;\n        } else if (value < 0) {\n          value = 0;\n        } else if (value > 100) {\n          value = 100;\n        }\n\n        elements.minConfidenceThresholdSlider!.value = value.toString();\n        elements.confidenceValue!.textContent = value.toString();\n      });\n    }\n\n    // z.ai API key change handler - fetch models when key changes\n    if (elements.zaiPaasApiKey) {\n      const debouncedPopulateZaiPaasModels = debounce(() => populateZaiModels('zaiPaas'), 500);\n      elements.zaiPaasApiKey.addEventListener('input', () => {\n        if (elements.zaiPaasApiKey?.value) {\n          debouncedPopulateZaiPaasModels();\n        }\n      });\n    }\n    if (elements.zaiCodingApiKey) {\n      const debouncedPopulateZaiCodingModels = debounce(() => populateZaiModels('zaiCoding'), 500);\n      elements.zaiCodingApiKey.addEventListener('input', () => {\n        if (elements.zaiCodingApiKey?.value) {\n          debouncedPopulateZaiCodingModels();\n        }\n      });\n    }\n\n    // Initialize cache management\n    updateCacheStats(elements).catch((error) => {\n      logger.error('Failed to initialize cache stats', { error });\n    });\n\n    // Cache management event listeners\n    elements.clearCacheBtn.addEventListener('click', () => {\n      handleClearCacheClick(elements);\n    });\n\n    // Kill queue button event listener\n    const killQueueBtn = document.getElementById('kill-queue-btn');\n    if (killQueueBtn) {\n      killQueueBtn.addEventListener('click', () => {\n        handleKillQueueClick(killQueueBtn as HTMLButtonElement).catch((error) => {\n          logger.error('Failed to handle kill queue click', { error });\n        });\n      });\n    }\n\n    // Load global threshold and custom tags\n    Promise.all([\n      loadCustomTags(),\n      messenger.storage.local.get({\n        appConfig: { minConfidenceThreshold: DEFAULTS.minConfidenceThreshold },\n      }),\n    ])\n      .then(([tags, data]) => {\n        const appConfig = (data as AppSettingsStorage).appConfig || {};\n        const globalThreshold =\n          appConfig.minConfidenceThreshold ?? DEFAULTS.minConfidenceThreshold;\n\n        currentCustomTags = tags;\n        renderTagList(elements.tagListContainer, currentCustomTags, globalThreshold);\n      })\n      .catch((error) => {\n        logger.error('Failed to load custom tags on init', { error });\n      });\n\n    // Add new tag button handler\n    elements.addNewTagBtn.addEventListener('click', () => {\n      openModal(elements, { tag: null, index: -1 });\n    });\n\n    // Close modal button handler\n    elements.closeModalBtn.addEventListener('click', () => {\n      closeModal(elements);\n    });\n\n    // Close modal on outside click\n    window.addEventListener('click', (e) => {\n      if (e.target === elements.modal) {\n        closeModal(elements);\n      }\n    });\n\n    // Tag list click handler\n    elements.tagListContainer.addEventListener(\n      'click',\n      handleTagListClick(elements, currentCustomTags)\n    );\n\n    // Tag form submit handler\n    elements.tagForm.addEventListener('submit', (e) => {\n      e.preventDefault();\n      handleTagFormSubmit(elements, currentCustomTags).catch((error) => {\n        logger.error('Failed to handle tag form submit', { error });\n      });\n    });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    logger.error('Failed to initialize options page', { error: errorMessage });\n    document.body.innerHTML = `<p style=\"color: red;\">Error initializing options page: ${escapeHtml(errorMessage)}</p>`;\n  }\n}\n\n// Start initialization when DOM is ready\ndocument.addEventListener('DOMContentLoaded', initializeOptionsPage);\n\n// Clean up resources when page unloads\nwindow.addEventListener('beforeunload', cleanupResources);\n",
        "last_modified": "2026-01-06T15:39:51.888360"
      },
      "task_intent": {
        "title": "010-confidence-score-display-and-threshold-configurati",
        "description": "# Confidence Score Display and Threshold Configuration\n\nDisplay confidence scores for AI classifications and allow users to configure minimum confidence thresholds. Tags are only applied when confidence exceeds the threshold.\n\n## Rationale\nAddresses market gap-5: lack of transparency in AI decisions. Gmail and SaneBox don't explain why emails are categorized (pain-3-3). Users need to understand AI certainty and control when tags are applied to avoid incorrect classifications.\n\n## User Stories\n- As a cautious user, I want to see confidence scores so that I can understand how certain the AI is about its classifications\n- As a power user, I want to set minimum confidence thresholds so that only high-confidence tags are applied automatically\n\n## Acceptance Criteria\n- [ ] Confidence score (0-100%) is displayed alongside each tag suggestion\n- [ ] Global confidence threshold setting in options (default: 70%)\n- [ ] Per-tag confidence threshold override option\n- [ ] Low-confidence classifications are flagged for manual review\n- [ ] Confidence scores are stored with analysis history\n",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.095618",
  "last_updated": "2026-01-06T07:24:51.163714"
}