{
  "file_path": "src/infrastructure/providers/BaseProvider.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "import { buildPrompt, StructuredEmailData } from '../../../core/analysis';\nimport type { CustomTags } from '../../../core/config';\nimport {\n  retryWithBackoff,\n  validateLLMResponse,\n  logger,\n  maskApiKey,\n  TagResponse as UtilsTagResponse,\n} from './ProviderUtils';\n\nexport type TagResponse = UtilsTagResponse;\n\n// ============================================================================\n// TYPE DEFINITIONS\n// ============================================================================\n\n/**\n * Base settings interface for all providers\n * Specific providers can extend this with their own properties\n */\nexport interface BaseProviderSettings {\n  apiKey?: string;\n  apiUrl?: string;\n  model?: string;\n}\n\n/**\n * Generic request body type for provider API calls\n * Specific providers can have more structured types\n */\nexport type RequestBody = Record<string, unknown>;\n\n/**\n * Generic provider response type\n * Specific providers can have more structured types\n */\nexport type ProviderResponse = unknown;\n\n/**\n * Input parameters for analyze method\n */\nexport interface AnalyzeInput {\n  settings: BaseProviderSettings;\n  structuredData: StructuredEmailData;\n  customTags: CustomTags;\n  signal?: AbortSignal;\n}\n\n/**\n * Output type for analyze method\n * Note: analyze() now throws errors instead of returning null\n */\nexport type AnalyzeOutput = TagResponse;\n\n/**\n * HTTP headers for API requests\n */\nexport type HttpHeaders = Record<string, string>;\n\n/**\n * Fetch options for API requests\n */\nexport interface FetchOptions extends Omit<RequestInit, 'headers'> {\n  headers?: HttpHeaders;\n}\n\n// ============================================================================\n// DEFAULT CONFIGURATION\n// ============================================================================\n\nconst DEFAULT_TIMEOUT = 300000 as const;\nconst DEFAULT_RETRY_CONFIG = {\n  maxRetries: 3,\n  baseDelay: 1000,\n  factor: 2,\n  jitter: 0.5,\n} as const;\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Fetches a URL with timeout support using AbortController\n * @param url - The URL to fetch\n * @param options - Fetch options\n * @param timeout - Timeout in milliseconds\n * @returns Promise resolving to the fetch response\n * @throws {Error} If the fetch fails or times out\n */\nasync function fetchWithTimeout(\n  url: string,\n  options: FetchOptions = {},\n  timeout: number = DEFAULT_TIMEOUT,\n  externalSignal?: AbortSignal\n): Promise<Response> {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n  if (externalSignal) {\n    externalSignal.addEventListener('abort', () => {\n      clearTimeout(timeoutId);\n      controller.abort();\n    });\n  }\n\n  try {\n    const response = await fetch(url, {\n      ...options,\n      signal: controller.signal,\n    });\n    clearTimeout(timeoutId);\n    return response;\n  } catch (error) {\n    clearTimeout(timeoutId);\n    throw error;\n  }\n}\n\n/**\n * Checks if an HTTP response is OK (status 200-299)\n * @param response - The fetch response\n * @returns True if the response is OK\n */\nfunction isOkResponse(response: Response): response is Response & { ok: true } {\n  return response.ok;\n}\n\n// ============================================================================\n// ABSTRACT BASE PROVIDER CLASS\n// ============================================================================\n\n/**\n * Abstract base class for all AI providers\n * Implements common functionality for email analysis with retry logic,\n * error handling, and response validation\n */\nexport abstract class BaseProvider {\n  protected readonly timeout: number;\n  protected readonly retryConfig: Readonly<typeof DEFAULT_RETRY_CONFIG>;\n\n  constructor(timeout: number = DEFAULT_TIMEOUT) {\n    this.timeout = timeout;\n    this.retryConfig = DEFAULT_RETRY_CONFIG;\n  }\n\n  // ========================================================================\n  // ABSTRACT METHODS (must be implemented by subclasses)\n  // ========================================================================\n\n  /**\n   * Returns the API URL for the provider\n   */\n  protected abstract getApiUrl(): string;\n\n  /**\n   * Builds the request body for the API call\n   * @param settings - Provider settings\n   * @param prompt - The analysis prompt\n   * @param structuredData - Email data\n   * @param customTags - Custom tag configurations\n   * @returns Request body for the API call\n   */\n  protected abstract buildRequestBody(\n    settings: BaseProviderSettings,\n    prompt: string,\n    structuredData: StructuredEmailData,\n    customTags: CustomTags\n  ): RequestBody;\n\n  /**\n   * Parses the provider response into a TagResponse\n   * @param response - Raw provider response\n   * @returns Parsed and validated tag response\n   */\n  protected abstract parseResponse(response: ProviderResponse): TagResponse;\n\n  /**\n   * Validates provider-specific settings\n   * @param settings - Provider settings to validate\n   * @returns True if settings are valid\n   */\n  public abstract validateSettings(settings: BaseProviderSettings): boolean;\n\n  // ========================================================================\n  // TEMPLATE METHODS (can be overridden by subclasses)\n  // ========================================================================\n\n  /**\n   * Extracts the API key from provider settings\n   * Default implementation uses settings.apiKey\n   * Override for providers with custom key names (e.g., openaiApiKey, zaiApiKey)\n   * @param settings - Provider settings\n   * @returns API key or undefined\n   */\n  protected getApiKey(settings: BaseProviderSettings): string | undefined {\n    return settings.apiKey;\n  }\n\n  /**\n   * Returns the HTTP header key for authentication\n   * Default implementation returns 'Authorization'\n   * Override for providers with different auth header (e.g., Claude uses 'x-api-key')\n   * @returns Header key string\n   */\n  protected getAuthHeaderKey(): string {\n    return 'Authorization';\n  }\n\n  /**\n   * Formats the API key for the authentication header\n   * Default implementation uses Bearer token format\n   * Override for providers with different auth schemes\n   * @param apiKey - The API key to format\n   * @returns Formatted header value\n   */\n  protected formatAuthHeader(apiKey: string): string {\n    return `Bearer ${apiKey}`;\n  }\n\n  /**\n   * Returns additional provider-specific headers\n   * Override to add custom headers (e.g., Claude's version headers)\n   * @param settings - Provider settings\n   * @returns Additional headers object\n   */\n  protected getAdditionalHeaders(_settings: BaseProviderSettings): HttpHeaders {\n    return {};\n  }\n\n  // ========================================================================\n  // COMMON UTILITY METHODS\n  // ========================================================================\n\n  /**\n   * Builds the analysis prompt from structured email data\n   * @param structuredData - Email data including headers, body, and attachments\n   * @param customTags - Custom tag configurations\n   * @returns Analysis prompt string\n   */\n  protected buildPrompt(structuredData: StructuredEmailData, customTags: CustomTags): string {\n    const result = buildPrompt(structuredData, customTags);\n    return result.prompt;\n  }\n\n  /**\n   * Validates the LLM response against the Tag schema\n   * @param response - Raw LLM response (string or object)\n   * @returns Validated tag response with fallback values\n   */\n  protected validateResponse(response: unknown): TagResponse {\n    return validateLLMResponse(response);\n  }\n\n  /**\n   * Logs an error message with API key masking\n   * @param message - Error message\n   * @param context - Additional context (apiKey will be masked if present)\n   */\n  protected logError(message: string, context: Record<string, unknown> = {}): void {\n    const sanitizedContext: Record<string, unknown> = { ...context };\n    if (sanitizedContext.apiKey) {\n      sanitizedContext.apiKey = this.maskApiKey(sanitizedContext.apiKey as string);\n    }\n    logger.error(message, sanitizedContext);\n  }\n\n  /**\n   * Logs an info message\n   * @param message - Info message\n   * @param context - Additional context\n   */\n  protected logInfo(message: string, context: Record<string, unknown> = {}): void {\n    logger.info(message, context);\n  }\n\n  /**\n   * Logs a debug message\n   * @param message - Debug message\n   * @param context - Additional context\n   */\n  protected logDebug(message: string, context: Record<string, unknown> = {}): void {\n    logger.debug(message, context);\n  }\n\n  /**\n   * Masks an API key for logging purposes\n   * Shows first 7 and last 3 characters with ellipsis in between\n   * @param key - The API key to mask\n   * @returns Masked key string\n   */\n  protected maskApiKey(key: unknown): string | undefined {\n    return maskApiKey(key);\n  }\n\n  /**\n   * Gets the API headers for the request\n   * Uses template methods for provider-specific authentication\n   * @param settings - Provider settings\n   * @returns HTTP headers object\n   */\n  protected getHeaders(settings: BaseProviderSettings): HttpHeaders {\n    const headers: HttpHeaders = {\n      'Content-Type': 'application/json',\n    };\n\n    // Add authentication header using template methods\n    const apiKey = this.getApiKey(settings);\n    if (apiKey) {\n      headers[this.getAuthHeaderKey()] = this.formatAuthHeader(apiKey);\n    }\n\n    // Add provider-specific headers\n    const additionalHeaders = this.getAdditionalHeaders(settings);\n    Object.assign(headers, additionalHeaders);\n\n    return headers;\n  }\n\n  // ========================================================================\n  // REQUEST EXECUTION\n  // ========================================================================\n\n  /**\n   * Executes the API request with retry logic and timeout handling\n   * @param settings - Provider settings\n   * @param requestBody - Request body to send\n   * @returns Promise resolving to the API response\n   * @throws {Error} If the request fails after all retries\n   */\n  protected async executeRequest(\n    settings: BaseProviderSettings,\n    requestBody: RequestBody,\n    externalSignal?: AbortSignal\n  ): Promise<Response> {\n    const apiUrl = this.getApiUrl();\n    const headers = this.getHeaders(settings);\n\n    this.logDebug('Executing API request', {\n      url: apiUrl,\n      hasApiKey: !!this.getApiKey(settings),\n      model: settings.model,\n    });\n\n    try {\n      const response = await retryWithBackoff<Response>(async (): Promise<Response> => {\n        const res = await fetchWithTimeout(\n          apiUrl,\n          {\n            method: 'POST',\n            headers,\n            body: JSON.stringify(requestBody),\n          },\n          this.timeout,\n          externalSignal\n        );\n\n        if (!isOkResponse(res)) {\n          const errorText = await res.text().catch(() => 'Could not read error response');\n          this.logError('API request failed', {\n            status: res.status,\n            statusText: res.statusText,\n            error: errorText,\n          });\n          throw new Error(`API request failed: ${res.status} ${res.statusText}`);\n        }\n\n        return res;\n      }, this.retryConfig);\n\n      return response;\n    } catch (error) {\n      this.logError('Request execution failed', {\n        error: error instanceof Error ? error.message : String(error),\n        url: apiUrl,\n      });\n      throw error;\n    }\n  }\n\n  // ========================================================================\n  // PUBLIC ENTRY POINT\n  // ========================================================================\n\n  /**\n   * Analyzes an email using the AI provider\n   * This is the main entry point for email analysis\n   * @param input - Analysis input parameters\n   * @returns Promise resolving to validated tag response, or null on error\n   */\n  public async analyze(input: AnalyzeInput): Promise<AnalyzeOutput> {\n    const { settings, structuredData, customTags, signal } = input;\n\n    try {\n      this.logInfo('Starting email analysis', {\n        hasBody: !!structuredData.body,\n        attachmentCount: structuredData.attachments.length,\n        tagCount: customTags.length,\n        model: settings.model,\n      });\n\n      if (!this.validateSettings(settings)) {\n        this.logError('Invalid provider settings', { settings });\n        throw new Error('Invalid provider settings: Missing required API key or model');\n      }\n\n      const prompt = this.buildPrompt(structuredData, customTags);\n      this.logDebug('Built analysis prompt', { promptLength: prompt.length });\n\n      const requestBody = this.buildRequestBody(settings, prompt, structuredData, customTags);\n      this.logDebug('Built request body');\n\n      const response = await this.executeRequest(settings, requestBody, signal);\n      const responseData = await response.json();\n\n      this.logDebug('Parsing provider response');\n      const parsedResponse = this.parseResponse(responseData);\n\n      const validatedResponse = this.validateResponse(parsedResponse);\n\n      this.logInfo('Email analysis completed', {\n        tagCount: validatedResponse.tags.length,\n        confidence: validatedResponse.confidence,\n      });\n\n      return validatedResponse;\n    } catch (error) {\n      this.logError('Email analysis failed', {\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      });\n      // Re-throw the error with context\n      if (error instanceof Error) {\n        throw error;\n      }\n      throw new Error(String(error));\n    }\n  }\n}\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.087868",
  "last_updated": "2026-01-05T14:48:03.091401"
}