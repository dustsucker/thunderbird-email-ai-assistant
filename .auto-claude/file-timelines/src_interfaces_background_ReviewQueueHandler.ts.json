{
  "file_path": "src/interfaces/background/ReviewQueueHandler.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * Review Queue Handler Service\n *\n * Handles automatic flagging of low-confidence email classifications for manual review.\n *\n * This service:\n * - Listens for EmailAnalyzedEvent events\n * - Checks if any tags fell below confidence thresholds\n * - Adds items requiring review to the review queue\n * - Manages event listener registration/deregistration\n * - Coordinates with EventBus and ReviewQueueRepository\n *\n * @module interfaces/background/ReviewQueueHandler\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IReviewQueueRepository } from '@/infrastructure/interfaces/IReviewQueueRepository';\nimport type { IMailReader } from '@/infrastructure/interfaces/IMailReader';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\nimport { EventBus } from '@/domain/events/EventBus';\nimport type { EmailAnalyzedEvent } from '@/domain/events/EmailAnalyzedEvent';\nimport type { FilterTagsByThresholdResult } from '@/application/use-cases/ApplyTagsToEmail';\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Event handler state.\n */\ninterface HandlerState {\n  /** Whether handlers are registered */\n  isRegistered: boolean;\n  /** Number of items added to review queue */\n  itemsAdded: number;\n  /** Number of items skipped (no low-confidence tags) */\n  itemsSkipped: number;\n  /** Number of errors encountered */\n  errorsEncountered: number;\n}\n\n/**\n * Extended EmailAnalyzedEvent with filtering information.\n *\n * We expect the event to include filtering information if\n * threshold-based filtering was applied during tag application.\n */\ninterface ExtendedEmailAnalyzedEvent extends EmailAnalyzedEvent {\n  /** Filtering result if threshold was applied */\n  filterResult?: FilterTagsByThresholdResult;\n}\n\n// ============================================================================\n// Service Implementation\n// ============================================================================\n\n/**\n * Review Queue Handler Service\n *\n * Listens for EmailAnalyzedEvent and adds low-confidence classifications\n * to the review queue for manual user review.\n *\n * @example\n * ```typescript\n * const service = container.resolve<ReviewQueueHandler>(ReviewQueueHandler);\n *\n * // Start handling review queue events\n * service.start();\n *\n * // Later, stop handling\n * service.stop();\n * ```\n */\n@injectable()\nexport class ReviewQueueHandler {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private readonly reviewQueueRepository: IReviewQueueRepository;\n  private readonly mailReader: IMailReader;\n  private readonly configRepository: IConfigRepository;\n  private readonly logger: ILogger;\n  private readonly eventBus: EventBus;\n\n  private handlerState: HandlerState = {\n    isRegistered: false,\n    itemsAdded: 0,\n    itemsSkipped: 0,\n    errorsEncountered: 0,\n  };\n\n  // Cached unsubscribe function for proper cleanup\n  private unsubscribeFn: (() => void) | null = null;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  /**\n   * Creates a new ReviewQueueHandler instance.\n   *\n   * @param reviewQueueRepository - Repository for persisting review queue items\n   * @param mailReader - Mail reader for accessing email message metadata\n   * @param configRepository - Config repository for accessing threshold settings\n   * @param logger - Logger instance for logging operations\n   * @param eventBus - Event bus for subscribing to analysis events\n   */\n  constructor(\n    @inject('IReviewQueueRepository') reviewQueueRepository: IReviewQueueRepository,\n    @inject('IMailReader') mailReader: IMailReader,\n    @inject('IConfigRepository') configRepository: IConfigRepository,\n    @inject('ILogger') logger: ILogger,\n    @inject(EventBus) eventBus: EventBus\n  ) {\n    this.reviewQueueRepository = reviewQueueRepository;\n    this.mailReader = mailReader;\n    this.configRepository = configRepository;\n    this.logger = logger;\n    this.eventBus = eventBus;\n\n    this.logger.debug('ReviewQueueHandler service initialized');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Registers event listeners.\n   *\n   * Sets up handlers for EmailAnalyzedEvent.\n   */\n  async registerListeners(): Promise<void> {\n    if (this.handlerState.isRegistered) {\n      this.logger.warn('Event listeners already registered');\n      return;\n    }\n\n    this.logger.info('Registering review queue event listeners');\n\n    // Register EmailAnalyzedEvent handler\n    this.unsubscribeFn = this.eventBus.subscribe<EmailAnalyzedEvent>(\n      'EmailAnalyzed',\n      this.onEmailAnalyzed.bind(this)\n    );\n\n    this.handlerState.isRegistered = true;\n    this.logger.info('Review queue event listener registered');\n  }\n\n  /**\n   * Unregisters event listeners.\n   *\n   * Removes all registered event handlers.\n   */\n  async unregisterListeners(): Promise<void> {\n    if (!this.handlerState.isRegistered) {\n      this.logger.debug('Event listeners not registered');\n      return;\n    }\n\n    this.logger.info('Unregistering review queue event listeners');\n\n    // Unregister EmailAnalyzedEvent handler\n    if (this.unsubscribeFn) {\n      this.unsubscribeFn();\n      this.unsubscribeFn = null;\n      this.logger.info('Review queue event listener unregistered');\n    }\n\n    this.handlerState.isRegistered = false;\n    this.logger.info('Review queue event listeners unregistered');\n  }\n\n  /**\n   * Starts the event handler service.\n   *\n   * Registers all event listeners and begins tracking low-confidence classifications.\n   */\n  async start(): Promise<void> {\n    this.logger.info('Starting review queue handler service');\n    await this.registerListeners();\n  }\n\n  /**\n   * Stops the event handler service.\n   *\n   * Unregisters all event listeners and stops tracking low-confidence classifications.\n   */\n  async stop(): Promise<void> {\n    this.logger.info('Stopping review queue handler service');\n    await this.unregisterListeners();\n  }\n\n  /**\n   * Gets current handler state.\n   *\n   * @returns Current state of event handlers\n   */\n  getState(): HandlerState {\n    return { ...this.handlerState };\n  }\n\n  // ==========================================================================\n  // Private Methods\n  // ==========================================================================\n\n  /**\n   * Handler for EmailAnalyzedEvent.\n   *\n   * Checks if any tags fell below confidence thresholds and adds them to the review queue.\n   *\n   * @param event - Email analyzed event\n   */\n  private async onEmailAnalyzed(event: EmailAnalyzedEvent): Promise<void> {\n    this.logger.debug('EmailAnalyzedEvent received', {\n      messageId: event.messageId,\n      providerId: event.providerId,\n      model: event.model,\n      confidenceScore: event.result.confidence_score,\n      fromCache: event.fromCache,\n    });\n\n    try {\n      // Step 1: Get email message details for enrichment\n      let emailSubject = '';\n      let emailFrom = '';\n\n      try {\n        const messageIdNum = parseInt(event.messageId, 10);\n        if (!isNaN(messageIdNum)) {\n          const email = await this.mailReader.getFullMessage(messageIdNum);\n          if (email) {\n            emailSubject = email.subject || '';\n            emailFrom = email.from || '';\n          }\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        this.logger.warn('Failed to get email message details', {\n          messageId: event.messageId,\n          error: errorMessage,\n        });\n        // Continue with empty values - non-fatal error\n      }\n\n      // Step 2: Re-check tags against thresholds to identify low-confidence classifications\n      // We need to do this because the filtering result isn't included in the event\n      const manualReviewTags = await this.checkThresholds(event);\n\n      // Step 3: If no tags need review, skip\n      if (manualReviewTags.length === 0) {\n        this.logger.debug('No tags below threshold, skipping review queue', {\n          messageId: event.messageId,\n          confidenceScore: event.result.confidence_score,\n        });\n        this.handlerState.itemsSkipped++;\n        return;\n      }\n\n      // Step 4: Create review queue item\n      const reviewItem = {\n        id: this.generateItemId(),\n        messageId: event.messageId,\n        subject: emailSubject,\n        from: emailFrom,\n        timestamp: event.timestamp,\n        provider: event.providerId,\n        model: event.model,\n        confidenceScore: event.result.confidence_score,\n        manualReviewTags,\n        reasoning: event.result.reasoning || '',\n        status: 'pending' as const,\n        addedAt: new Date().toISOString(),\n        cacheKey: event.cacheKey,\n      };\n\n      // Step 5: Add to review queue\n      await this.reviewQueueRepository.addToQueue(reviewItem);\n\n      this.handlerState.itemsAdded++;\n\n      this.logger.info('Low-confidence classification added to review queue', {\n        itemId: reviewItem.id,\n        messageId: event.messageId,\n        confidenceScore: event.result.confidence_score,\n        manualReviewCount: manualReviewTags.length,\n        manualReviewTags: manualReviewTags.map((t) => ({\n          tag: t.tag,\n          confidence: t.confidence,\n          threshold: t.threshold,\n        })),\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to add item to review queue', {\n        messageId: event.messageId,\n        error: errorMessage,\n      });\n\n      this.handlerState.errorsEncountered++;\n      // Don't throw - continue processing other events\n    }\n  }\n\n  /**\n   * Checks tags against thresholds to identify those needing manual review.\n   *\n   * For each tag, retrieves its effective threshold (per-tag override or global)\n   * and checks if the confidence score meets it.\n   *\n   * @param event - Email analyzed event\n   * @returns Array of tags that need manual review with their confidence and threshold\n   */\n  private async checkThresholds(\n    event: EmailAnalyzedEvent\n  ): Promise<Array<{ tag: string; confidence: number; threshold: number }>> {\n    const { tags, confidence_score } = event.result;\n    const manualReviewTags: Array<{ tag: string; confidence: number; threshold: number }> = [];\n\n    this.logger.debug('Checking tags against thresholds for review queue', {\n      totalTags: tags.length,\n      overallConfidence: confidence_score,\n    });\n\n    for (const tag of tags) {\n      try {\n        // Get global threshold\n        const appConfig = await this.configRepository.getAppConfig();\n        const globalThreshold = appConfig.confidenceThreshold || 70;\n\n        // Get per-tag override if it exists\n        const tagThreshold = await this.configRepository.getTagThreshold(tag);\n        const effectiveThreshold = tagThreshold !== null ? tagThreshold : globalThreshold;\n\n        this.logger.debug('Checking tag against threshold', {\n          tag,\n          confidence: confidence_score,\n          threshold: effectiveThreshold,\n          meetsThreshold: confidence_score >= effectiveThreshold,\n        });\n\n        if (confidence_score < effectiveThreshold) {\n          // Tag below threshold - needs manual review\n          manualReviewTags.push({\n            tag,\n            confidence: confidence_score,\n            threshold: effectiveThreshold,\n          });\n          this.logger.debug('\u26a0\ufe0f Tag below threshold - adding to review queue', {\n            tag,\n            confidence: confidence_score,\n            threshold: effectiveThreshold,\n            deficit: effectiveThreshold - confidence_score,\n          });\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        this.logger.error('\u274c Failed to check threshold for tag', { tag, error: errorMessage });\n        // On error, add to review queue for safety\n        manualReviewTags.push({\n          tag,\n          confidence: confidence_score,\n          threshold: 70, // Default to 70% on error\n        });\n      }\n    }\n\n    if (manualReviewTags.length > 0) {\n      this.logger.debug('\u2705 Threshold check complete - tags need review', {\n        reviewCount: manualReviewTags.length,\n        tags: manualReviewTags.map((t) => t.tag),\n      });\n    } else {\n      this.logger.debug('\u2705 Threshold check complete - all tags meet requirements');\n    }\n\n    return manualReviewTags;\n  }\n\n  /**\n   * Generates a unique review queue item ID.\n   *\n   * @returns Unique item ID\n   */\n  private generateItemId(): string {\n    return `review-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n  }\n}\n",
        "last_modified": "2026-01-05T19:59:00.211370"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.048282",
  "last_updated": "2026-01-05T14:48:03.051450"
}