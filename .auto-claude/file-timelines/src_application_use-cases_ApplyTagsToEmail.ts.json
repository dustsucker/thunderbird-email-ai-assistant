{
  "file_path": "src/application/use-cases/ApplyTagsToEmail.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "/**\n * ApplyTagsToEmail Use Case\n *\n * Manages tag application to email messages.\n * Ensures tags exist before applying them and handles tag validation.\n *\n * This use case provides a clean interface for applying tags to messages:\n * 1. Validates and ensures all specified tags exist\n * 2. Applies tags to specified message via ITagManager\n *\n * @module application/use-cases/ApplyTagsToEmail\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { ITagManager } from '@/infrastructure/interfaces/ITagManager';\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\nimport { EventBus } from '@/domain/events/EventBus';\nimport { createTagAppliedEvent } from '@/domain/events/TagAppliedEvent';\nimport { createTagCreatedEvent } from '@/domain/events/TagCreatedEvent';\nimport { HARDCODED_TAGS, type Tag } from '../../../core/config';\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Configuration for tag application.\n */\nexport interface ApplyTagsConfig {\n  /** Whether to create missing tags automatically (default: false) */\n  createMissingTags?: boolean;\n  /** Whether to replace existing tags (default: false - append tags) */\n  replaceTags?: boolean;\n  /** Default color for auto-created tags (if createMissingTags is true) */\n  defaultColor?: string;\n}\n\n/**\n * Result of tag application.\n */\nexport interface ApplyTagsResult {\n  /** Message ID that tags were applied to */\n  messageId: string;\n  /** Tags that were successfully applied */\n  appliedTags: string[];\n  /** Tags that were skipped (already existed or failed) */\n  skippedTags: string[];\n  /** Tags that were created (if createMissingTags was true) */\n  createdTags: string[];\n}\n\n// ============================================================================\n// Use Case Implementation\n// ============================================================================\n\n/**\n * ApplyTagsToEmail Use Case\n *\n * Provides functionality for applying tags to email messages.\n * Handles tag validation and automatic creation if configured.\n *\n * @example\n * ```typescript\n * const useCase = container.resolve<ApplyTagsToEmail>(ApplyTagsToEmail);\n * const result = await useCase.execute('12345', ['is_business', 'is_important']);\n * console.log(`Applied ${result.appliedTags.length} tags`);\n * ```\n */\n@injectable()\nexport class ApplyTagsToEmail {\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor(\n    @inject('ITagManager') private readonly tagManager: ITagManager,\n    @inject('ILogger') private readonly logger: ILogger,\n    @inject(EventBus) private readonly eventBus: EventBus,\n    @inject('IConfigRepository') private readonly configRepository: IConfigRepository\n  ) {\n    this.logger.debug('\u2705 ApplyTagsToEmail use case initialized');\n  }\n\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  /** Flag to track if hardcoded tags have been ensured */\n  private hardcodedTagsEnsured: boolean = false;\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Applies tags to an email message.\n   *\n   * @param messageId - Thunderbird message ID (as string for flexibility)\n   * @param tagKeys - Tag keys to apply\n   * @param config - Optional configuration for tag application\n   * @returns Promise resolving to tag application result\n   *\n   * @throws {Error} If message ID is invalid\n   * @throws {Error} If tag application fails\n   *\n   * @example\n   * ```typescript\n   * const result = await applyTagsToEmail.execute('12345', ['is_business']);\n   * console.log(`Applied: ${result.appliedTags.join(', ')}`);\n   * ```\n   */\n  async execute(\n    messageId: string,\n    tagKeys: string[],\n    config: ApplyTagsConfig = {}\n  ): Promise<ApplyTagsResult> {\n    // Hardcoded Tags beim ersten Mal erstellen\n    if (!this.hardcodedTagsEnsured) {\n      await this.ensureHardcodedTagsExist();\n      this.hardcodedTagsEnsured = true;\n      this.logger.info('\u2705 Hardcoded tags ensured on first execution');\n    }\n\n    const { createMissingTags = false, replaceTags = false, defaultColor = '#9E9E9E' } = config;\n\n    this.logger.info('\ud83c\udff7\ufe0f  Applying tags to email', {\n      messageId,\n      tagKeys,\n      config: { createMissingTags, replaceTags },\n    });\n\n    try {\n      // Validate message ID\n      const messageIdNum = parseInt(messageId, 10);\n      if (isNaN(messageIdNum)) {\n        throw new Error(`Invalid message ID: ${messageId}`);\n      }\n\n      // Validate and filter tags\n      const { validTags, invalidTags, warnings } = await this.validateAndFilterTags(tagKeys);\n\n      // Log warnings for invalid tags\n      if (warnings.length > 0) {\n        warnings.forEach((warning) => this.logger.warn(warning));\n      }\n\n      // Ensure all valid tags exist\n      this.logger.debug('\u27a1\ufe0f  Ensuring tags exist', { tagKeys: validTags, createMissingTags });\n      const { applied: ensuredTags, created: createdTags } = await this.ensureTagsExist(\n        validTags,\n        createMissingTags,\n        defaultColor\n      );\n      this.logger.debug('\u2705 Tags ensured', { ensuredTags, createdTags });\n\n      // Apply tags to message\n      this.logger.debug('\u27a1\ufe0f  Applying tags to message');\n      await this.applyTagsToMessage(messageIdNum, ensuredTags, replaceTags);\n      this.logger.debug('\u2705 Tags applied to message');\n\n      this.logger.info('\u2705 Tags applied successfully', {\n        messageId,\n        appliedTags: ensuredTags,\n        createdTags,\n      });\n\n      // Publish TagAppliedEvent\n      this.logger.debug('\u27a1\ufe0f  Publishing TagAppliedEvent');\n      await this.eventBus.publish(\n        createTagAppliedEvent(messageId, ensuredTags, {\n          skippedTags: invalidTags,\n          createdTags,\n          replaceTags,\n        })\n      );\n\n      return {\n        messageId,\n        appliedTags: ensuredTags,\n        skippedTags: invalidTags,\n        createdTags,\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to apply tags', { messageId, tagKeys, error: errorMessage });\n      throw new Error(`Failed to apply tags to message ${messageId}: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Ensures tags exist in Thunderbird.\n   *\n   * Validates that all specified tags exist and optionally creates missing ones.\n   *\n   * @param tagKeys - Tag keys to ensure exist\n   * @param createMissing - Whether to create missing tags (default: false)\n   * @param defaultColor - Default color for auto-created tags\n   * @returns Promise resolving to ensured tags and created tags\n   *\n   * @throws {Error} If a required tag does not exist and createMissing is false\n   *\n   * @example\n   * ```typescript\n   * const { applied, created } = await applyTagsToEmail.ensureTagsExist(\n   *   ['is_business', 'is_personal'],\n   *   true,\n   *   '#FF0000'\n   * );\n   * console.log(`Created ${created.length} new tags`);\n   * ```\n   */\n  async ensureTagsExist(\n    tagKeys: string[],\n    createMissing: boolean = false,\n    defaultColor: string = '#9E9E9E'\n  ): Promise<{ applied: string[]; created: string[] }> {\n    this.logger.debug('\ud83d\udd0d Ensuring tags exist', { tagKeys, createMissing, defaultColor });\n\n    const applied: string[] = [];\n    const created: string[] = [];\n\n    for (const tagKey of tagKeys) {\n      try {\n        this.logger.debug('\u27a1\ufe0f  Checking tag existence', { tagKey });\n        const existingTag = await this.tagManager.getTag(tagKey);\n\n        if (existingTag) {\n          // Tag already exists\n          this.logger.debug('\u2705 Tag already exists', { tagKey });\n          applied.push(tagKey);\n        } else if (createMissing) {\n          // Create missing tag\n          this.logger.info('\ud83c\udd95 Creating missing tag', { tagKey, color: defaultColor });\n\n          // Generate a readable tag name from key\n          const tagName = this.keyToTagName(tagKey);\n\n          await this.tagManager.ensureTagExists(tagKey, tagName, defaultColor);\n          created.push(tagKey);\n          applied.push(tagKey);\n\n          // Publish TagCreatedEvent\n          this.logger.debug('\u27a1\ufe0f  Publishing TagCreatedEvent');\n          await this.eventBus.publish(createTagCreatedEvent(tagKey, tagName, defaultColor));\n          this.logger.debug('\u2705 TagCreatedEvent published');\n        } else {\n          // Tag does not exist and creation is disabled\n          this.logger.warn('\u26a0\ufe0f  Tag does not exist and creation is disabled', { tagKey });\n          throw new Error(\n            `Tag '${tagKey}' does not exist. Set createMissingTags=true to create it automatically.`\n          );\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        this.logger.error('\u274c Failed to ensure tag exists', { tagKey, error: errorMessage });\n        throw error;\n      }\n    }\n\n    this.logger.debug('\u2705 Tags ensured', { applied: applied.length, created: created.length });\n\n    return { applied, created };\n  }\n\n  /**\n   * Removes tags from an email message.\n   *\n   * @param messageId - Thunderbird message ID\n   * @param tagKeys - Tag keys to remove\n   * @returns Promise resolving when tags are removed\n   *\n   * @throws {Error} If message ID is invalid\n   * @throws {Error} If tag removal fails\n   *\n   * @example\n   * ```typescript\n   * await applyTagsToEmail.removeTags('12345', ['is_business', 'is_personal']);\n   * ```\n   */\n  async removeTags(messageId: string, tagKeys: string[]): Promise<void> {\n    this.logger.info('\ud83d\uddd1\ufe0f  Removing tags from email', { messageId, tagKeys });\n\n    try {\n      const messageIdNum = parseInt(messageId, 10);\n      if (isNaN(messageIdNum)) {\n        throw new Error(`Invalid message ID: ${messageId}`);\n      }\n\n      // Get current tags on message\n      this.logger.debug('\u27a1\ufe0f  Getting current tags on message');\n      const currentTags = await this.getCurrentTags(messageIdNum);\n      const keysToRemove = tagKeys.filter((k) => currentTags.includes(k));\n      this.logger.debug('\u2705 Current tags retrieved', { currentTags, keysToRemove });\n\n      if (keysToRemove.length === 0) {\n        this.logger.debug('\u23ed\ufe0f  No tags to remove', { messageId, tagKeys });\n        return;\n      }\n\n      // Calculate remaining tags\n      const remainingTags = currentTags.filter((k) => !keysToRemove.includes(k));\n      this.logger.debug('\u27a1\ufe0f  Setting remaining tags', { remainingTags });\n\n      // Set remaining tags\n      await this.tagManager.setTagsOnMessage(messageIdNum, remainingTags);\n\n      this.logger.info('\u2705 Tags removed successfully', {\n        messageId,\n        removedTags: keysToRemove,\n        remainingTags: remainingTags.length,\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to remove tags', { messageId, tagKeys, error: errorMessage });\n      throw new Error(`Failed to remove tags from message ${messageId}: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Clears all tags from an email message.\n   *\n   * @param messageId - Thunderbird message ID\n   * @returns Promise resolving when all tags are cleared\n   *\n   * @throws {Error} If message ID is invalid\n   * @throws {Error} If tag clearing fails\n   *\n   * @example\n   * ```typescript\n   * await applyTagsToEmail.clearTags('12345');\n   * ```\n   */\n  async clearTags(messageId: string): Promise<void> {\n    this.logger.info('\ud83e\uddf9 Clearing all tags from email', { messageId });\n\n    try {\n      const messageIdNum = parseInt(messageId, 10);\n      if (isNaN(messageIdNum)) {\n        throw new Error(`Invalid message ID: ${messageId}`);\n      }\n\n      this.logger.debug('\u27a1\ufe0f  Setting empty tag array');\n      await this.tagManager.setTagsOnMessage(messageIdNum, []);\n\n      this.logger.info('\u2705 All tags cleared', { messageId });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to clear tags', { messageId, error: errorMessage });\n      throw new Error(`Failed to clear tags from message ${messageId}: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods\n  // ==========================================================================\n\n  /**\n   * Ensures all hardcoded tags exist in Thunderbird.\n   *\n   * Automatically creates all tags defined in HARDCODED_TAGS if they don't exist.\n   * This is called once on the first execution to ensure the system has all\n   * required tags available.\n   *\n   * @private\n   */\n  private async ensureHardcodedTagsExist(): Promise<void> {\n    for (const [key, tagConfig] of Object.entries(HARDCODED_TAGS)) {\n      try {\n        await this.tagManager.ensureTagExists(key, tagConfig.name, tagConfig.color);\n        this.logger.debug('Hardcoded tag ensured', { key, name: tagConfig.name });\n      } catch (error) {\n        this.logger.warn('Failed to ensure hardcoded tag', { key, error: String(error) });\n      }\n    }\n  }\n\n  /**\n   * Validates and filters tags against defined tags.\n   *\n   * Checks each tag key against hardcoded tags and custom tags.\n   * Returns valid tags that are defined and invalid tags that should be discarded.\n   *\n   * @param tagKeys - Tag keys to validate\n   * @returns Promise resolving to valid tags, invalid tags, and warning messages\n   */\n  private async validateAndFilterTags(tagKeys: string[]): Promise<{\n    validTags: string[];\n    invalidTags: string[];\n    warnings: string[];\n  }> {\n    this.logger.debug(`[DEBUG-TagValidation] Validating ${tagKeys.length} tags from LLM`);\n\n    const validTags: string[] = [];\n    const invalidTags: string[] = [];\n    const warnings: string[] = [];\n\n    // Get custom tags from config repository\n    const customTags = await this.configRepository.getCustomTags();\n\n    // Build a set of all defined tag keys\n    const hardcodedTagKeys = new Set(Object.keys(HARDCODED_TAGS));\n    const customTagKeys = new Set(customTags.map((tag) => tag.key));\n\n    for (const tagKey of tagKeys) {\n      if (hardcodedTagKeys.has(tagKey)) {\n        // Tag is in HARDCODED_TAGS\n        validTags.push(tagKey);\n      } else if (customTagKeys.has(tagKey)) {\n        // Tag is in Custom Tags\n        validTags.push(tagKey);\n      } else {\n        // Tag is not defined\n        invalidTags.push(tagKey);\n        warnings.push(\n          `[DEBUG-TagValidation] Invalid tag '${tagKey}' - not defined in HARDCODED_TAGS or custom tags`\n        );\n      }\n    }\n\n    this.logger.debug(\n      `[DEBUG-TagValidation] Found ${validTags.length} valid, ${invalidTags.length} invalid tags`\n    );\n\n    if (invalidTags.length > 0) {\n      this.logger.debug(`[DEBUG-TagValidation] Invalid tags: ${invalidTags.join(', ')}`);\n      this.logger.warn(`[WARN-TagValidation] Skipping ${invalidTags.length} undefined tags`);\n    }\n\n    return { validTags, invalidTags, warnings };\n  }\n\n  /**\n   * Applies tags to a message.\n   *\n   * @param messageId - Message ID (as number)\n   * @param tagKeys - Tag keys to apply\n   * @param replaceTags - Whether to replace existing tags\n   * @throws {Error} If tag application fails\n   */\n  private async applyTagsToMessage(\n    messageId: number,\n    tagKeys: string[],\n    replaceTags: boolean\n  ): Promise<void> {\n    this.logger.debug('\ud83d\udd27 Applying tags to message', { messageId, tagKeys, replaceTags });\n\n    try {\n      if (replaceTags) {\n        // Replace all tags\n        this.logger.debug('\u27a1\ufe0f  Replacing all tags');\n        await this.tagManager.setTagsOnMessage(messageId, tagKeys);\n      } else {\n        // Append tags to existing ones\n        this.logger.debug('\u27a1\ufe0f  Appending tags to existing ones');\n        const currentTags = await this.getCurrentTags(messageId);\n        const newTags = [...new Set([...currentTags, ...tagKeys])];\n        this.logger.debug('\u2705 Combined tags', { current: currentTags.length, new: newTags.length });\n        await this.tagManager.setTagsOnMessage(messageId, newTags);\n      }\n\n      this.logger.debug('\u2705 Tags applied to message', { messageId, count: tagKeys.length });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to apply tags to message', { messageId, error: errorMessage });\n      throw error;\n    }\n  }\n\n  /**\n   * Gets current tags on a message.\n   *\n   * Note: This is a simplified implementation. In a real implementation,\n   * you would retrieve the current tags from Thunderbird via IMailReader\n   * or a dedicated method in ITagManager.\n   *\n   * @param messageId - Message ID\n   * @returns Array of tag keys currently on the message\n   */\n  private async getCurrentTags(messageId: number): Promise<string[]> {\n    // Simplified implementation - in real code, you would:\n    // 1. Call messenger.messages.get(messageId) to get message object\n    // 2. Extract tags from message.tags property\n    // 3. Return tag keys\n\n    this.logger.debug('\ud83d\udd0d Getting current tags for message', { messageId });\n\n    // Placeholder implementation\n    // This should be replaced with actual Thunderbird API call\n    return [];\n  }\n\n  /**\n   * Converts a tag key to a readable tag name.\n   *\n   * @param key - Tag key (e.g., 'is_business')\n   * @returns Tag name (e.g., 'Business')\n   */\n  private keyToTagName(key: string): string {\n    return key\n      .split(/[_\\s]+/)\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n  }\n}\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * ApplyTagsToEmail Use Case\n *\n * Manages tag application to email messages.\n * Ensures tags exist before applying them and handles tag validation.\n *\n * This use case provides a clean interface for applying tags to messages:\n * 1. Validates and ensures all specified tags exist\n * 2. Applies tags to specified message via ITagManager\n *\n * @module application/use-cases/ApplyTagsToEmail\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { ITagManager } from '@/infrastructure/interfaces/ITagManager';\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\nimport type { ITagResponse } from '@/infrastructure/interfaces/IProvider';\nimport { EventBus } from '@/domain/events/EventBus';\nimport { createTagAppliedEvent } from '@/domain/events/TagAppliedEvent';\nimport { createTagCreatedEvent } from '@/domain/events/TagCreatedEvent';\nimport { HARDCODED_TAGS, type Tag } from '../../../core/config';\nimport { AppConfigService } from '@/infrastructure/config/AppConfig';\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Configuration for tag application.\n */\nexport interface ApplyTagsConfig {\n  /** Whether to create missing tags automatically (default: false) */\n  createMissingTags?: boolean;\n  /** Whether to replace existing tags (default: false - append tags) */\n  replaceTags?: boolean;\n  /** Default color for auto-created tags (if createMissingTags is true) */\n  defaultColor?: string;\n}\n\n/**\n * Result of tag application.\n */\nexport interface ApplyTagsResult {\n  /** Message ID that tags were applied to */\n  messageId: string;\n  /** Tags that were successfully applied */\n  appliedTags: string[];\n  /** Tags that were skipped (already existed or failed) */\n  skippedTags: string[];\n  /** Tags that were created (if createMissingTags was true) */\n  createdTags: string[];\n}\n\n/**\n * Result of confidence-based tag filtering.\n */\nexport interface FilterTagsByThresholdResult {\n  /** Tags that meet the threshold criteria */\n  autoApplyTags: string[];\n  /** Tags that fall below the threshold and need manual review */\n  manualReviewTags: Array<{ tag: string; confidence: number; threshold: number }>;\n  /** Overall confidence score */\n  overallConfidence: number;\n}\n\n// ============================================================================\n// Use Case Implementation\n// ============================================================================\n\n/**\n * ApplyTagsToEmail Use Case\n *\n * Provides functionality for applying tags to email messages.\n * Handles tag validation and automatic creation if configured.\n *\n * @example\n * ```typescript\n * const useCase = container.resolve<ApplyTagsToEmail>(ApplyTagsToEmail);\n * const result = await useCase.execute('12345', ['is_business', 'is_important']);\n * console.log(`Applied ${result.appliedTags.length} tags`);\n * ```\n */\n@injectable()\nexport class ApplyTagsToEmail {\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor(\n    @inject('ITagManager') private readonly tagManager: ITagManager,\n    @inject('ILogger') private readonly logger: ILogger,\n    @inject(EventBus) private readonly eventBus: EventBus,\n    @inject('IConfigRepository') private readonly configRepository: IConfigRepository,\n    @inject(AppConfigService) private readonly appConfigService: AppConfigService\n  ) {\n    this.logger.debug('\u2705 ApplyTagsToEmail use case initialized');\n  }\n\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  /** Flag to track if hardcoded tags have been ensured */\n  private hardcodedTagsEnsured: boolean = false;\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Filters tags based on confidence thresholds.\n   *\n   * For each tag, checks if the overall confidence score meets the tag's threshold.\n   * Uses per-tag threshold override if available, otherwise falls back to global threshold.\n   *\n   * @param analysisResult - The AI analysis result containing tags and confidence score\n   * @returns Promise resolving to filtered tags split into auto-apply and manual review categories\n   *\n   * @example\n   * ```typescript\n   * const result = await applyTagsToEmail.filterTagsByThreshold(analysisResult);\n   * console.log(`${result.autoApplyTags.length} tags to auto-apply`);\n   * console.log(`${result.manualReviewTags.length} tags need manual review`);\n   * ```\n   */\n  async filterTagsByThreshold(analysisResult: ITagResponse): Promise<FilterTagsByThresholdResult> {\n    const { tags, confidence_score } = analysisResult;\n\n    this.logger.debug('\ud83d\udd0d Filtering tags by confidence threshold', {\n      totalTags: tags.length,\n      overallConfidence: confidence_score,\n    });\n\n    const autoApplyTags: string[] = [];\n    const manualReviewTags: Array<{ tag: string; confidence: number; threshold: number }> = [];\n\n    for (const tag of tags) {\n      try {\n        // Get the effective threshold for this tag (per-tag override or global)\n        const threshold = await this.appConfigService.getEffectiveThreshold(tag);\n\n        this.logger.debug('Checking tag against threshold', {\n          tag,\n          confidence: confidence_score,\n          threshold,\n          meetsThreshold: confidence_score >= threshold,\n        });\n\n        if (confidence_score >= threshold) {\n          // Tag meets threshold - can be auto-applied\n          autoApplyTags.push(tag);\n          this.logger.debug('\u2705 Tag meets threshold for auto-apply', { tag, confidence: confidence_score, threshold });\n        } else {\n          // Tag below threshold - needs manual review\n          manualReviewTags.push({\n            tag,\n            confidence: confidence_score,\n            threshold,\n          });\n          this.logger.debug('\u26a0\ufe0f Tag below threshold - manual review needed', {\n            tag,\n            confidence: confidence_score,\n            threshold,\n            deficit: threshold - confidence_score,\n          });\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        this.logger.error('\u274c Failed to check threshold for tag', { tag, error: errorMessage });\n        // On error, add to manual review for safety\n        manualReviewTags.push({\n          tag,\n          confidence: confidence_score,\n          threshold: 70, // Default to 70% on error\n        });\n      }\n    }\n\n    this.logger.info('\u2705 Tag filtering complete', {\n      autoApplyCount: autoApplyTags.length,\n      manualReviewCount: manualReviewTags.length,\n      overallConfidence: confidence_score,\n    });\n\n    return {\n      autoApplyTags,\n      manualReviewTags,\n      overallConfidence: confidence_score,\n    };\n  }\n\n  /**\n   * Applies tags to an email message based on confidence thresholds.\n   *\n   * This method extends the base `execute` method by first filtering tags\n   * based on confidence thresholds. Only tags that meet their threshold\n   * are automatically applied. Tags below threshold are tracked but not applied.\n   *\n   * @param messageId - Thunderbird message ID (as string for flexibility)\n   * @param analysisResult - The AI analysis result containing tags and confidence\n   * @param config - Optional configuration for tag application\n   * @returns Promise resolving to tag application result with filtering information\n   *\n   * @throws {Error} If message ID is invalid\n   * @throws {Error} If tag application fails\n   *\n   * @example\n   * ```typescript\n   * const result = await applyTagsToEmail.applyTagsWithThreshold('12345', analysisResult);\n   * console.log(`Applied ${result.appliedTags.length} tags`);\n   * console.log(`${result.filteredTags.length} tags filtered due to low confidence`);\n   * ```\n   */\n  async applyTagsWithThreshold(\n    messageId: string,\n    analysisResult: ITagResponse,\n    config: ApplyTagsConfig = {}\n  ): Promise<ApplyTagsResult & { filteredTags: FilterTagsByThresholdResult }> {\n    this.logger.info('\ud83c\udff7\ufe0f  Applying tags with confidence threshold filtering', {\n      messageId,\n      totalTags: analysisResult.tags.length,\n      confidence: analysisResult.confidence_score,\n    });\n\n    // Step 1: Filter tags based on thresholds\n    const filterResult = await this.filterTagsByThreshold(analysisResult);\n\n    // Step 2: Only apply tags that meet the threshold\n    if (filterResult.autoApplyTags.length > 0) {\n      this.logger.debug('\u27a1\ufe0f  Applying tags that meet threshold', {\n        count: filterResult.autoApplyTags.length,\n        tags: filterResult.autoApplyTags,\n      });\n      const applyResult = await this.execute(messageId, filterResult.autoApplyTags, config);\n\n      this.logger.info('\u2705 Tag application with filtering complete', {\n        messageId,\n        appliedCount: applyResult.appliedTags.length,\n        filteredCount: filterResult.manualReviewTags.length,\n      });\n\n      return {\n        ...applyResult,\n        filteredTags: filterResult,\n      };\n    } else {\n      this.logger.warn('\u26a0\ufe0f  No tags meet the threshold for auto-apply', {\n        messageId,\n        confidence: analysisResult.confidence_score,\n        manualReviewCount: filterResult.manualReviewTags.length,\n      });\n\n      return {\n        messageId,\n        appliedTags: [],\n        skippedTags: [],\n        createdTags: [],\n        filteredTags: filterResult,\n      };\n    }\n  }\n\n\n  /**\n   * Applies tags to an email message.\n   *\n   * @param messageId - Thunderbird message ID (as string for flexibility)\n   * @param tagKeys - Tag keys to apply\n   * @param config - Optional configuration for tag application\n   * @returns Promise resolving to tag application result\n   *\n   * @throws {Error} If message ID is invalid\n   * @throws {Error} If tag application fails\n   *\n   * @example\n   * ```typescript\n   * const result = await applyTagsToEmail.execute('12345', ['is_business']);\n   * console.log(`Applied: ${result.appliedTags.join(', ')}`);\n   * ```\n   */\n  async execute(\n    messageId: string,\n    tagKeys: string[],\n    config: ApplyTagsConfig = {}\n  ): Promise<ApplyTagsResult> {\n    // Hardcoded Tags beim ersten Mal erstellen\n    if (!this.hardcodedTagsEnsured) {\n      await this.ensureHardcodedTagsExist();\n      this.hardcodedTagsEnsured = true;\n      this.logger.info('\u2705 Hardcoded tags ensured on first execution');\n    }\n\n    const { createMissingTags = false, replaceTags = false, defaultColor = '#9E9E9E' } = config;\n\n    this.logger.info('\ud83c\udff7\ufe0f  Applying tags to email', {\n      messageId,\n      tagKeys,\n      config: { createMissingTags, replaceTags },\n    });\n\n    try {\n      // Validate message ID\n      const messageIdNum = parseInt(messageId, 10);\n      if (isNaN(messageIdNum)) {\n        throw new Error(`Invalid message ID: ${messageId}`);\n      }\n\n      // Validate and filter tags\n      const { validTags, invalidTags, warnings } = await this.validateAndFilterTags(tagKeys);\n\n      // Log warnings for invalid tags\n      if (warnings.length > 0) {\n        warnings.forEach((warning) => this.logger.warn(warning));\n      }\n\n      // Ensure all valid tags exist\n      this.logger.debug('\u27a1\ufe0f  Ensuring tags exist', { tagKeys: validTags, createMissingTags });\n      const { applied: ensuredTags, created: createdTags } = await this.ensureTagsExist(\n        validTags,\n        createMissingTags,\n        defaultColor\n      );\n      this.logger.debug('\u2705 Tags ensured', { ensuredTags, createdTags });\n\n      // Apply tags to message\n      this.logger.debug('\u27a1\ufe0f  Applying tags to message');\n      await this.applyTagsToMessage(messageIdNum, ensuredTags, replaceTags);\n      this.logger.debug('\u2705 Tags applied to message');\n\n      this.logger.info('\u2705 Tags applied successfully', {\n        messageId,\n        appliedTags: ensuredTags,\n        createdTags,\n      });\n\n      // Publish TagAppliedEvent\n      this.logger.debug('\u27a1\ufe0f  Publishing TagAppliedEvent');\n      await this.eventBus.publish(\n        createTagAppliedEvent(messageId, ensuredTags, {\n          skippedTags: invalidTags,\n          createdTags,\n          replaceTags,\n        })\n      );\n\n      return {\n        messageId,\n        appliedTags: ensuredTags,\n        skippedTags: invalidTags,\n        createdTags,\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to apply tags', { messageId, tagKeys, error: errorMessage });\n      throw new Error(`Failed to apply tags to message ${messageId}: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Ensures tags exist in Thunderbird.\n   *\n   * Validates that all specified tags exist and optionally creates missing ones.\n   *\n   * @param tagKeys - Tag keys to ensure exist\n   * @param createMissing - Whether to create missing tags (default: false)\n   * @param defaultColor - Default color for auto-created tags\n   * @returns Promise resolving to ensured tags and created tags\n   *\n   * @throws {Error} If a required tag does not exist and createMissing is false\n   *\n   * @example\n   * ```typescript\n   * const { applied, created } = await applyTagsToEmail.ensureTagsExist(\n   *   ['is_business', 'is_personal'],\n   *   true,\n   *   '#FF0000'\n   * );\n   * console.log(`Created ${created.length} new tags`);\n   * ```\n   */\n  async ensureTagsExist(\n    tagKeys: string[],\n    createMissing: boolean = false,\n    defaultColor: string = '#9E9E9E'\n  ): Promise<{ applied: string[]; created: string[] }> {\n    this.logger.debug('\ud83d\udd0d Ensuring tags exist', { tagKeys, createMissing, defaultColor });\n\n    const applied: string[] = [];\n    const created: string[] = [];\n\n    for (const tagKey of tagKeys) {\n      try {\n        this.logger.debug('\u27a1\ufe0f  Checking tag existence', { tagKey });\n        const existingTag = await this.tagManager.getTag(tagKey);\n\n        if (existingTag) {\n          // Tag already exists\n          this.logger.debug('\u2705 Tag already exists', { tagKey });\n          applied.push(tagKey);\n        } else if (createMissing) {\n          // Create missing tag\n          this.logger.info('\ud83c\udd95 Creating missing tag', { tagKey, color: defaultColor });\n\n          // Generate a readable tag name from key\n          const tagName = this.keyToTagName(tagKey);\n\n          await this.tagManager.ensureTagExists(tagKey, tagName, defaultColor);\n          created.push(tagKey);\n          applied.push(tagKey);\n\n          // Publish TagCreatedEvent\n          this.logger.debug('\u27a1\ufe0f  Publishing TagCreatedEvent');\n          await this.eventBus.publish(createTagCreatedEvent(tagKey, tagName, defaultColor));\n          this.logger.debug('\u2705 TagCreatedEvent published');\n        } else {\n          // Tag does not exist and creation is disabled\n          this.logger.warn('\u26a0\ufe0f  Tag does not exist and creation is disabled', { tagKey });\n          throw new Error(\n            `Tag '${tagKey}' does not exist. Set createMissingTags=true to create it automatically.`\n          );\n        }\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        this.logger.error('\u274c Failed to ensure tag exists', { tagKey, error: errorMessage });\n        throw error;\n      }\n    }\n\n    this.logger.debug('\u2705 Tags ensured', { applied: applied.length, created: created.length });\n\n    return { applied, created };\n  }\n\n  /**\n   * Removes tags from an email message.\n   *\n   * @param messageId - Thunderbird message ID\n   * @param tagKeys - Tag keys to remove\n   * @returns Promise resolving when tags are removed\n   *\n   * @throws {Error} If message ID is invalid\n   * @throws {Error} If tag removal fails\n   *\n   * @example\n   * ```typescript\n   * await applyTagsToEmail.removeTags('12345', ['is_business', 'is_personal']);\n   * ```\n   */\n  async removeTags(messageId: string, tagKeys: string[]): Promise<void> {\n    this.logger.info('\ud83d\uddd1\ufe0f  Removing tags from email', { messageId, tagKeys });\n\n    try {\n      const messageIdNum = parseInt(messageId, 10);\n      if (isNaN(messageIdNum)) {\n        throw new Error(`Invalid message ID: ${messageId}`);\n      }\n\n      // Get current tags on message\n      this.logger.debug('\u27a1\ufe0f  Getting current tags on message');\n      const currentTags = await this.getCurrentTags(messageIdNum);\n      const keysToRemove = tagKeys.filter((k) => currentTags.includes(k));\n      this.logger.debug('\u2705 Current tags retrieved', { currentTags, keysToRemove });\n\n      if (keysToRemove.length === 0) {\n        this.logger.debug('\u23ed\ufe0f  No tags to remove', { messageId, tagKeys });\n        return;\n      }\n\n      // Calculate remaining tags\n      const remainingTags = currentTags.filter((k) => !keysToRemove.includes(k));\n      this.logger.debug('\u27a1\ufe0f  Setting remaining tags', { remainingTags });\n\n      // Set remaining tags\n      await this.tagManager.setTagsOnMessage(messageIdNum, remainingTags);\n\n      this.logger.info('\u2705 Tags removed successfully', {\n        messageId,\n        removedTags: keysToRemove,\n        remainingTags: remainingTags.length,\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to remove tags', { messageId, tagKeys, error: errorMessage });\n      throw new Error(`Failed to remove tags from message ${messageId}: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Clears all tags from an email message.\n   *\n   * @param messageId - Thunderbird message ID\n   * @returns Promise resolving when all tags are cleared\n   *\n   * @throws {Error} If message ID is invalid\n   * @throws {Error} If tag clearing fails\n   *\n   * @example\n   * ```typescript\n   * await applyTagsToEmail.clearTags('12345');\n   * ```\n   */\n  async clearTags(messageId: string): Promise<void> {\n    this.logger.info('\ud83e\uddf9 Clearing all tags from email', { messageId });\n\n    try {\n      const messageIdNum = parseInt(messageId, 10);\n      if (isNaN(messageIdNum)) {\n        throw new Error(`Invalid message ID: ${messageId}`);\n      }\n\n      this.logger.debug('\u27a1\ufe0f  Setting empty tag array');\n      await this.tagManager.setTagsOnMessage(messageIdNum, []);\n\n      this.logger.info('\u2705 All tags cleared', { messageId });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to clear tags', { messageId, error: errorMessage });\n      throw new Error(`Failed to clear tags from message ${messageId}: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods\n  // ==========================================================================\n\n  /**\n   * Ensures all hardcoded tags exist in Thunderbird.\n   *\n   * Automatically creates all tags defined in HARDCODED_TAGS if they don't exist.\n   * This is called once on the first execution to ensure the system has all\n   * required tags available.\n   *\n   * @private\n   */\n  private async ensureHardcodedTagsExist(): Promise<void> {\n    for (const [key, tagConfig] of Object.entries(HARDCODED_TAGS)) {\n      try {\n        await this.tagManager.ensureTagExists(key, tagConfig.name, tagConfig.color);\n        this.logger.debug('Hardcoded tag ensured', { key, name: tagConfig.name });\n      } catch (error) {\n        this.logger.warn('Failed to ensure hardcoded tag', { key, error: String(error) });\n      }\n    }\n  }\n\n  /**\n   * Validates and filters tags against defined tags.\n   *\n   * Checks each tag key against hardcoded tags and custom tags.\n   * Returns valid tags that are defined and invalid tags that should be discarded.\n   *\n   * @param tagKeys - Tag keys to validate\n   * @returns Promise resolving to valid tags, invalid tags, and warning messages\n   */\n  private async validateAndFilterTags(tagKeys: string[]): Promise<{\n    validTags: string[];\n    invalidTags: string[];\n    warnings: string[];\n  }> {\n    this.logger.debug(`[DEBUG-TagValidation] Validating ${tagKeys.length} tags from LLM`);\n\n    const validTags: string[] = [];\n    const invalidTags: string[] = [];\n    const warnings: string[] = [];\n\n    // Get custom tags from config repository\n    const customTags = await this.configRepository.getCustomTags();\n\n    // Build a set of all defined tag keys\n    const hardcodedTagKeys = new Set(Object.keys(HARDCODED_TAGS));\n    const customTagKeys = new Set(customTags.map((tag) => tag.key));\n\n    for (const tagKey of tagKeys) {\n      if (hardcodedTagKeys.has(tagKey)) {\n        // Tag is in HARDCODED_TAGS\n        validTags.push(tagKey);\n      } else if (customTagKeys.has(tagKey)) {\n        // Tag is in Custom Tags\n        validTags.push(tagKey);\n      } else {\n        // Tag is not defined\n        invalidTags.push(tagKey);\n        warnings.push(\n          `[DEBUG-TagValidation] Invalid tag '${tagKey}' - not defined in HARDCODED_TAGS or custom tags`\n        );\n      }\n    }\n\n    this.logger.debug(\n      `[DEBUG-TagValidation] Found ${validTags.length} valid, ${invalidTags.length} invalid tags`\n    );\n\n    if (invalidTags.length > 0) {\n      this.logger.debug(`[DEBUG-TagValidation] Invalid tags: ${invalidTags.join(', ')}`);\n      this.logger.warn(`[WARN-TagValidation] Skipping ${invalidTags.length} undefined tags`);\n    }\n\n    return { validTags, invalidTags, warnings };\n  }\n\n  /**\n   * Applies tags to a message.\n   *\n   * @param messageId - Message ID (as number)\n   * @param tagKeys - Tag keys to apply\n   * @param replaceTags - Whether to replace existing tags\n   * @throws {Error} If tag application fails\n   */\n  private async applyTagsToMessage(\n    messageId: number,\n    tagKeys: string[],\n    replaceTags: boolean\n  ): Promise<void> {\n    this.logger.debug('\ud83d\udd27 Applying tags to message', { messageId, tagKeys, replaceTags });\n\n    try {\n      if (replaceTags) {\n        // Replace all tags\n        this.logger.debug('\u27a1\ufe0f  Replacing all tags');\n        await this.tagManager.setTagsOnMessage(messageId, tagKeys);\n      } else {\n        // Append tags to existing ones\n        this.logger.debug('\u27a1\ufe0f  Appending tags to existing ones');\n        const currentTags = await this.getCurrentTags(messageId);\n        const newTags = [...new Set([...currentTags, ...tagKeys])];\n        this.logger.debug('\u2705 Combined tags', { current: currentTags.length, new: newTags.length });\n        await this.tagManager.setTagsOnMessage(messageId, newTags);\n      }\n\n      this.logger.debug('\u2705 Tags applied to message', { messageId, count: tagKeys.length });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to apply tags to message', { messageId, error: errorMessage });\n      throw error;\n    }\n  }\n\n  /**\n   * Gets current tags on a message.\n   *\n   * Note: This is a simplified implementation. In a real implementation,\n   * you would retrieve the current tags from Thunderbird via IMailReader\n   * or a dedicated method in ITagManager.\n   *\n   * @param messageId - Message ID\n   * @returns Array of tag keys currently on the message\n   */\n  private async getCurrentTags(messageId: number): Promise<string[]> {\n    // Simplified implementation - in real code, you would:\n    // 1. Call messenger.messages.get(messageId) to get message object\n    // 2. Extract tags from message.tags property\n    // 3. Return tag keys\n\n    this.logger.debug('\ud83d\udd0d Getting current tags for message', { messageId });\n\n    // Placeholder implementation\n    // This should be replaced with actual Thunderbird API call\n    return [];\n  }\n\n  /**\n   * Converts a tag key to a readable tag name.\n   *\n   * @param key - Tag key (e.g., 'is_business')\n   * @returns Tag name (e.g., 'Business')\n   */\n  private keyToTagName(key: string): string {\n    return key\n      .split(/[_\\s]+/)\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n  }\n}\n",
        "last_modified": "2026-01-05T19:59:00.205645"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.076442",
  "last_updated": "2026-01-05T14:48:03.079848"
}