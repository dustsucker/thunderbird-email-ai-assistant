{
  "file_path": "src/infrastructure/providers/BaseProviderAdapter.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "/**\n * BaseProviderAdapter bridges the legacy BaseProvider implementation with the IProvider interface.\n *\n * This adapter enables dependency injection for existing BaseProvider implementations\n * by wrapping them in the IProvider interface contract.\n */\n\nimport { injectable } from 'tsyringe';\nimport type { BaseProvider } from './BaseProvider';\nimport type {\n  BaseProviderSettings,\n  AnalyzeInput as LegacyAnalyzeInput,\n} from './BaseProvider';\nimport type {\n  IProvider,\n  IProviderSettings,\n  IStructuredEmailData,\n  ICustomTag,\n  ITagResponse,\n  IAnalyzeInput,\n} from '../interfaces/IProvider';\nimport type { ILogger } from '../interfaces/ILogger';\nimport type { Tag } from '@/shared/types/ProviderTypes';\nimport 'reflect-metadata';\n\n// ============================================================================\n// Type Guards and Helpers\n// ============================================================================\n\n/**\n * Type guard to check if value is valid IProviderSettings\n */\nfunction isIProviderSettings(value: unknown): value is IProviderSettings {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    ('apiKey' in value || 'apiUrl' in value || 'model' in value)\n  );\n}\n\n/**\n * Type guard to check if value is valid IAttachment\n */\nfunction isIAttachment(value: unknown): value is { name: string; mimeType: string; size: number } {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'name' in value &&\n    'mimeType' in value &&\n    'size' in value\n  );\n}\n\n/**\n * Type guard to check if value is valid ICustomTag\n */\nfunction isICustomTag(value: unknown): value is { key: string; name: string; description: string } {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'key' in value &&\n    'name' in value &&\n    'description' in value\n  );\n}\n\n// ============================================================================\n// Adapter Implementation\n// ============================================================================\n\n/**\n * Adapter class that wraps BaseProvider to implement IProvider interface.\n *\n * This adapter enables the legacy BaseProvider implementations to be used\n * with the new dependency injection system. It handles type conversions between\n * the new IProvider interfaces and the legacy BaseProvider types.\n *\n * @template T - The BaseProvider implementation type\n *\n * @example\n * ```typescript\n * const adapter = new BaseProviderAdapter<OpenAIProvider>(\n *   'openai',\n *   new OpenAIProvider()\n * );\n * await container.registerInstance<IProvider>('IProvider', adapter);\n * ```\n */\n@injectable()\nexport class BaseProviderAdapter<T extends BaseProvider> implements IProvider {\n  private readonly logger: ILogger;\n  /** Unique provider identifier */\n  public readonly providerId: string;\n\n  /**\n   * Creates a new BaseProviderAdapter instance.\n   *\n   * @param providerId - Unique identifier for this provider\n   * @param provider - The BaseProvider implementation to wrap\n   * @param logger - Logger instance for logging operations\n   */\n  constructor(\n    providerId: string,\n    private readonly provider: T,\n    logger: ILogger\n  ) {\n    this.providerId = providerId;\n    this.logger = logger;\n    this.logger.debug('BaseProviderAdapter initialized', { providerId });\n  }\n\n  // ========================================================================\n  // IProvider Implementation\n  // ========================================================================\n\n  /**\n   * Validates provider settings.\n   *\n   * Delegates to the wrapped BaseProvider's validateSettings method.\n   *\n   * @param settings - Provider settings to validate\n   * @returns Promise resolving to true if settings are valid\n   * @throws {Error} If settings validation fails\n   *\n   * @example\n   * ```typescript\n   * const isValid = await adapter.validateSettings({\n   *   apiKey: 'sk-proj-123456'\n   * });\n   * ```\n   */\n  async validateSettings(settings: IProviderSettings): Promise<boolean> {\n    this.logger.debug('Validating provider settings', {\n      providerId: this.providerId,\n      hasApiKey: !!settings.apiKey,\n      hasModel: !!settings.model,\n    });\n\n    try {\n      // Convert IProviderSettings to BaseProviderSettings\n      const baseSettings: BaseProviderSettings = this.convertSettings(settings);\n\n      // Access protected method via type assertion (BaseProvider instances have this method)\n      const result = (\n        this.provider as {\n          validateSettings(settings: BaseProviderSettings): boolean;\n        }\n      ).validateSettings(baseSettings);\n\n      if (result) {\n        this.logger.debug('Settings validation succeeded', { providerId: this.providerId });\n      } else {\n        this.logger.warn('Settings validation failed', { providerId: this.providerId });\n      }\n\n      return result;\n    } catch (error) {\n      this.logger.error('Settings validation error', {\n        providerId: this.providerId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Analyzes an email and assigns tags.\n   *\n   * Delegates to the wrapped BaseProvider's analyze method after converting\n   * the input format from IAnalyzeInput to LegacyAnalyzeInput.\n   *\n   * @param input - Analysis input containing settings, email data, and tags\n   * @returns Promise resolving to tag analysis response\n   * @throws {Error} If analysis fails (invalid settings, API error, timeout, etc.)\n   *\n   * @example\n   * ```typescript\n   * const result = await adapter.analyze({\n   *   settings: { apiKey: 'sk-...', model: 'gpt-4' },\n   *   data: { headers: {}, body: 'Hello...', attachments: [] },\n   *   tags: [{ key: 'is_advertise', name: 'Ad', description: '...' }]\n   * });\n   * console.log(result.tags);\n   * ```\n   */\n  async analyze(input: IAnalyzeInput): Promise<ITagResponse> {\n    this.logger.debug('Starting email analysis', {\n      providerId: this.providerId,\n      tagCount: input.tags.length,\n      hasBody: !!input.data.body,\n    });\n\n    try {\n      // Convert IAnalyzeInput to LegacyAnalyzeInput\n      const legacyInput: LegacyAnalyzeInput = this.convertAnalyzeInput(input);\n\n      // Delegate to BaseProvider\n      const legacyResponse = await this.provider.analyze(legacyInput);\n\n      // Convert legacy TagResponse to ITagResponse\n      const response: ITagResponse = this.convertTagResponse(legacyResponse);\n\n      this.logger.info('Email analysis completed', {\n        providerId: this.providerId,\n        tagCount: response.tags.length,\n        confidence: response.confidence,\n      });\n\n      return response;\n    } catch (error) {\n      this.logger.error('Email analysis failed', {\n        providerId: this.providerId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  // ========================================================================\n  // Type Conversion Methods\n  // ========================================================================\n\n  /**\n   * Converts IProviderSettings to BaseProviderSettings.\n   *\n   * @param settings - IProviderSettings to convert\n   * @returns BaseProviderSettings\n   */\n  private convertSettings(settings: IProviderSettings): BaseProviderSettings {\n    if (!isIProviderSettings(settings)) {\n      throw new Error('Invalid settings provided');\n    }\n\n    const baseSettings: BaseProviderSettings = {\n      apiKey: settings.apiKey,\n      apiUrl: settings.apiUrl,\n      model: settings.model,\n    };\n\n    // Copy any additional properties\n    for (const [key, value] of Object.entries(settings)) {\n      if (!['apiKey', 'apiUrl', 'model'].includes(key)) {\n        baseSettings[key as keyof BaseProviderSettings] = value as never;\n      }\n    }\n\n    return baseSettings;\n  }\n\n  /**\n   * Converts IAnalyzeInput to LegacyAnalyzeInput.\n   *\n   * @param input - IAnalyzeInput to convert\n   * @returns LegacyAnalyzeInput\n   */\n  private convertAnalyzeInput(input: IAnalyzeInput): LegacyAnalyzeInput {\n    if (!isIProviderSettings(input.settings)) {\n      throw new Error('Invalid settings provided in analyze input');\n    }\n\n    // Convert IStructuredEmailData to StructuredEmailData\n    const structuredData = this.convertStructuredEmailData(input.data);\n\n    // Convert ICustomTag[] to CustomTags\n    const customTags = this.convertCustomTags(input.tags);\n\n    return {\n      settings: this.convertSettings(input.settings),\n      structuredData,\n      customTags,\n    };\n  }\n\n  /**\n   * Converts IStructuredEmailData to StructuredEmailData from legacy.\n   *\n   * @param data - IStructuredEmailData to convert\n   * @returns Legacy StructuredEmailData\n   */\n  private convertStructuredEmailData(data: IStructuredEmailData): {\n    headers: Record<string, string>;\n    body: string;\n    attachments: Array<{ name: string; mimeType: string; size: number }>;\n  } {\n    return {\n      headers: { ...data.headers },\n      body: data.body,\n      attachments: data.attachments.map((attachment) => {\n        if (!isIAttachment(attachment)) {\n          throw new Error('Invalid attachment provided');\n        }\n        return {\n          name: attachment.name,\n          mimeType: attachment.mimeType,\n          size: attachment.size,\n        };\n      }),\n    };\n  }\n\n  /**\n   * Converts ICustomTag[] to CustomTags from legacy.\n   *\n   * @param tags - ICustomTag array to convert\n   * @returns Legacy CustomTags\n   */\n  private convertCustomTags(tags: ICustomTag[]): Tag[] {\n    return tags.map((tag) => {\n      if (!isICustomTag(tag)) {\n        throw new Error('Invalid custom tag provided');\n      }\n      return {\n        key: tag.key,\n        name: tag.name,\n        color: '#9E9E9E', // Default gray color for custom tags\n        prompt: tag.description, // description maps to prompt in legacy\n      };\n    });\n  }\n\n  /**\n   * Converts legacy TagResponse to ITagResponse.\n   *\n   * @param response - Legacy TagResponse\n   * @returns ITagResponse\n   */\n  private convertTagResponse(response: {\n    tags: string[];\n    confidence: number;\n    reasoning: string;\n    [key: string]: unknown;\n  }): ITagResponse {\n    return {\n      tags: response.tags,\n      confidence: response.confidence,\n      reasoning: response.reasoning,\n      // Extract known optional fields if present\n      is_scam: response.is_scam as boolean | undefined,\n      sender: response.sender as string | undefined,\n      sender_consistent: response.sender_consistent as boolean | null | undefined,\n      spf_pass: response.spf_pass as boolean | null | undefined,\n      dkim_pass: response.dkim_pass as boolean | null | undefined,\n    };\n  }\n}\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * BaseProviderAdapter bridges the legacy BaseProvider implementation with the IProvider interface.\n *\n * This adapter enables dependency injection for existing BaseProvider implementations\n * by wrapping them in the IProvider interface contract.\n */\n\nimport { injectable } from 'tsyringe';\nimport type { BaseProvider } from './BaseProvider';\nimport type {\n  BaseProviderSettings,\n  AnalyzeInput as LegacyAnalyzeInput,\n} from './BaseProvider';\nimport type {\n  IProvider,\n  IProviderSettings,\n  IStructuredEmailData,\n  ICustomTag,\n  ITagResponse,\n  IAnalyzeInput,\n} from '../interfaces/IProvider';\nimport type { ILogger } from '../interfaces/ILogger';\nimport type { Tag } from '@/shared/types/ProviderTypes';\nimport 'reflect-metadata';\n\n// ============================================================================\n// Type Guards and Helpers\n// ============================================================================\n\n/**\n * Type guard to check if value is valid IProviderSettings\n */\nfunction isIProviderSettings(value: unknown): value is IProviderSettings {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    ('apiKey' in value || 'apiUrl' in value || 'model' in value)\n  );\n}\n\n/**\n * Type guard to check if value is valid IAttachment\n */\nfunction isIAttachment(value: unknown): value is { name: string; mimeType: string; size: number } {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'name' in value &&\n    'mimeType' in value &&\n    'size' in value\n  );\n}\n\n/**\n * Type guard to check if value is valid ICustomTag\n */\nfunction isICustomTag(value: unknown): value is { key: string; name: string; description: string } {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'key' in value &&\n    'name' in value &&\n    'description' in value\n  );\n}\n\n// ============================================================================\n// Adapter Implementation\n// ============================================================================\n\n/**\n * Adapter class that wraps BaseProvider to implement IProvider interface.\n *\n * This adapter enables the legacy BaseProvider implementations to be used\n * with the new dependency injection system. It handles type conversions between\n * the new IProvider interfaces and the legacy BaseProvider types.\n *\n * @template T - The BaseProvider implementation type\n *\n * @example\n * ```typescript\n * const adapter = new BaseProviderAdapter<OpenAIProvider>(\n *   'openai',\n *   new OpenAIProvider()\n * );\n * await container.registerInstance<IProvider>('IProvider', adapter);\n * ```\n */\n@injectable()\nexport class BaseProviderAdapter<T extends BaseProvider> implements IProvider {\n  private readonly logger: ILogger;\n  /** Unique provider identifier */\n  public readonly providerId: string;\n\n  /**\n   * Creates a new BaseProviderAdapter instance.\n   *\n   * @param providerId - Unique identifier for this provider\n   * @param provider - The BaseProvider implementation to wrap\n   * @param logger - Logger instance for logging operations\n   */\n  constructor(\n    providerId: string,\n    private readonly provider: T,\n    logger: ILogger\n  ) {\n    this.providerId = providerId;\n    this.logger = logger;\n    this.logger.debug('BaseProviderAdapter initialized', { providerId });\n  }\n\n  // ========================================================================\n  // IProvider Implementation\n  // ========================================================================\n\n  /**\n   * Validates provider settings.\n   *\n   * Delegates to the wrapped BaseProvider's validateSettings method.\n   *\n   * @param settings - Provider settings to validate\n   * @returns Promise resolving to true if settings are valid\n   * @throws {Error} If settings validation fails\n   *\n   * @example\n   * ```typescript\n   * const isValid = await adapter.validateSettings({\n   *   apiKey: 'sk-proj-123456'\n   * });\n   * ```\n   */\n  async validateSettings(settings: IProviderSettings): Promise<boolean> {\n    this.logger.debug('Validating provider settings', {\n      providerId: this.providerId,\n      hasApiKey: !!settings.apiKey,\n      hasModel: !!settings.model,\n    });\n\n    try {\n      // Convert IProviderSettings to BaseProviderSettings\n      const baseSettings: BaseProviderSettings = this.convertSettings(settings);\n\n      // Access protected method via type assertion (BaseProvider instances have this method)\n      const result = (\n        this.provider as {\n          validateSettings(settings: BaseProviderSettings): boolean;\n        }\n      ).validateSettings(baseSettings);\n\n      if (result) {\n        this.logger.debug('Settings validation succeeded', { providerId: this.providerId });\n      } else {\n        this.logger.warn('Settings validation failed', { providerId: this.providerId });\n      }\n\n      return result;\n    } catch (error) {\n      this.logger.error('Settings validation error', {\n        providerId: this.providerId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Analyzes an email and assigns tags.\n   *\n   * Delegates to the wrapped BaseProvider's analyze method after converting\n   * the input format from IAnalyzeInput to LegacyAnalyzeInput.\n   *\n   * @param input - Analysis input containing settings, email data, and tags\n   * @returns Promise resolving to tag analysis response\n   * @throws {Error} If analysis fails (invalid settings, API error, timeout, etc.)\n   *\n   * @example\n   * ```typescript\n   * const result = await adapter.analyze({\n   *   settings: { apiKey: 'sk-...', model: 'gpt-4' },\n   *   data: { headers: {}, body: 'Hello...', attachments: [] },\n   *   tags: [{ key: 'is_advertise', name: 'Ad', description: '...' }]\n   * });\n   * console.log(result.tags);\n   * ```\n   */\n  async analyze(input: IAnalyzeInput): Promise<ITagResponse> {\n    this.logger.debug('Starting email analysis', {\n      providerId: this.providerId,\n      tagCount: input.tags.length,\n      hasBody: !!input.data.body,\n    });\n\n    try {\n      // Convert IAnalyzeInput to LegacyAnalyzeInput\n      const legacyInput: LegacyAnalyzeInput = this.convertAnalyzeInput(input);\n\n      // Delegate to BaseProvider\n      const legacyResponse = await this.provider.analyze(legacyInput);\n\n      // Convert legacy TagResponse to ITagResponse\n      const response: ITagResponse = this.convertTagResponse(legacyResponse);\n\n      this.logger.info('Email analysis completed', {\n        providerId: this.providerId,\n        tagCount: response.tags.length,\n        confidence: response.confidence,\n      });\n\n      return response;\n    } catch (error) {\n      this.logger.error('Email analysis failed', {\n        providerId: this.providerId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  // ========================================================================\n  // Type Conversion Methods\n  // ========================================================================\n\n  /**\n   * Converts IProviderSettings to BaseProviderSettings.\n   *\n   * @param settings - IProviderSettings to convert\n   * @returns BaseProviderSettings\n   */\n  private convertSettings(settings: IProviderSettings): BaseProviderSettings {\n    if (!isIProviderSettings(settings)) {\n      throw new Error('Invalid settings provided');\n    }\n\n    const baseSettings: BaseProviderSettings = {\n      apiKey: settings.apiKey,\n      apiUrl: settings.apiUrl,\n      model: settings.model,\n    };\n\n    // Copy any additional properties\n    for (const [key, value] of Object.entries(settings)) {\n      if (!['apiKey', 'apiUrl', 'model'].includes(key)) {\n        baseSettings[key as keyof BaseProviderSettings] = value as never;\n      }\n    }\n\n    return baseSettings;\n  }\n\n  /**\n   * Converts IAnalyzeInput to LegacyAnalyzeInput.\n   *\n   * @param input - IAnalyzeInput to convert\n   * @returns LegacyAnalyzeInput\n   */\n  private convertAnalyzeInput(input: IAnalyzeInput): LegacyAnalyzeInput {\n    if (!isIProviderSettings(input.settings)) {\n      throw new Error('Invalid settings provided in analyze input');\n    }\n\n    // Convert IStructuredEmailData to StructuredEmailData\n    const structuredData = this.convertStructuredEmailData(input.data);\n\n    // Convert ICustomTag[] to CustomTags\n    const customTags = this.convertCustomTags(input.tags);\n\n    return {\n      settings: this.convertSettings(input.settings),\n      structuredData,\n      customTags,\n    };\n  }\n\n  /**\n   * Converts IStructuredEmailData to StructuredEmailData from legacy.\n   *\n   * @param data - IStructuredEmailData to convert\n   * @returns Legacy StructuredEmailData\n   */\n  private convertStructuredEmailData(data: IStructuredEmailData): {\n    headers: Record<string, string>;\n    body: string;\n    attachments: Array<{ name: string; mimeType: string; size: number }>;\n  } {\n    return {\n      headers: { ...data.headers },\n      body: data.body,\n      attachments: data.attachments.map((attachment) => {\n        if (!isIAttachment(attachment)) {\n          throw new Error('Invalid attachment provided');\n        }\n        return {\n          name: attachment.name,\n          mimeType: attachment.mimeType,\n          size: attachment.size,\n        };\n      }),\n    };\n  }\n\n  /**\n   * Converts ICustomTag[] to CustomTags from legacy.\n   *\n   * @param tags - ICustomTag array to convert\n   * @returns Legacy CustomTags\n   */\n  private convertCustomTags(tags: ICustomTag[]): Tag[] {\n    return tags.map((tag) => {\n      if (!isICustomTag(tag)) {\n        throw new Error('Invalid custom tag provided');\n      }\n      return {\n        key: tag.key,\n        name: tag.name,\n        color: '#9E9E9E', // Default gray color for custom tags\n        prompt: tag.description, // description maps to prompt in legacy\n      };\n    });\n  }\n\n  /**\n   * Converts legacy TagResponse to ITagResponse.\n   *\n   * @param response - Legacy TagResponse\n   * @returns ITagResponse\n   */\n  private convertTagResponse(response: {\n    tags: string[];\n    confidence: number;\n    reasoning: string;\n    [key: string]: unknown;\n  }): ITagResponse {\n    return {\n      tags: response.tags,\n      confidence: response.confidence,\n      confidence_score: Math.round(response.confidence * 100),\n      reasoning: response.reasoning,\n      // Extract known optional fields if present\n      is_scam: response.is_scam as boolean | undefined,\n      sender: response.sender as string | undefined,\n      sender_consistent: response.sender_consistent as boolean | null | undefined,\n      spf_pass: response.spf_pass as boolean | null | undefined,\n      dkim_pass: response.dkim_pass as boolean | null | undefined,\n    };\n  }\n}\n",
        "last_modified": "2026-01-05T19:59:00.208208"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.099746",
  "last_updated": "2026-01-05T14:48:03.103239"
}