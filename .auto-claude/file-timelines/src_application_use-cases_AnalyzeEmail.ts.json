{
  "file_path": "src/application/use-cases/AnalyzeEmail.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "/**\n * AnalyzeEmail Use Case\n *\n * Orchestrates email analysis by coordinating email retrieval, content extraction,\n * AI provider analysis, caching, and tag application.\n *\n * This use case implements the complete email analysis workflow:\n * 1. Retrieves email from Thunderbird via IMailReader\n * 2. Extracts structured content via EmailContentExtractor\n * 3. Checks cache for cached analysis results\n * 4. Performs AI analysis via Provider (if cache miss)\n * 5. Caches the analysis result\n * 6. Applies tags to the message via ITagManager\n *\n * @module application/use-cases/AnalyzeEmail\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { IMailReader } from '@/infrastructure/interfaces/IMailReader';\nimport type { ITagManager } from '@/infrastructure/interfaces/ITagManager';\nimport type { IProvider } from '@/infrastructure/interfaces/IProvider';\nimport type { ICache } from '@/infrastructure/interfaces/ICache';\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IEmailMessage } from '@/infrastructure/interfaces/IMailReader';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\nimport type { IQueue } from '@/infrastructure/interfaces/IQueue';\nimport type {\n  ITagResponse,\n  IProviderSettings,\n  IStructuredEmailData,\n} from '@/infrastructure/interfaces/IProvider';\nimport { EmailContentExtractor } from '@/domain/services/EmailContentExtractor';\nimport { ProviderFactory } from '@/infrastructure/providers/ProviderFactory';\nimport { EventBus } from '@/domain/events/EventBus';\nimport { createEmailAnalyzedEvent } from '@/domain/events/EmailAnalyzedEvent';\nimport { createProviderErrorEvent } from '@/domain/events/ProviderErrorEvent';\n\n// ============================================================================\n// Browser-compatible Crypto Utilities\n// ============================================================================\n\n/**\n * SHA-256 hash function using Web Crypto API (browser-compatible).\n *\n * @param message - String to hash\n * @returns Promise resolving to hex-encoded SHA-256 hash\n * @throws {Error} If Web Crypto API is not available\n */\nasync function sha256(message: string): Promise<string> {\n  // Get crypto.subtle from global window or self (for Web Workers)\n  const subtleCrypto =\n    (typeof window !== 'undefined' && window.crypto?.subtle) ||\n    (typeof self !== 'undefined' && self.crypto?.subtle);\n\n  if (!subtleCrypto) {\n    throw new Error('Web Crypto API (crypto.subtle) is not available in this environment');\n  }\n\n  const msgBuffer = new TextEncoder().encode(message);\n  const hashBuffer = await subtleCrypto.digest('SHA-256', msgBuffer);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n}\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Result of email analysis including tags and metadata.\n */\nexport interface AnalyzeEmailResult extends ITagResponse {\n  /** The message ID that was analyzed */\n  messageId: string;\n  /** Cache key for this analysis (SHA-256 hash) */\n  cacheKey: string;\n  /** Whether result was retrieved from cache */\n  fromCache: boolean;\n  /** Number of tags applied */\n  tagsApplied: number;\n}\n\n/**\n * Configuration for email analysis.\n */\nexport interface AnalyzeEmailConfig {\n  /** Cache TTL in milliseconds (default: 24 hours) */\n  cacheTtl?: number;\n  /** Whether to force re-analysis (bypass cache) */\n  forceReanalyze?: boolean;\n  /** Whether to apply tags after analysis (default: true) */\n  applyTags?: boolean;\n  /** Custom tags to use for analysis (optional) */\n  customTags?: Array<{ key: string; name: string; description: string }>;\n  /** AbortSignal for cancelling the analysis */\n  signal?: AbortSignal;\n}\n\n// ============================================================================\n// Use Case Implementation\n// ============================================================================\n\n/**\n * AnalyzeEmail Use Case\n *\n * Orchestrates the complete email analysis workflow.\n * Uses dependency injection for all dependencies.\n *\n * @example\n * ```typescript\n * const useCase = container.resolve<AnalyzeEmail>(AnalyzeEmail);\n * const result = await useCase.execute('12345', {\n *   apiKey: 'sk-...',\n *   provider: 'openai',\n *   model: 'gpt-4'\n * });\n * console.log(`Analyzed email, tags: ${result.tags.join(', ')}`);\n * ```\n */\n@injectable()\nexport class AnalyzeEmail {\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor(\n    @inject('IMailReader') private readonly mailReader: IMailReader,\n    @inject('ITagManager') private readonly tagManager: ITagManager,\n    @inject('ProviderFactory') private readonly providerFactory: ProviderFactory,\n    @inject('ICache') private readonly cache: ICache,\n    @inject('ILogger') private readonly logger: ILogger,\n    @inject(EmailContentExtractor) private readonly contentExtractor: EmailContentExtractor,\n    @inject(EventBus) private readonly eventBus: EventBus,\n    @inject('IConfigRepository') private readonly configRepository: IConfigRepository,\n    @inject('IQueue') private readonly queue: IQueue\n  ) {\n    this.logger.debug('\u2705 AnalyzeEmail use case initialized');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Executes email analysis for a single message.\n   *\n   * @param messageId - Thunderbird message ID (as string for flexibility)\n   * @param providerSettings - Provider configuration (including providerId)\n   * @param config - Optional analysis configuration\n   * @returns Promise resolving to analysis result with tags\n   *\n   * @throws {Error} If message cannot be retrieved\n   * @throws {Error} If content extraction fails\n   * @throws {Error} If provider analysis fails\n   * @throws {Error} If tag application fails\n   *\n   * @example\n   * ```typescript\n   * const result = await analyzeEmail.execute('12345', {\n   *   provider: 'openai',\n   *   apiKey: 'sk-...',\n   *   model: 'gpt-4'\n   * }, { applyTags: true });\n   * ```\n   */\n  async execute(\n    messageId: string,\n    providerSettings: IProviderSettings,\n    config: AnalyzeEmailConfig = {}\n  ): Promise<ITagResponse> {\n    const {\n      cacheTtl = 24 * 60 * 60 * 1000, // 24 hours default\n      forceReanalyze = false,\n      applyTags = true,\n      customTags,\n    } = config;\n\n    const providerId = (providerSettings.provider as string) ?? 'unknown';\n    this.logger.info('\ud83d\ude80 Starting email analysis', {\n      messageId,\n      providerId,\n      config: { forceReanalyze, applyTags },\n    });\n\n    const startTime = Date.now();\n\n    this.logger.debug('\ud83d\udccb Analysis configuration', {\n      cacheTtl: `${cacheTtl / 1000 / 60 / 60}h`,\n      forceReanalyze,\n      applyTags,\n      hasCustomTags: customTags !== undefined,\n      customTagsCount: customTags?.length ?? 0,\n    });\n\n    try {\n      // Step 1: Retrieve email from Thunderbird\n      this.logger.debug('\u27a1\ufe0f  Step 1: Retrieving email from Thunderbird');\n      const email = await this.retrieveEmail(messageId);\n      this.logger.debug('\u2705 Step 1 complete: Email retrieved');\n\n      // Step 2: Extract structured content\n      this.logger.debug('\u27a1\ufe0f  Step 2: Extracting structured content');\n      const structuredData = this.extractEmailContent(email);\n      this.logger.debug('\u2705 Step 2 complete: Content extracted', {\n        bodyLength: structuredData.body.length,\n        attachmentCount: structuredData.attachments.length,\n      });\n\n      // Step 3: Load custom tags from ConfigRepository if not provided\n      this.logger.debug('\u27a1\ufe0f  Step 3: Loading custom tags', {\n        hasCustomTags: customTags !== undefined,\n      });\n      const tagsToUse = customTags ?? (await this.loadCustomTags());\n      this.logger.debug('\u2705 Step 3 complete: Tags loaded', { tagCount: tagsToUse.length });\n\n      // Step 4: Generate cache key\n      this.logger.debug('\u27a1\ufe0f  Step 4: Generating cache key');\n      const cacheKey = await this.generateCacheKey(email, providerSettings);\n      this.logger.debug('\u2705 Step 4 complete: Cache key generated', {\n        cacheKey: cacheKey.substring(0, 16) + '...',\n      });\n\n      // Step 5: Check cache (unless force re-analysis)\n      if (!forceReanalyze) {\n        this.logger.debug('\u27a1\ufe0f  Step 5: Checking cache');\n        const cachedResult = await this.checkCache(cacheKey);\n        if (cachedResult) {\n          this.logger.info('\u2705 Cache HIT - Retrieved analysis from cache', { cacheKey });\n\n          if (applyTags) {\n            this.logger.debug('\u27a1\ufe0f  Applying cached tags to email');\n            await this.applyTagsToEmail(messageId, cachedResult.tags);\n            this.logger.debug('\u2705 Cached tags applied');\n          }\n\n          // Publish EmailAnalyzedEvent (from cache)\n          this.logger.debug('\u27a1\ufe0f  Publishing EmailAnalyzedEvent (from cache)');\n          await this.eventBus.publish(\n            createEmailAnalyzedEvent(\n              messageId,\n              providerSettings.provider as string,\n              providerSettings.model as string,\n              cachedResult,\n              {\n                fromCache: true,\n                cacheKey,\n                duration: Date.now() - startTime,\n              }\n            )\n          );\n\n          this.logger.info('\u2705 Analysis completed from cache', {\n            duration: `${Date.now() - startTime}ms`,\n            tagsFound: cachedResult.tags.length,\n          });\n          return cachedResult;\n        }\n        this.logger.debug('\u26a0\ufe0f  Cache MISS - No cached result found');\n      } else {\n        this.logger.debug('\u23ed\ufe0f  Skipping cache check (forceReanalyze=true)');\n      }\n\n      // Step 6: Get provider from factory (if providerId is specified)\n      this.logger.debug('\u27a1\ufe0f  Step 6: Getting provider from factory');\n      const provider = this.getProvider(providerSettings);\n      this.logger.debug('\u2705 Step 6 complete: Provider retrieved');\n\n      // Step 7: Perform AI analysis\n      this.logger.debug('\u27a1\ufe0f  Step 7: Performing AI analysis');\n      const analysisResult = await this.analyzeWithProvider(\n        structuredData,\n        providerSettings,\n        tagsToUse,\n        provider\n      );\n      this.logger.debug('\u2705 Step 7 complete: AI analysis finished', {\n        tagsFound: analysisResult.tags.length,\n        confidence: analysisResult.confidence,\n      });\n\n      // Step 8: Cache the result\n      this.logger.debug('\u27a1\ufe0f  Step 8: Caching result');\n      await this.cacheResult(cacheKey, analysisResult, cacheTtl);\n      this.logger.debug('\u2705 Step 8 complete: Result cached');\n\n      // Step 9: Apply tags to the message\n      if (applyTags) {\n        this.logger.debug('\u27a1\ufe0f  Step 9: Applying tags to message');\n        await this.applyTagsToEmail(messageId, analysisResult.tags);\n        this.logger.debug('\u2705 Step 9 complete: Tags applied');\n      } else {\n        this.logger.debug('\u23ed\ufe0f  Skipping tag application (applyTags=false)');\n      }\n\n      // Publish EmailAnalyzedEvent\n      this.logger.debug('\u27a1\ufe0f  Publishing EmailAnalyzedEvent (new analysis)');\n      await this.eventBus.publish(\n        createEmailAnalyzedEvent(\n          messageId,\n          providerSettings.provider as string,\n          providerSettings.model as string,\n          analysisResult,\n          {\n            fromCache: false,\n            cacheKey,\n            duration: Date.now() - startTime,\n          }\n        )\n      );\n\n      this.logger.info('\u2705 Email analysis completed successfully', {\n        messageId,\n        tags: analysisResult.tags,\n        confidence: analysisResult.confidence,\n        duration: `${Date.now() - startTime}ms`,\n      });\n\n      return analysisResult;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Email analysis failed', { messageId, error: errorMessage });\n\n      // Publish ProviderErrorEvent\n      await this.eventBus.publish(\n        createProviderErrorEvent(\n          providerSettings.provider as string,\n          providerSettings.model as string,\n          errorMessage,\n          {\n            messageId,\n            error: error instanceof Error ? error : undefined,\n            errorType: 'api_error',\n          }\n        )\n      );\n\n      throw new Error(`Failed to analyze email ${messageId}: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods\n  // ==========================================================================\n\n  /**\n   * Loads custom tags from ConfigRepository.\n   *\n   * @returns Array of custom tags for analysis\n   */\n  private async loadCustomTags(): Promise<\n    Array<{ key: string; name: string; description: string }>\n  > {\n    this.logger.debug('\ud83d\udd0d Loading custom tags from ConfigRepository');\n    try {\n      const customTags = await this.configRepository.getCustomTags();\n      const mappedTags = customTags.map((tag) => ({\n        key: tag.key,\n        name: tag.name,\n        description: tag.prompt ?? '',\n      }));\n      this.logger.debug('\u2705 Custom tags loaded from ConfigRepository', {\n        count: mappedTags.length,\n      });\n      return mappedTags;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('\u26a0\ufe0f  Failed to load custom tags from ConfigRepository, using empty array', {\n        error: errorMessage,\n      });\n      return [];\n    }\n  }\n\n  /**\n   * Retrieves email from Thunderbird.\n   *\n   * @param messageId - Message ID to retrieve\n   * @returns Complete email message\n   * @throws {Error} If message cannot be retrieved\n   */\n  private async retrieveEmail(messageId: string): Promise<IEmailMessage> {\n    this.logger.debug('\ud83d\udcec Retrieving email from Thunderbird', { messageId });\n\n    try {\n      const messageIdNum = parseInt(messageId, 10);\n      if (isNaN(messageIdNum)) {\n        throw new Error(`Invalid message ID: ${messageId}`);\n      }\n\n      const email = await this.mailReader.getFullMessage(messageIdNum);\n\n      if (!email) {\n        throw new Error(`Email not found: ${messageId}`);\n      }\n\n      this.logger.debug('\u2705 Email retrieved successfully', {\n        messageId,\n        subject: email.subject,\n        from: email.from,\n      });\n\n      return email;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to retrieve email', { messageId, error: errorMessage });\n      throw error;\n    }\n  }\n\n  /**\n   * Extracts structured content from email.\n   *\n   * @param email - Email message to extract from\n   * @returns Structured email data for AI analysis\n   * @throws {Error} If content extraction fails\n   */\n  private extractEmailContent(email: IEmailMessage): IStructuredEmailData {\n    this.logger.debug('\ud83d\udcc4 Extracting email content', { messageId: email.id });\n\n    try {\n      // Parse email parts if available\n      let body = email.body || '';\n      const attachments: IAttachment[] = [];\n\n      if (email.parts && email.parts.length > 0) {\n        this.logger.debug('\ud83d\udcce Processing email parts', { partCount: email.parts.length });\n        const parsed = this.contentExtractor.findEmailParts(email.parts);\n        body = parsed.body;\n        parsed.attachments.forEach((att) => {\n          attachments.push({\n            name: att.name,\n            mimeType: att.mimeType,\n            size: att.size,\n          });\n        });\n        this.logger.debug('\u2705 Email parts processed', {\n          bodyLength: body.length,\n          attachmentCount: attachments.length,\n        });\n      }\n\n      // Also check direct attachments\n      if (email.attachments && email.attachments.length > 0) {\n        this.logger.debug('\ud83d\udcce Processing direct attachments', {\n          attachmentCount: email.attachments.length,\n        });\n        email.attachments.forEach((att) => {\n          if (!attachments.some((a) => a.name === att.name)) {\n            attachments.push({\n              name: att.name,\n              mimeType: att.mimeType,\n              size: att.size,\n            });\n          }\n        });\n      }\n\n      const structuredData: IStructuredEmailData = {\n        headers: email.headers || {},\n        body,\n        attachments,\n      };\n\n      this.logger.debug('\u2705 Email content extracted', {\n        bodyLength: body.length,\n        attachmentsCount: attachments.length,\n      });\n\n      return structuredData;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to extract email content', {\n        messageId: email.id,\n        error: errorMessage,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Generates cache key from email content and provider settings.\n   *\n   * Uses SHA-256 hash of email headers + body + provider ID + model.\n   *\n   * @param email - Email message\n   * @param providerSettings - Provider settings\n   * @returns Promise resolving to SHA-256 hash as cache key\n   */\n  private async generateCacheKey(\n    email: IEmailMessage,\n    providerSettings: IProviderSettings\n  ): Promise<string> {\n    const keyData = JSON.stringify({\n      subject: email.subject,\n      from: email.from,\n      to: email.to,\n      body: email.body,\n      providerId: providerSettings.provider,\n      model: providerSettings.model,\n    });\n\n    const hash = await sha256(keyData);\n    this.logger.debug('\ud83d\udd10 Generated cache key', { hash: hash.substring(0, 16) + '...' });\n\n    return hash;\n  }\n\n  /**\n   * Checks cache for existing analysis result.\n   *\n   * @param cacheKey - Cache key to check\n   * @returns Cached result or null if not found\n   */\n  private async checkCache(cacheKey: string): Promise<ITagResponse | null> {\n    this.logger.debug('\ud83d\udcbe Checking cache', { cacheKey: cacheKey.substring(0, 16) + '...' });\n\n    try {\n      const cached = await this.cache.get<ITagResponse>(cacheKey);\n      if (cached) {\n        this.logger.debug('\u2705 Cache HIT', { cacheKey: cacheKey.substring(0, 16) + '...' });\n        return cached;\n      }\n\n      this.logger.debug('\u26a0\ufe0f  Cache MISS', { cacheKey: cacheKey.substring(0, 16) + '...' });\n      return null;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('\u26a0\ufe0f  Failed to check cache', {\n        cacheKey: cacheKey.substring(0, 16) + '...',\n        error: errorMessage,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Gets provider instance from factory.\n   *\n   * @param providerSettings - Provider settings with providerId\n   * @returns Provider instance\n   * @throws {Error} If provider cannot be resolved\n   */\n  private getProvider(providerSettings: IProviderSettings): IProvider {\n    const providerId = providerSettings.provider as string;\n    if (!providerId) {\n      throw new Error('Provider ID not specified in provider settings');\n    }\n\n    this.logger.debug('\ud83c\udfed Getting provider from factory', { providerId });\n\n    try {\n      return this.providerFactory.getProvider(providerId);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to get provider', { providerId, error: errorMessage });\n      throw error;\n    }\n  }\n\n  /**\n   * Performs AI analysis with provider.\n   *\n   * @param structuredData - Structured email data\n   * @param providerSettings - Provider settings\n   * @param customTags - Custom tag definitions\n   * @param provider - Provider instance\n   * @returns Analysis result with tags\n   * @throws {Error} If analysis fails\n   */\n  private async analyzeWithProvider(\n    structuredData: IStructuredEmailData,\n    providerSettings: IProviderSettings,\n    customTags: Array<{ key: string; name: string; description: string }>,\n    provider: IProvider\n  ): Promise<ITagResponse> {\n    this.logger.debug('\ud83e\udd16 Starting provider analysis', {\n      providerId: provider.providerId,\n      tagCount: customTags.length,\n    });\n\n    try {\n      // Validate provider settings\n      const isValid = await provider.validateSettings(providerSettings);\n      if (!isValid) {\n        throw new Error(`Invalid provider settings for ${provider.providerId}`);\n      }\n      this.logger.debug('\u2705 Provider settings validated');\n\n      // Build analysis input\n      const analysisInput = {\n        settings: providerSettings,\n        data: structuredData,\n        tags: customTags.map((tag) => ({\n          key: tag.key,\n          name: tag.name,\n          description: tag.description,\n        })),\n      };\n\n      this.logger.debug('\u27a1\ufe0f  Calling provider.analyze() with input', {\n        bodyLength: structuredData.body.length,\n        tags: customTags.map((t) => t.key),\n      });\n\n      // Perform analysis\n      const result = await provider.analyze(analysisInput);\n\n      this.logger.debug('\u2705 Provider analysis completed', {\n        providerId: provider.providerId,\n        tags: result.tags,\n        confidence: result.confidence,\n      });\n\n      return result;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Provider analysis failed', {\n        providerId: provider.providerId,\n        error: errorMessage,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Caches analysis result.\n   *\n   * @param cacheKey - Cache key\n   * @param result - Analysis result to cache\n   * @param ttl - Time-to-live in milliseconds\n   */\n  private async cacheResult(cacheKey: string, result: ITagResponse, ttl: number): Promise<void> {\n    this.logger.debug('\ud83d\udcbe Caching analysis result', {\n      cacheKey: cacheKey.substring(0, 16) + '...',\n      ttl: `${ttl / 1000 / 60}min`,\n    });\n\n    try {\n      await this.cache.set(cacheKey, result, ttl);\n      this.logger.debug('\u2705 Analysis result cached', {\n        cacheKey: cacheKey.substring(0, 16) + '...',\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('\u26a0\ufe0f  Failed to cache result', {\n        cacheKey: cacheKey.substring(0, 16) + '...',\n        error: errorMessage,\n      });\n      // Non-fatal error, continue execution\n    }\n  }\n\n  /**\n   * Applies tags to email message.\n   *\n   * @param messageId - Message ID to apply tags to\n   * @param tagKeys - Tag keys to apply\n   * @throws {Error} If tag application fails\n   */\n  private async applyTagsToEmail(messageId: string, tagKeys: string[]): Promise<void> {\n    this.logger.debug('\ud83c\udff7\ufe0f  Applying tags to email', { messageId, tagKeys });\n\n    try {\n      const messageIdNum = parseInt(messageId, 10);\n      if (isNaN(messageIdNum)) {\n        throw new Error(`Invalid message ID: ${messageId}`);\n      }\n\n      await this.tagManager.setTagsOnMessage(messageIdNum, tagKeys);\n\n      this.logger.debug('\u2705 Tags applied successfully', { messageId, count: tagKeys.length });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to apply tags', { messageId, tagKeys, error: errorMessage });\n      throw error;\n    }\n  }\n}\n\n// ============================================================================\n// Helper Types\n// ============================================================================\n\n/**\n * Attachment interface for AI analysis.\n */\ninterface IAttachment {\n  name: string;\n  mimeType: string;\n  size: number;\n}\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * AnalyzeEmail Use Case\n *\n * Orchestrates email analysis by coordinating email retrieval, content extraction,\n * AI provider analysis, caching, and tag application.\n *\n * This use case implements the complete email analysis workflow:\n * 1. Retrieves email from Thunderbird via IMailReader\n * 2. Extracts structured content via EmailContentExtractor\n * 3. Checks cache for cached analysis results\n * 4. Performs AI analysis via Provider (if cache miss)\n * 5. Caches the analysis result\n * 6. Applies tags to the message via ITagManager\n *\n * @module application/use-cases/AnalyzeEmail\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { IMailReader } from '@/infrastructure/interfaces/IMailReader';\nimport type { ITagManager } from '@/infrastructure/interfaces/ITagManager';\nimport type { IProvider } from '@/infrastructure/interfaces/IProvider';\nimport type { ICache } from '@/infrastructure/interfaces/ICache';\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IEmailMessage } from '@/infrastructure/interfaces/IMailReader';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\nimport type { IQueue } from '@/infrastructure/interfaces/IQueue';\nimport type {\n  ITagResponse,\n  IProviderSettings,\n  IStructuredEmailData,\n} from '@/infrastructure/interfaces/IProvider';\nimport { EmailContentExtractor } from '@/domain/services/EmailContentExtractor';\nimport { ProviderFactory } from '@/infrastructure/providers/ProviderFactory';\nimport { EventBus } from '@/domain/events/EventBus';\nimport { createEmailAnalyzedEvent } from '@/domain/events/EmailAnalyzedEvent';\nimport { createProviderErrorEvent } from '@/domain/events/ProviderErrorEvent';\nimport { ApplyTagsToEmail } from '@/application/use-cases/ApplyTagsToEmail';\n\n// ============================================================================\n// Browser-compatible Crypto Utilities\n// ============================================================================\n\n/**\n * SHA-256 hash function using Web Crypto API (browser-compatible).\n *\n * @param message - String to hash\n * @returns Promise resolving to hex-encoded SHA-256 hash\n * @throws {Error} If Web Crypto API is not available\n */\nasync function sha256(message: string): Promise<string> {\n  // Get crypto.subtle from global window or self (for Web Workers)\n  const subtleCrypto =\n    (typeof window !== 'undefined' && window.crypto?.subtle) ||\n    (typeof self !== 'undefined' && self.crypto?.subtle);\n\n  if (!subtleCrypto) {\n    throw new Error('Web Crypto API (crypto.subtle) is not available in this environment');\n  }\n\n  const msgBuffer = new TextEncoder().encode(message);\n  const hashBuffer = await subtleCrypto.digest('SHA-256', msgBuffer);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');\n}\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Result of email analysis including tags and metadata.\n */\nexport interface AnalyzeEmailResult extends ITagResponse {\n  /** The message ID that was analyzed */\n  messageId: string;\n  /** Cache key for this analysis (SHA-256 hash) */\n  cacheKey: string;\n  /** Whether result was retrieved from cache */\n  fromCache: boolean;\n  /** Number of tags applied */\n  tagsApplied: number;\n}\n\n/**\n * Configuration for email analysis.\n */\nexport interface AnalyzeEmailConfig {\n  /** Cache TTL in milliseconds (default: 24 hours) */\n  cacheTtl?: number;\n  /** Whether to force re-analysis (bypass cache) */\n  forceReanalyze?: boolean;\n  /** Whether to apply tags after analysis (default: true) */\n  applyTags?: boolean;\n  /** Custom tags to use for analysis (optional) */\n  customTags?: Array<{ key: string; name: string; description: string }>;\n  /** AbortSignal for cancelling the analysis */\n  signal?: AbortSignal;\n}\n\n// ============================================================================\n// Use Case Implementation\n// ============================================================================\n\n/**\n * AnalyzeEmail Use Case\n *\n * Orchestrates the complete email analysis workflow.\n * Uses dependency injection for all dependencies.\n *\n * @example\n * ```typescript\n * const useCase = container.resolve<AnalyzeEmail>(AnalyzeEmail);\n * const result = await useCase.execute('12345', {\n *   apiKey: 'sk-...',\n *   provider: 'openai',\n *   model: 'gpt-4'\n * });\n * console.log(`Analyzed email, tags: ${result.tags.join(', ')}`);\n * ```\n */\n@injectable()\nexport class AnalyzeEmail {\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor(\n    @inject('IMailReader') private readonly mailReader: IMailReader,\n    @inject('ITagManager') private readonly tagManager: ITagManager,\n    @inject('ProviderFactory') private readonly providerFactory: ProviderFactory,\n    @inject('ICache') private readonly cache: ICache,\n    @inject('ILogger') private readonly logger: ILogger,\n    @inject(EmailContentExtractor) private readonly contentExtractor: EmailContentExtractor,\n    @inject(EventBus) private readonly eventBus: EventBus,\n    @inject('IConfigRepository') private readonly configRepository: IConfigRepository,\n    @inject('IQueue') private readonly queue: IQueue,\n    @inject(ApplyTagsToEmail) private readonly applyTagsToEmail: ApplyTagsToEmail\n  ) {\n    this.logger.debug('\u2705 AnalyzeEmail use case initialized');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Executes email analysis for a single message.\n   *\n   * @param messageId - Thunderbird message ID (as string for flexibility)\n   * @param providerSettings - Provider configuration (including providerId)\n   * @param config - Optional analysis configuration\n   * @returns Promise resolving to analysis result with tags\n   *\n   * @throws {Error} If message cannot be retrieved\n   * @throws {Error} If content extraction fails\n   * @throws {Error} If provider analysis fails\n   * @throws {Error} If tag application fails\n   *\n   * @example\n   * ```typescript\n   * const result = await analyzeEmail.execute('12345', {\n   *   provider: 'openai',\n   *   apiKey: 'sk-...',\n   *   model: 'gpt-4'\n   * }, { applyTags: true });\n   * ```\n   */\n  async execute(\n    messageId: string,\n    providerSettings: IProviderSettings,\n    config: AnalyzeEmailConfig = {}\n  ): Promise<ITagResponse> {\n    const {\n      cacheTtl = 24 * 60 * 60 * 1000, // 24 hours default\n      forceReanalyze = false,\n      applyTags = true,\n      customTags,\n    } = config;\n\n    const providerId = (providerSettings.provider as string) ?? 'unknown';\n    this.logger.info('\ud83d\ude80 Starting email analysis', {\n      messageId,\n      providerId,\n      config: { forceReanalyze, applyTags },\n    });\n\n    const startTime = Date.now();\n\n    this.logger.debug('\ud83d\udccb Analysis configuration', {\n      cacheTtl: `${cacheTtl / 1000 / 60 / 60}h`,\n      forceReanalyze,\n      applyTags,\n      hasCustomTags: customTags !== undefined,\n      customTagsCount: customTags?.length ?? 0,\n    });\n\n    try {\n      // Step 1: Retrieve email from Thunderbird\n      this.logger.debug('\u27a1\ufe0f  Step 1: Retrieving email from Thunderbird');\n      const email = await this.retrieveEmail(messageId);\n      this.logger.debug('\u2705 Step 1 complete: Email retrieved');\n\n      // Step 2: Extract structured content\n      this.logger.debug('\u27a1\ufe0f  Step 2: Extracting structured content');\n      const structuredData = this.extractEmailContent(email);\n      this.logger.debug('\u2705 Step 2 complete: Content extracted', {\n        bodyLength: structuredData.body.length,\n        attachmentCount: structuredData.attachments.length,\n      });\n\n      // Step 3: Load custom tags from ConfigRepository if not provided\n      this.logger.debug('\u27a1\ufe0f  Step 3: Loading custom tags', {\n        hasCustomTags: customTags !== undefined,\n      });\n      const tagsToUse = customTags ?? (await this.loadCustomTags());\n      this.logger.debug('\u2705 Step 3 complete: Tags loaded', { tagCount: tagsToUse.length });\n\n      // Step 4: Generate cache key\n      this.logger.debug('\u27a1\ufe0f  Step 4: Generating cache key');\n      const cacheKey = await this.generateCacheKey(email, providerSettings);\n      this.logger.debug('\u2705 Step 4 complete: Cache key generated', {\n        cacheKey: cacheKey.substring(0, 16) + '...',\n      });\n\n      // Step 5: Check cache (unless force re-analysis)\n      if (!forceReanalyze) {\n        this.logger.debug('\u27a1\ufe0f  Step 5: Checking cache');\n        const cachedResult = await this.checkCache(cacheKey);\n        if (cachedResult) {\n          this.logger.info('\u2705 Cache HIT - Retrieved analysis from cache', { cacheKey });\n\n          if (applyTags) {\n            this.logger.debug('\u27a1\ufe0f  Applying cached tags to email with confidence threshold filtering');\n            const applyResult = await this.applyTagsToEmail.applyTagsWithThreshold(\n              messageId,\n              cachedResult\n            );\n            this.logger.debug('\u2705 Cached tags applied with filtering', {\n              appliedCount: applyResult.appliedTags.length,\n              filteredCount: applyResult.filteredTags.manualReviewTags.length,\n            });\n          }\n\n          // Publish EmailAnalyzedEvent (from cache)\n          this.logger.debug('\u27a1\ufe0f  Publishing EmailAnalyzedEvent (from cache)');\n          await this.eventBus.publish(\n            createEmailAnalyzedEvent(\n              messageId,\n              providerSettings.provider as string,\n              providerSettings.model as string,\n              cachedResult,\n              {\n                fromCache: true,\n                cacheKey,\n                duration: Date.now() - startTime,\n              }\n            )\n          );\n\n          this.logger.info('\u2705 Analysis completed from cache', {\n            duration: `${Date.now() - startTime}ms`,\n            tagsFound: cachedResult.tags.length,\n          });\n          return cachedResult;\n        }\n        this.logger.debug('\u26a0\ufe0f  Cache MISS - No cached result found');\n      } else {\n        this.logger.debug('\u23ed\ufe0f  Skipping cache check (forceReanalyze=true)');\n      }\n\n      // Step 6: Get provider from factory (if providerId is specified)\n      this.logger.debug('\u27a1\ufe0f  Step 6: Getting provider from factory');\n      const provider = this.getProvider(providerSettings);\n      this.logger.debug('\u2705 Step 6 complete: Provider retrieved');\n\n      // Step 7: Perform AI analysis\n      this.logger.debug('\u27a1\ufe0f  Step 7: Performing AI analysis');\n      const analysisResult = await this.analyzeWithProvider(\n        structuredData,\n        providerSettings,\n        tagsToUse,\n        provider\n      );\n      this.logger.debug('\u2705 Step 7 complete: AI analysis finished', {\n        tagsFound: analysisResult.tags.length,\n        confidence: analysisResult.confidence,\n      });\n\n      // Step 8: Cache the result\n      this.logger.debug('\u27a1\ufe0f  Step 8: Caching result');\n      await this.cacheResult(cacheKey, analysisResult, cacheTtl);\n      this.logger.debug('\u2705 Step 8 complete: Result cached');\n\n      // Step 9: Apply tags to the message\n      if (applyTags) {\n        this.logger.debug('\u27a1\ufe0f  Step 9: Applying tags to message with confidence threshold filtering');\n        const applyResult = await this.applyTagsToEmail.applyTagsWithThreshold(\n          messageId,\n          analysisResult\n        );\n        this.logger.debug('\u2705 Step 9 complete: Tags applied with filtering', {\n          appliedCount: applyResult.appliedTags.length,\n          filteredCount: applyResult.filteredTags.manualReviewTags.length,\n        });\n      } else {\n        this.logger.debug('\u23ed\ufe0f  Skipping tag application (applyTags=false)');\n      }\n\n      // Publish EmailAnalyzedEvent\n      this.logger.debug('\u27a1\ufe0f  Publishing EmailAnalyzedEvent (new analysis)');\n      await this.eventBus.publish(\n        createEmailAnalyzedEvent(\n          messageId,\n          providerSettings.provider as string,\n          providerSettings.model as string,\n          analysisResult,\n          {\n            fromCache: false,\n            cacheKey,\n            duration: Date.now() - startTime,\n          }\n        )\n      );\n\n      this.logger.info('\u2705 Email analysis completed successfully', {\n        messageId,\n        tags: analysisResult.tags,\n        confidence: analysisResult.confidence,\n        duration: `${Date.now() - startTime}ms`,\n      });\n\n      return analysisResult;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Email analysis failed', { messageId, error: errorMessage });\n\n      // Publish ProviderErrorEvent\n      await this.eventBus.publish(\n        createProviderErrorEvent(\n          providerSettings.provider as string,\n          providerSettings.model as string,\n          errorMessage,\n          {\n            messageId,\n            error: error instanceof Error ? error : undefined,\n            errorType: 'api_error',\n          }\n        )\n      );\n\n      throw new Error(`Failed to analyze email ${messageId}: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods\n  // ==========================================================================\n\n  /**\n   * Loads custom tags from ConfigRepository.\n   *\n   * @returns Array of custom tags for analysis\n   */\n  private async loadCustomTags(): Promise<\n    Array<{ key: string; name: string; description: string }>\n  > {\n    this.logger.debug('\ud83d\udd0d Loading custom tags from ConfigRepository');\n    try {\n      const customTags = await this.configRepository.getCustomTags();\n      const mappedTags = customTags.map((tag) => ({\n        key: tag.key,\n        name: tag.name,\n        description: tag.prompt ?? '',\n      }));\n      this.logger.debug('\u2705 Custom tags loaded from ConfigRepository', {\n        count: mappedTags.length,\n      });\n      return mappedTags;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('\u26a0\ufe0f  Failed to load custom tags from ConfigRepository, using empty array', {\n        error: errorMessage,\n      });\n      return [];\n    }\n  }\n\n  /**\n   * Retrieves email from Thunderbird.\n   *\n   * @param messageId - Message ID to retrieve\n   * @returns Complete email message\n   * @throws {Error} If message cannot be retrieved\n   */\n  private async retrieveEmail(messageId: string): Promise<IEmailMessage> {\n    this.logger.debug('\ud83d\udcec Retrieving email from Thunderbird', { messageId });\n\n    try {\n      const messageIdNum = parseInt(messageId, 10);\n      if (isNaN(messageIdNum)) {\n        throw new Error(`Invalid message ID: ${messageId}`);\n      }\n\n      const email = await this.mailReader.getFullMessage(messageIdNum);\n\n      if (!email) {\n        throw new Error(`Email not found: ${messageId}`);\n      }\n\n      this.logger.debug('\u2705 Email retrieved successfully', {\n        messageId,\n        subject: email.subject,\n        from: email.from,\n      });\n\n      return email;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to retrieve email', { messageId, error: errorMessage });\n      throw error;\n    }\n  }\n\n  /**\n   * Extracts structured content from email.\n   *\n   * @param email - Email message to extract from\n   * @returns Structured email data for AI analysis\n   * @throws {Error} If content extraction fails\n   */\n  private extractEmailContent(email: IEmailMessage): IStructuredEmailData {\n    this.logger.debug('\ud83d\udcc4 Extracting email content', { messageId: email.id });\n\n    try {\n      // Parse email parts if available\n      let body = email.body || '';\n      const attachments: IAttachment[] = [];\n\n      if (email.parts && email.parts.length > 0) {\n        this.logger.debug('\ud83d\udcce Processing email parts', { partCount: email.parts.length });\n        const parsed = this.contentExtractor.findEmailParts(email.parts);\n        body = parsed.body;\n        parsed.attachments.forEach((att) => {\n          attachments.push({\n            name: att.name,\n            mimeType: att.mimeType,\n            size: att.size,\n          });\n        });\n        this.logger.debug('\u2705 Email parts processed', {\n          bodyLength: body.length,\n          attachmentCount: attachments.length,\n        });\n      }\n\n      // Also check direct attachments\n      if (email.attachments && email.attachments.length > 0) {\n        this.logger.debug('\ud83d\udcce Processing direct attachments', {\n          attachmentCount: email.attachments.length,\n        });\n        email.attachments.forEach((att) => {\n          if (!attachments.some((a) => a.name === att.name)) {\n            attachments.push({\n              name: att.name,\n              mimeType: att.mimeType,\n              size: att.size,\n            });\n          }\n        });\n      }\n\n      const structuredData: IStructuredEmailData = {\n        headers: email.headers || {},\n        body,\n        attachments,\n      };\n\n      this.logger.debug('\u2705 Email content extracted', {\n        bodyLength: body.length,\n        attachmentsCount: attachments.length,\n      });\n\n      return structuredData;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to extract email content', {\n        messageId: email.id,\n        error: errorMessage,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Generates cache key from email content and provider settings.\n   *\n   * Uses SHA-256 hash of email headers + body + provider ID + model.\n   *\n   * @param email - Email message\n   * @param providerSettings - Provider settings\n   * @returns Promise resolving to SHA-256 hash as cache key\n   */\n  private async generateCacheKey(\n    email: IEmailMessage,\n    providerSettings: IProviderSettings\n  ): Promise<string> {\n    const keyData = JSON.stringify({\n      subject: email.subject,\n      from: email.from,\n      to: email.to,\n      body: email.body,\n      providerId: providerSettings.provider,\n      model: providerSettings.model,\n    });\n\n    const hash = await sha256(keyData);\n    this.logger.debug('\ud83d\udd10 Generated cache key', { hash: hash.substring(0, 16) + '...' });\n\n    return hash;\n  }\n\n  /**\n   * Checks cache for existing analysis result.\n   *\n   * @param cacheKey - Cache key to check\n   * @returns Cached result or null if not found\n   */\n  private async checkCache(cacheKey: string): Promise<ITagResponse | null> {\n    this.logger.debug('\ud83d\udcbe Checking cache', { cacheKey: cacheKey.substring(0, 16) + '...' });\n\n    try {\n      const cached = await this.cache.get<ITagResponse>(cacheKey);\n      if (cached) {\n        this.logger.debug('\u2705 Cache HIT', { cacheKey: cacheKey.substring(0, 16) + '...' });\n        return cached;\n      }\n\n      this.logger.debug('\u26a0\ufe0f  Cache MISS', { cacheKey: cacheKey.substring(0, 16) + '...' });\n      return null;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('\u26a0\ufe0f  Failed to check cache', {\n        cacheKey: cacheKey.substring(0, 16) + '...',\n        error: errorMessage,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Gets provider instance from factory.\n   *\n   * @param providerSettings - Provider settings with providerId\n   * @returns Provider instance\n   * @throws {Error} If provider cannot be resolved\n   */\n  private getProvider(providerSettings: IProviderSettings): IProvider {\n    const providerId = providerSettings.provider as string;\n    if (!providerId) {\n      throw new Error('Provider ID not specified in provider settings');\n    }\n\n    this.logger.debug('\ud83c\udfed Getting provider from factory', { providerId });\n\n    try {\n      return this.providerFactory.getProvider(providerId);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Failed to get provider', { providerId, error: errorMessage });\n      throw error;\n    }\n  }\n\n  /**\n   * Performs AI analysis with provider.\n   *\n   * @param structuredData - Structured email data\n   * @param providerSettings - Provider settings\n   * @param customTags - Custom tag definitions\n   * @param provider - Provider instance\n   * @returns Analysis result with tags\n   * @throws {Error} If analysis fails\n   */\n  private async analyzeWithProvider(\n    structuredData: IStructuredEmailData,\n    providerSettings: IProviderSettings,\n    customTags: Array<{ key: string; name: string; description: string }>,\n    provider: IProvider\n  ): Promise<ITagResponse> {\n    this.logger.debug('\ud83e\udd16 Starting provider analysis', {\n      providerId: provider.providerId,\n      tagCount: customTags.length,\n    });\n\n    try {\n      // Validate provider settings\n      const isValid = await provider.validateSettings(providerSettings);\n      if (!isValid) {\n        throw new Error(`Invalid provider settings for ${provider.providerId}`);\n      }\n      this.logger.debug('\u2705 Provider settings validated');\n\n      // Build analysis input\n      const analysisInput = {\n        settings: providerSettings,\n        data: structuredData,\n        tags: customTags.map((tag) => ({\n          key: tag.key,\n          name: tag.name,\n          description: tag.description,\n        })),\n      };\n\n      this.logger.debug('\u27a1\ufe0f  Calling provider.analyze() with input', {\n        bodyLength: structuredData.body.length,\n        tags: customTags.map((t) => t.key),\n      });\n\n      // Perform analysis\n      const result = await provider.analyze(analysisInput);\n\n      this.logger.debug('\u2705 Provider analysis completed', {\n        providerId: provider.providerId,\n        tags: result.tags,\n        confidence: result.confidence,\n      });\n\n      return result;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.error('\u274c Provider analysis failed', {\n        providerId: provider.providerId,\n        error: errorMessage,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Caches analysis result.\n   *\n   * @param cacheKey - Cache key\n   * @param result - Analysis result to cache\n   * @param ttl - Time-to-live in milliseconds\n   */\n  private async cacheResult(cacheKey: string, result: ITagResponse, ttl: number): Promise<void> {\n    this.logger.debug('\ud83d\udcbe Caching analysis result', {\n      cacheKey: cacheKey.substring(0, 16) + '...',\n      ttl: `${ttl / 1000 / 60}min`,\n    });\n\n    try {\n      await this.cache.set(cacheKey, result, ttl);\n      this.logger.debug('\u2705 Analysis result cached', {\n        cacheKey: cacheKey.substring(0, 16) + '...',\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger.warn('\u26a0\ufe0f  Failed to cache result', {\n        cacheKey: cacheKey.substring(0, 16) + '...',\n        error: errorMessage,\n      });\n      // Non-fatal error, continue execution\n    }\n  }\n\n}\n\n// ============================================================================\n// Helper Types\n// ============================================================================\n\n/**\n * Attachment interface for AI analysis.\n */\ninterface IAttachment {\n  name: string;\n  mimeType: string;\n  size: number;\n}\n",
        "last_modified": "2026-01-05T19:59:00.205156"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.167336",
  "last_updated": "2026-01-05T14:48:03.170832"
}