{
  "file_path": "test/config-repository.test.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "/**\n * Unit tests for IndexedDBConfigRepository.\n */\n\nimport 'reflect-metadata';\nimport { describe, it, expect, vi, beforeEach, afterEach, expectTypeOf } from 'vitest';\nimport { IndexedDBConfigRepository } from '../src/infrastructure/repositories/IndexedDBConfigRepository';\nimport type { ILogger } from '../src/infrastructure/interfaces/ILogger';\nimport type {\n  IProviderSettings,\n  ICustomTag,\n  IAppConfig,\n} from '../src/infrastructure/interfaces/IConfigRepository';\n\n// === Mock Browser API ===\n\nfunction createMockBrowserStorage() {\n  const storage = new Map<string, Record<string, unknown>>();\n\n  return {\n    get: vi.fn(async (keys: string | string[] | Record<string, unknown> | null) => {\n      const result: Record<string, unknown> = {};\n\n      if (keys === null || typeof keys === 'string') {\n        if (keys === null || storage.has(keys)) {\n          const key = keys === null ? Array.from(storage.keys())[0] : keys;\n          if (key && storage.has(key)) {\n            result[key] = storage.get(key);\n          }\n        }\n      } else if (Array.isArray(keys)) {\n        for (const key of keys) {\n          if (storage.has(key)) {\n            result[key] = storage.get(key);\n          }\n        }\n      } else if (typeof keys === 'object') {\n        for (const key of Object.keys(keys)) {\n          if (storage.has(key)) {\n            result[key] = storage.get(key);\n          }\n        }\n      }\n\n      return result;\n    }),\n\n    set: vi.fn(async (items: Record<string, unknown>) => {\n      for (const [key, value] of Object.entries(items)) {\n        storage.set(key, value as Record<string, unknown>);\n      }\n    }),\n\n    clear: vi.fn(async () => {\n      storage.clear();\n    }),\n\n    _getStorage: () => storage,\n  };\n}\n\nfunction mockGlobalBrowserStorage() {\n  const mockStorage = createMockBrowserStorage();\n\n  (globalThis as unknown as Record<string, unknown>).browser = {\n    storage: {\n      local: {\n        get: mockStorage.get,\n        set: mockStorage.set,\n        clear: mockStorage.clear,\n      },\n    },\n  };\n\n  return mockStorage;\n}\n\n// === Test Fixtures ===\n\nfunction createMockLogger(): ILogger {\n  return {\n    debug: vi.fn(),\n    info: vi.fn(),\n    warn: vi.fn(),\n    error: vi.fn(),\n    maskApiKey: vi.fn((key?: string) =>\n      key ? `${key.slice(0, 7)}...${key.slice(-3)}` : 'not set'\n    ),\n  };\n}\n\nconst sampleProviderSettings: IProviderSettings = {\n  apiKey: 'sk-test-key-123',\n  model: 'gpt-4',\n  apiUrl: 'https://api.example.com/v1',\n  additionalConfig: {\n    temperature: 0.7,\n  },\n};\n\nconst sampleCustomTags: ICustomTag[] = [\n  {\n    key: 'is_advertise',\n    name: 'Advertisement',\n    color: '#FFC107',\n    prompt: 'Check if email is advertising something',\n  },\n  {\n    key: 'is_personal',\n    name: 'Personal',\n    color: '#4CAF50',\n    prompt: 'Check if this is personal email',\n  },\n];\n\nconst sampleAppConfig: IAppConfig = {\n  defaultProvider: 'openai',\n  enableNotifications: true,\n  enableLogging: true,\n  modelConcurrencyLimits: [\n    {\n      provider: 'openai',\n      model: 'gpt-4',\n      concurrency: 10,\n    },\n    {\n      provider: 'ollama',\n      concurrency: 5,\n    },\n  ],\n};\n\n// === Test Suite ===\n\ndescribe('IndexedDBConfigRepository', () => {\n  let repository: IndexedDBConfigRepository;\n  let mockLogger: ILogger;\n  let mockStorage: ReturnType<typeof createMockBrowserStorage>;\n\n  beforeEach(() => {\n    mockLogger = createMockLogger();\n    mockStorage = mockGlobalBrowserStorage();\n    repository = new IndexedDBConfigRepository(mockLogger);\n  });\n\n  afterEach(() => {\n    // Clean up global mock\n    delete (globalThis as unknown as Record<string, unknown>).browser;\n    delete (globalThis as unknown as Record<string, unknown>).chrome;\n  });\n\n  // === Provider Settings Tests ===\n\n  describe('Provider Settings', () => {\n    it('should set and get provider settings', async () => {\n      const providerId = 'openai';\n\n      await repository.setProviderSettings(providerId, sampleProviderSettings);\n      const retrieved = await repository.getProviderSettings(providerId);\n\n      expect(retrieved).toEqual(sampleProviderSettings);\n      expect(mockLogger.debug).toHaveBeenCalledWith(\n        `Saved provider settings for ${providerId}`,\n        expect.objectContaining({\n          providerId,\n          hasApiKey: true,\n          model: 'gpt-4',\n        })\n      );\n    });\n\n    it('should throw error when getting non-existent provider settings', async () => {\n      await expect(repository.getProviderSettings('nonexistent')).rejects.toThrow(\n        'Provider settings not found for provider: nonexistent'\n      );\n      expect(mockLogger.error).toHaveBeenCalled();\n    });\n\n    it('should get all provider settings', async () => {\n      const settings2: IProviderSettings = {\n        apiKey: 'ollama-key',\n        model: 'llama2',\n      };\n\n      await repository.setProviderSettings('openai', sampleProviderSettings);\n      await repository.setProviderSettings('ollama', settings2);\n\n      const allSettings = await repository.getAllProviderSettings();\n\n      expect(allSettings).toEqual({\n        openai: sampleProviderSettings,\n        ollama: settings2,\n      });\n    });\n\n    it('should return empty object when no provider settings exist', async () => {\n      const allSettings = await repository.getAllProviderSettings();\n\n      expect(allSettings).toEqual({});\n    });\n\n    it('should overwrite existing provider settings', async () => {\n      const providerId = 'openai';\n\n      await repository.setProviderSettings(providerId, sampleProviderSettings);\n\n      const updatedSettings: IProviderSettings = {\n        apiKey: 'new-key',\n        model: 'gpt-4-turbo',\n      };\n\n      await repository.setProviderSettings(providerId, updatedSettings);\n      const retrieved = await repository.getProviderSettings(providerId);\n\n      expect(retrieved).toEqual(updatedSettings);\n      expect(retrieved).not.toEqual(sampleProviderSettings);\n    });\n  });\n\n  // === Custom Tags Tests ===\n\n  describe('Custom Tags', () => {\n    it('should set and get custom tags', async () => {\n      await repository.setCustomTags(sampleCustomTags);\n      const retrieved = await repository.getCustomTags();\n\n      expect(retrieved).toEqual(sampleCustomTags);\n      expect(mockLogger.debug).toHaveBeenCalledWith('Saved 2 custom tags');\n    });\n\n    it('should return empty array when no custom tags exist', async () => {\n      const tags = await repository.getCustomTags();\n\n      expect(tags).toEqual([]);\n    });\n\n    it('should overwrite existing custom tags', async () => {\n      await repository.setCustomTags(sampleCustomTags);\n\n      const newTags: ICustomTag[] = [\n        {\n          key: 'new_tag',\n          name: 'New Tag',\n          color: '#123456',\n        },\n      ];\n\n      await repository.setCustomTags(newTags);\n      const retrieved = await repository.getCustomTags();\n\n      expect(retrieved).toEqual(newTags);\n      expect(retrieved).toHaveLength(1);\n    });\n\n    it('should handle empty custom tags array', async () => {\n      await repository.setCustomTags([]);\n      const tags = await repository.getCustomTags();\n\n      expect(tags).toEqual([]);\n    });\n  });\n\n  // === App Config Tests ===\n\n  describe('App Config', () => {\n    it('should set and get app config', async () => {\n      await repository.setAppConfig(sampleAppConfig);\n      const retrieved = await repository.getAppConfig();\n\n      expect(retrieved).toEqual(sampleAppConfig);\n      expect(mockLogger.debug).toHaveBeenCalledWith(\n        'Saved application config',\n        expect.objectContaining({\n          defaultProvider: 'openai',\n          enableNotifications: true,\n        })\n      );\n    });\n\n    it('should throw error when app config does not exist', async () => {\n      await expect(repository.getAppConfig()).rejects.toThrow(\n        'Application configuration not found'\n      );\n      expect(mockLogger.error).toHaveBeenCalled();\n    });\n\n    it('should update existing app config', async () => {\n      await repository.setAppConfig(sampleAppConfig);\n\n      const updatedConfig: IAppConfig = {\n        ...sampleAppConfig,\n        defaultProvider: 'ollama',\n        enableNotifications: false,\n      };\n\n      await repository.setAppConfig(updatedConfig);\n      const retrieved = await repository.getAppConfig();\n\n      expect(retrieved).toEqual(updatedConfig);\n      expect(retrieved.defaultProvider).toBe('ollama');\n      expect(retrieved.enableNotifications).toBe(false);\n    });\n\n    it('should handle config without concurrency limits', async () => {\n      const configWithoutLimits: IAppConfig = {\n        defaultProvider: 'openai',\n        enableNotifications: true,\n        enableLogging: false,\n      };\n\n      await repository.setAppConfig(configWithoutLimits);\n      const retrieved = await repository.getAppConfig();\n\n      expect(retrieved.modelConcurrencyLimits).toBeUndefined();\n    });\n  });\n\n  // === Clear All Tests ===\n\n  describe('Clear All', () => {\n    it('should clear all configuration data', async () => {\n      await repository.setProviderSettings('openai', sampleProviderSettings);\n      await repository.setCustomTags(sampleCustomTags);\n      await repository.setAppConfig(sampleAppConfig);\n\n      await repository.clearAll();\n\n      const allSettings = await repository.getAllProviderSettings();\n      const tags = await repository.getCustomTags();\n\n      expect(allSettings).toEqual({});\n      expect(tags).toEqual([]);\n      await expect(repository.getAppConfig()).rejects.toThrow();\n      expect(mockLogger.info).toHaveBeenCalledWith('Cleared all configuration data');\n    });\n  });\n\n  // === Error Handling Tests ===\n\n  describe('Error Handling', () => {\n    it('should handle storage errors gracefully', async () => {\n      const errorMessage = 'Storage quota exceeded';\n      mockStorage.set.mockRejectedValueOnce(new Error(errorMessage));\n\n      await expect(\n        repository.setProviderSettings('openai', sampleProviderSettings)\n      ).rejects.toThrow('Failed to save provider settings for openai: Storage quota exceeded');\n\n      expect(mockLogger.error).toHaveBeenCalledWith(\n        'Failed to save provider settings for openai',\n        expect.objectContaining({\n          providerId: 'openai',\n          error: errorMessage,\n        })\n      );\n    });\n\n    it('should handle get errors gracefully', async () => {\n      const errorMessage = 'Database error';\n      mockStorage.get.mockRejectedValueOnce(new Error(errorMessage));\n\n      await expect(repository.getCustomTags()).rejects.toThrow(\n        `Failed to get custom tags: ${errorMessage}`\n      );\n\n      expect(mockLogger.error).toHaveBeenCalledWith(\n        'Failed to get custom tags',\n        expect.objectContaining({\n          error: errorMessage,\n        })\n      );\n    });\n  });\n\n  // === Type Safety Tests ===\n\n  describe('Type Safety', () => {\n    it('should preserve IProviderSettings type', async () => {\n      await repository.setProviderSettings('test', sampleProviderSettings);\n      const settings = await repository.getProviderSettings('test');\n\n      expectTypeOf(settings).toMatchTypeOf<IProviderSettings>();\n      expect(settings.apiKey).toBeTypeOf('string');\n      expect(settings.model).toBeTypeOf('string');\n      expect(settings.apiUrl).toBeTypeOf('string');\n      expect(settings.additionalConfig).toBeTypeOf('object');\n    });\n\n    it('should preserve ICustomTag type', async () => {\n      await repository.setCustomTags(sampleCustomTags);\n      const tags = await repository.getCustomTags();\n\n      expectTypeOf(tags).toMatchTypeOf<ICustomTag[]>();\n      tags.forEach((tag) => {\n        expect(tag.key).toBeTypeOf('string');\n        expect(tag.name).toBeTypeOf('string');\n        expect(tag.color).toBeTypeOf('string');\n        if (tag.prompt) {\n          expect(tag.prompt).toBeTypeOf('string');\n        }\n      });\n    });\n\n    it('should preserve IAppConfig type', async () => {\n      await repository.setAppConfig(sampleAppConfig);\n      const config = await repository.getAppConfig();\n\n      expectTypeOf(config).toMatchTypeOf<IAppConfig>();\n      expect(config.defaultProvider).toBeTypeOf('string');\n      expect(config.enableNotifications).toBeTypeOf('boolean');\n      expect(config.enableLogging).toBeTypeOf('boolean');\n      expect(config.modelConcurrencyLimits).toBeTypeOf('object');\n    });\n  });\n\n  // === Browser API Compatibility Tests ===\n\n  describe('Browser API Compatibility', () => {\n    it('should throw error when browser API is not available', () => {\n      delete (globalThis as unknown as Record<string, unknown>).browser;\n\n      expect(() => new IndexedDBConfigRepository(mockLogger)).toThrow(\n        'browser.storage API not available'\n      );\n    });\n  });\n});\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * Unit tests for IndexedDBConfigRepository.\n */\n\nimport 'reflect-metadata';\nimport { describe, it, expect, vi, beforeEach, afterEach, expectTypeOf } from 'vitest';\nimport { IndexedDBConfigRepository } from '../src/infrastructure/repositories/IndexedDBConfigRepository';\nimport type { ILogger } from '../src/infrastructure/interfaces/ILogger';\nimport type {\n  IProviderSettings,\n  ICustomTag,\n  IAppConfig,\n} from '../src/infrastructure/interfaces/IConfigRepository';\n\n// === Mock Browser API ===\n\nfunction createMockBrowserStorage() {\n  const storage = new Map<string, Record<string, unknown>>();\n\n  return {\n    get: vi.fn(async (keys: string | string[] | Record<string, unknown> | null) => {\n      const result: Record<string, unknown> = {};\n\n      if (keys === null || typeof keys === 'string') {\n        if (keys === null || storage.has(keys)) {\n          const key = keys === null ? Array.from(storage.keys())[0] : keys;\n          if (key && storage.has(key)) {\n            result[key] = storage.get(key);\n          }\n        }\n      } else if (Array.isArray(keys)) {\n        for (const key of keys) {\n          if (storage.has(key)) {\n            result[key] = storage.get(key);\n          }\n        }\n      } else if (typeof keys === 'object') {\n        for (const key of Object.keys(keys)) {\n          if (storage.has(key)) {\n            result[key] = storage.get(key);\n          }\n        }\n      }\n\n      return result;\n    }),\n\n    set: vi.fn(async (items: Record<string, unknown>) => {\n      for (const [key, value] of Object.entries(items)) {\n        storage.set(key, value as Record<string, unknown>);\n      }\n    }),\n\n    clear: vi.fn(async () => {\n      storage.clear();\n    }),\n\n    _getStorage: () => storage,\n  };\n}\n\nfunction mockGlobalBrowserStorage() {\n  const mockStorage = createMockBrowserStorage();\n\n  (globalThis as unknown as Record<string, unknown>).browser = {\n    storage: {\n      local: {\n        get: mockStorage.get,\n        set: mockStorage.set,\n        clear: mockStorage.clear,\n      },\n    },\n  };\n\n  return mockStorage;\n}\n\n// === Test Fixtures ===\n\nfunction createMockLogger(): ILogger {\n  return {\n    debug: vi.fn(),\n    info: vi.fn(),\n    warn: vi.fn(),\n    error: vi.fn(),\n    maskApiKey: vi.fn((key?: string) =>\n      key ? `${key.slice(0, 7)}...${key.slice(-3)}` : 'not set'\n    ),\n  };\n}\n\nconst sampleProviderSettings: IProviderSettings = {\n  apiKey: 'sk-test-key-123',\n  model: 'gpt-4',\n  apiUrl: 'https://api.example.com/v1',\n  additionalConfig: {\n    temperature: 0.7,\n  },\n};\n\nconst sampleCustomTags: ICustomTag[] = [\n  {\n    key: 'is_advertise',\n    name: 'Advertisement',\n    color: '#FFC107',\n    prompt: 'Check if email is advertising something',\n  },\n  {\n    key: 'is_personal',\n    name: 'Personal',\n    color: '#4CAF50',\n    prompt: 'Check if this is personal email',\n  },\n];\n\nconst sampleAppConfig: IAppConfig = {\n  defaultProvider: 'openai',\n  enableNotifications: true,\n  enableLogging: true,\n  modelConcurrencyLimits: [\n    {\n      provider: 'openai',\n      model: 'gpt-4',\n      concurrency: 10,\n    },\n    {\n      provider: 'ollama',\n      concurrency: 5,\n    },\n  ],\n  confidenceThreshold: 70,\n};\n\n// === Test Suite ===\n\ndescribe('IndexedDBConfigRepository', () => {\n  let repository: IndexedDBConfigRepository;\n  let mockLogger: ILogger;\n  let mockStorage: ReturnType<typeof createMockBrowserStorage>;\n\n  beforeEach(() => {\n    mockLogger = createMockLogger();\n    mockStorage = mockGlobalBrowserStorage();\n    repository = new IndexedDBConfigRepository(mockLogger);\n  });\n\n  afterEach(() => {\n    // Clean up global mock\n    delete (globalThis as unknown as Record<string, unknown>).browser;\n    delete (globalThis as unknown as Record<string, unknown>).chrome;\n  });\n\n  // === Provider Settings Tests ===\n\n  describe('Provider Settings', () => {\n    it('should set and get provider settings', async () => {\n      const providerId = 'openai';\n\n      await repository.setProviderSettings(providerId, sampleProviderSettings);\n      const retrieved = await repository.getProviderSettings(providerId);\n\n      expect(retrieved).toEqual(sampleProviderSettings);\n      expect(mockLogger.debug).toHaveBeenCalledWith(\n        `Saved provider settings for ${providerId}`,\n        expect.objectContaining({\n          providerId,\n          hasApiKey: true,\n          model: 'gpt-4',\n        })\n      );\n    });\n\n    it('should throw error when getting non-existent provider settings', async () => {\n      await expect(repository.getProviderSettings('nonexistent')).rejects.toThrow(\n        'Provider settings not found for provider: nonexistent'\n      );\n      expect(mockLogger.error).toHaveBeenCalled();\n    });\n\n    it('should get all provider settings', async () => {\n      const settings2: IProviderSettings = {\n        apiKey: 'ollama-key',\n        model: 'llama2',\n      };\n\n      await repository.setProviderSettings('openai', sampleProviderSettings);\n      await repository.setProviderSettings('ollama', settings2);\n\n      const allSettings = await repository.getAllProviderSettings();\n\n      expect(allSettings).toEqual({\n        openai: sampleProviderSettings,\n        ollama: settings2,\n      });\n    });\n\n    it('should return empty object when no provider settings exist', async () => {\n      const allSettings = await repository.getAllProviderSettings();\n\n      expect(allSettings).toEqual({});\n    });\n\n    it('should overwrite existing provider settings', async () => {\n      const providerId = 'openai';\n\n      await repository.setProviderSettings(providerId, sampleProviderSettings);\n\n      const updatedSettings: IProviderSettings = {\n        apiKey: 'new-key',\n        model: 'gpt-4-turbo',\n      };\n\n      await repository.setProviderSettings(providerId, updatedSettings);\n      const retrieved = await repository.getProviderSettings(providerId);\n\n      expect(retrieved).toEqual(updatedSettings);\n      expect(retrieved).not.toEqual(sampleProviderSettings);\n    });\n  });\n\n  // === Custom Tags Tests ===\n\n  describe('Custom Tags', () => {\n    it('should set and get custom tags', async () => {\n      await repository.setCustomTags(sampleCustomTags);\n      const retrieved = await repository.getCustomTags();\n\n      expect(retrieved).toEqual(sampleCustomTags);\n      expect(mockLogger.debug).toHaveBeenCalledWith('Saved 2 custom tags');\n    });\n\n    it('should return empty array when no custom tags exist', async () => {\n      const tags = await repository.getCustomTags();\n\n      expect(tags).toEqual([]);\n    });\n\n    it('should overwrite existing custom tags', async () => {\n      await repository.setCustomTags(sampleCustomTags);\n\n      const newTags: ICustomTag[] = [\n        {\n          key: 'new_tag',\n          name: 'New Tag',\n          color: '#123456',\n        },\n      ];\n\n      await repository.setCustomTags(newTags);\n      const retrieved = await repository.getCustomTags();\n\n      expect(retrieved).toEqual(newTags);\n      expect(retrieved).toHaveLength(1);\n    });\n\n    it('should handle empty custom tags array', async () => {\n      await repository.setCustomTags([]);\n      const tags = await repository.getCustomTags();\n\n      expect(tags).toEqual([]);\n    });\n  });\n\n  // === App Config Tests ===\n\n  describe('App Config', () => {\n    it('should set and get app config', async () => {\n      await repository.setAppConfig(sampleAppConfig);\n      const retrieved = await repository.getAppConfig();\n\n      expect(retrieved).toEqual(sampleAppConfig);\n      expect(mockLogger.debug).toHaveBeenCalledWith(\n        'Saved application config',\n        expect.objectContaining({\n          defaultProvider: 'openai',\n          enableNotifications: true,\n        })\n      );\n    });\n\n    it('should throw error when app config does not exist', async () => {\n      await expect(repository.getAppConfig()).rejects.toThrow(\n        'Application configuration not found'\n      );\n      expect(mockLogger.error).toHaveBeenCalled();\n    });\n\n    it('should update existing app config', async () => {\n      await repository.setAppConfig(sampleAppConfig);\n\n      const updatedConfig: IAppConfig = {\n        ...sampleAppConfig,\n        defaultProvider: 'ollama',\n        enableNotifications: false,\n      };\n\n      await repository.setAppConfig(updatedConfig);\n      const retrieved = await repository.getAppConfig();\n\n      expect(retrieved).toEqual(updatedConfig);\n      expect(retrieved.defaultProvider).toBe('ollama');\n      expect(retrieved.enableNotifications).toBe(false);\n    });\n\n    it('should handle config without concurrency limits', async () => {\n      const configWithoutLimits: IAppConfig = {\n        defaultProvider: 'openai',\n        enableNotifications: true,\n        enableLogging: false,\n        modelConcurrencyLimits: undefined,\n        confidenceThreshold: 75,\n      };\n\n      await repository.setAppConfig(configWithoutLimits);\n      const retrieved = await repository.getAppConfig();\n\n      expect(retrieved.modelConcurrencyLimits).toBeUndefined();\n    });\n  });\n\n  // === Clear All Tests ===\n\n  describe('Clear All', () => {\n    it('should clear all configuration data', async () => {\n      await repository.setProviderSettings('openai', sampleProviderSettings);\n      await repository.setCustomTags(sampleCustomTags);\n      await repository.setAppConfig(sampleAppConfig);\n\n      await repository.clearAll();\n\n      const allSettings = await repository.getAllProviderSettings();\n      const tags = await repository.getCustomTags();\n\n      expect(allSettings).toEqual({});\n      expect(tags).toEqual([]);\n      await expect(repository.getAppConfig()).rejects.toThrow();\n      expect(mockLogger.info).toHaveBeenCalledWith('Cleared all configuration data');\n    });\n  });\n\n  // === Error Handling Tests ===\n\n  describe('Error Handling', () => {\n    it('should handle storage errors gracefully', async () => {\n      const errorMessage = 'Storage quota exceeded';\n      mockStorage.set.mockRejectedValueOnce(new Error(errorMessage));\n\n      await expect(\n        repository.setProviderSettings('openai', sampleProviderSettings)\n      ).rejects.toThrow('Failed to save provider settings for openai: Storage quota exceeded');\n\n      expect(mockLogger.error).toHaveBeenCalledWith(\n        'Failed to save provider settings for openai',\n        expect.objectContaining({\n          providerId: 'openai',\n          error: errorMessage,\n        })\n      );\n    });\n\n    it('should handle get errors gracefully', async () => {\n      const errorMessage = 'Database error';\n      mockStorage.get.mockRejectedValueOnce(new Error(errorMessage));\n\n      await expect(repository.getCustomTags()).rejects.toThrow(\n        `Failed to get custom tags: ${errorMessage}`\n      );\n\n      expect(mockLogger.error).toHaveBeenCalledWith(\n        'Failed to get custom tags',\n        expect.objectContaining({\n          error: errorMessage,\n        })\n      );\n    });\n  });\n\n  // === Type Safety Tests ===\n\n  describe('Type Safety', () => {\n    it('should preserve IProviderSettings type', async () => {\n      await repository.setProviderSettings('test', sampleProviderSettings);\n      const settings = await repository.getProviderSettings('test');\n\n      expectTypeOf(settings).toMatchTypeOf<IProviderSettings>();\n      expect(settings.apiKey).toBeTypeOf('string');\n      expect(settings.model).toBeTypeOf('string');\n      expect(settings.apiUrl).toBeTypeOf('string');\n      expect(settings.additionalConfig).toBeTypeOf('object');\n    });\n\n    it('should preserve ICustomTag type', async () => {\n      await repository.setCustomTags(sampleCustomTags);\n      const tags = await repository.getCustomTags();\n\n      expectTypeOf(tags).toMatchTypeOf<ICustomTag[]>();\n      tags.forEach((tag) => {\n        expect(tag.key).toBeTypeOf('string');\n        expect(tag.name).toBeTypeOf('string');\n        expect(tag.color).toBeTypeOf('string');\n        if (tag.prompt) {\n          expect(tag.prompt).toBeTypeOf('string');\n        }\n      });\n    });\n\n    it('should preserve IAppConfig type', async () => {\n      await repository.setAppConfig(sampleAppConfig);\n      const config = await repository.getAppConfig();\n\n      expectTypeOf(config).toMatchTypeOf<IAppConfig>();\n      expect(config.defaultProvider).toBeTypeOf('string');\n      expect(config.enableNotifications).toBeTypeOf('boolean');\n      expect(config.enableLogging).toBeTypeOf('boolean');\n      expect(config.modelConcurrencyLimits).toBeTypeOf('object');\n    });\n  });\n\n  // === Tag Threshold Tests ===\n\n  describe('Tag Thresholds', () => {\n    it('should set and get tag threshold', async () => {\n      const tagKey = 'is_business';\n      const threshold = 80;\n\n      await repository.setTagThreshold(tagKey, threshold);\n      const retrieved = await repository.getTagThreshold(tagKey);\n\n      expect(retrieved).toBe(threshold);\n    });\n\n    it('should return null when tag threshold is not set', async () => {\n      const tagKey = 'is_business';\n      const retrieved = await repository.getTagThreshold(tagKey);\n\n      expect(retrieved).toBeNull();\n    });\n\n    it('should remove tag threshold when set to null', async () => {\n      const tagKey = 'is_business';\n      const threshold = 80;\n\n      // Set threshold\n      await repository.setTagThreshold(tagKey, threshold);\n      let retrieved = await repository.getTagThreshold(tagKey);\n      expect(retrieved).toBe(threshold);\n\n      // Remove threshold\n      await repository.setTagThreshold(tagKey, null);\n      retrieved = await repository.getTagThreshold(tagKey);\n      expect(retrieved).toBeNull();\n    });\n\n    it('should get all tag thresholds', async () => {\n      const thresholds = {\n        is_business: 80,\n        is_personal: 60,\n        is_advertise: 75,\n      };\n\n      // Set thresholds\n      for (const [tagKey, threshold] of Object.entries(thresholds)) {\n        await repository.setTagThreshold(tagKey, threshold);\n      }\n\n      const allThresholds = await repository.getAllTagThresholds();\n\n      expect(allThresholds).toEqual(thresholds);\n    });\n\n    it('should return empty object when no tag thresholds are set', async () => {\n      const allThresholds = await repository.getAllTagThresholds();\n\n      expect(allThresholds).toEqual({});\n    });\n\n    it('should overwrite existing tag threshold', async () => {\n      const tagKey = 'is_business';\n\n      await repository.setTagThreshold(tagKey, 80);\n      await repository.setTagThreshold(tagKey, 90);\n\n      const retrieved = await repository.getTagThreshold(tagKey);\n      expect(retrieved).toBe(90);\n    });\n\n    it('should reject invalid threshold values', async () => {\n      const tagKey = 'is_business';\n\n      await expect(repository.setTagThreshold(tagKey, -1)).rejects.toThrow();\n      await expect(repository.setTagThreshold(tagKey, 101)).rejects.toThrow();\n      await expect(repository.setTagThreshold(tagKey, NaN)).rejects.toThrow();\n    });\n\n    it('should accept valid threshold boundary values', async () => {\n      const tagKey1 = 'tag1';\n      const tagKey2 = 'tag2';\n\n      await repository.setTagThreshold(tagKey1, 0);\n      await repository.setTagThreshold(tagKey2, 100);\n\n      const threshold1 = await repository.getTagThreshold(tagKey1);\n      const threshold2 = await repository.getTagThreshold(tagKey2);\n\n      expect(threshold1).toBe(0);\n      expect(threshold2).toBe(100);\n    });\n\n    it('should handle multiple tag thresholds independently', async () => {\n      const tag1 = 'is_business';\n      const tag2 = 'is_personal';\n      const tag3 = 'is_advertise';\n\n      await repository.setTagThreshold(tag1, 80);\n      await repository.setTagThreshold(tag2, 60);\n      await repository.setTagThreshold(tag3, 75);\n\n      // Remove only tag2\n      await repository.setTagThreshold(tag2, null);\n\n      const allThresholds = await repository.getAllTagThresholds();\n\n      expect(allThresholds).toEqual({\n        is_business: 80,\n        is_advertise: 75,\n      });\n      expect(allThresholds).not.toHaveProperty('is_personal');\n    });\n  });\n\n  // === Browser API Compatibility Tests ===\n\n  describe('Browser API Compatibility', () => {\n    it('should throw error when browser API is not available', () => {\n      delete (globalThis as unknown as Record<string, unknown>).browser;\n\n      expect(() => new IndexedDBConfigRepository(mockLogger)).toThrow(\n        'browser.storage API not available'\n      );\n    });\n  });\n});\n",
        "last_modified": "2026-01-05T19:59:00.213774"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.103720",
  "last_updated": "2026-01-05T14:48:03.106913"
}