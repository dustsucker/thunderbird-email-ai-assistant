{
  "file_path": "src/infrastructure/repositories/AnalysisHistoryRepository.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * Analysis history repository using browser.storage.local.\n *\n * Implements IAnalysisHistoryRepository using browser.storage.local API\n * which is available in Thunderbird extensions and provides a Promise-based\n * interface for persistent analysis history storage.\n *\n * Uses a single storage namespace (key):\n * - 'analysisHistory': Array of analysis history records\n */\n\nimport { injectable, inject } from 'tsyringe';\nimport type { ILogger } from '../interfaces/ILogger';\nimport type {\n  IAnalysisHistoryRepository,\n  IAnalysisHistoryRecord,\n  IAnalysisHistoryQuery,\n  IAnalysisHistoryStats,\n} from '../interfaces/IAnalysisHistoryRepository';\n\n// === Type Definitions ===\n\ninterface StorageLocal {\n  get: (\n    keys: string | string[] | Record<string, unknown> | null\n  ) => Promise<Record<string, unknown>>;\n  set: (items: Record<string, unknown>) => Promise<void>;\n  clear: () => Promise<void>;\n}\n\ninterface BrowserStorage {\n  storage: {\n    local: StorageLocal;\n  };\n}\n\n// === Type Guards ===\n\n/**\n * Type guard to check if object has browser.storage API.\n */\nfunction hasBrowserStorage(obj: unknown): obj is BrowserStorage {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const maybeStorage = obj as Record<string, unknown>;\n  if (typeof maybeStorage.storage !== 'object' || maybeStorage.storage === null) {\n    return false;\n  }\n\n  const storage = maybeStorage.storage as Record<string, unknown>;\n  if (typeof storage.local !== 'object' || storage.local === null) {\n    return false;\n  }\n\n  const local = storage.local as Record<string, unknown>;\n  return (\n    typeof local.get === 'function' &&\n    typeof local.set === 'function' &&\n    typeof local.clear === 'function'\n  );\n}\n\n// === Constants ===\n\nconst STORAGE_KEY = 'analysisHistory';\n\n// === Helper Functions ===\n\n/**\n * Generate a unique ID for an analysis record.\n */\nfunction generateId(): string {\n  return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n}\n\n/**\n * Convert provider confidence (0.0-1.0) to confidence score (0-100).\n */\nfunction toConfidenceScore(confidence: number): number {\n  return Math.round(confidence * 100);\n}\n\n/**\n * Check if a record matches a query.\n */\nfunction matchesQuery(record: IAnalysisHistoryRecord, query: IAnalysisHistoryQuery): boolean {\n  // Filter by message ID\n  if (query.messageId && record.messageId !== query.messageId) {\n    return false;\n  }\n\n  // Filter by provider\n  if (query.provider && record.provider !== query.provider) {\n    return false;\n  }\n\n  // Filter by model\n  if (query.model && record.model !== query.model) {\n    return false;\n  }\n\n  // Filter by confidence score range\n  if (query.minConfidenceScore !== undefined && record.confidence_score < query.minConfidenceScore) {\n    return false;\n  }\n  if (query.maxConfidenceScore !== undefined && record.confidence_score > query.maxConfidenceScore) {\n    return false;\n  }\n\n  // Filter by tag\n  if (query.hasTag && !record.tags.includes(query.hasTag)) {\n    return false;\n  }\n\n  // Filter by date range\n  if (query.startDate && record.timestamp < query.startDate) {\n    return false;\n  }\n  if (query.endDate && record.timestamp > query.endDate) {\n    return false;\n  }\n\n  return true;\n}\n\n// === Implementation ===\n\n@injectable()\nexport class AnalysisHistoryRepository implements IAnalysisHistoryRepository {\n  private readonly storage: {\n    get: (keys: string | string[] | Record<string, unknown> | null) => Promise<Record<string, unknown>>;\n    set: (items: Record<string, unknown>) => Promise<void>;\n    clear: () => Promise<void>;\n  };\n\n  constructor(@inject('ILogger') private readonly logger: ILogger) {\n    // Use browser.storage.local if available (Thunderbird extension environment)\n    const browserApi = (globalThis as unknown as Record<string, unknown>).browser as\n      | BrowserStorage\n      | undefined;\n    const chromeApi = (globalThis as unknown as Record<string, unknown>).chrome as\n      | BrowserStorage\n      | undefined;\n\n    if (browserApi && hasBrowserStorage(browserApi)) {\n      this.storage = {\n        get: browserApi.storage.local.get.bind(browserApi.storage.local),\n        set: browserApi.storage.local.set.bind(browserApi.storage.local),\n        clear: browserApi.storage.local.clear.bind(browserApi.storage.local),\n      };\n      this.logger.info('Using browser.storage.local for analysis history persistence');\n    } else if (chromeApi && hasBrowserStorage(chromeApi)) {\n      this.storage = {\n        get: chromeApi.storage.local.get.bind(chromeApi.storage.local),\n        set: chromeApi.storage.local.set.bind(chromeApi.storage.local),\n        clear: chromeApi.storage.local.clear.bind(chromeApi.storage.local),\n      };\n      this.logger.info('Using chrome.storage.local for analysis history persistence');\n    } else {\n      throw new Error(\n        'browser.storage API not available. AnalysisHistoryRepository requires a Thunderbird extension environment.'\n      );\n    }\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  async saveAnalysis(record: IAnalysisHistoryRecord): Promise<void> {\n    try {\n      this.logger.debug('Saving analysis record', {\n        id: record.id,\n        messageId: record.messageId,\n        confidence_score: record.confidence_score,\n      });\n\n      const data = await this.storage.get(STORAGE_KEY);\n      const history = (data[STORAGE_KEY] as IAnalysisHistoryRecord[]) || [];\n\n      // Add new record\n      history.push(record);\n\n      // Sort by timestamp descending (newest first)\n      history.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n\n      await this.storage.set({ [STORAGE_KEY]: history });\n\n      this.logger.debug('Analysis record saved successfully', {\n        id: record.id,\n        totalRecords: history.length,\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to save analysis record', {\n        id: record.id,\n        error: message,\n      });\n      throw new Error(`Failed to save analysis record: ${message}`);\n    }\n  }\n\n  async getAnalysis(id: string): Promise<IAnalysisHistoryRecord | null> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const history = (data[STORAGE_KEY] as IAnalysisHistoryRecord[]) || [];\n\n      const record = history.find((r) => r.id === id);\n\n      if (record) {\n        this.logger.debug('Analysis record found', { id });\n      } else {\n        this.logger.debug('Analysis record not found', { id });\n      }\n\n      return record || null;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get analysis record', { id, error: message });\n      throw new Error(`Failed to get analysis record: ${message}`);\n    }\n  }\n\n  async getAnalysisByMessage(messageId: string): Promise<IAnalysisHistoryRecord[]> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const history = (data[STORAGE_KEY] as IAnalysisHistoryRecord[]) || [];\n\n      const records = history.filter((r) => r.messageId === messageId);\n\n      this.logger.debug('Retrieved analysis records for message', {\n        messageId,\n        count: records.length,\n      });\n\n      return records;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to get analysis records for message', {\n        messageId,\n        error: message,\n      });\n      throw new Error(`Failed to get analysis records for message: ${message}`);\n    }\n  }\n\n  async queryAnalysisHistory(query?: IAnalysisHistoryQuery): Promise<IAnalysisHistoryRecord[]> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      let history = (data[STORAGE_KEY] as IAnalysisHistoryRecord[]) || [];\n\n      // Apply filters\n      if (query) {\n        history = history.filter((record) => matchesQuery(record, query));\n\n        // Apply limit and offset\n        const offset = query.offset || 0;\n        const limit = query.limit;\n        if (limit !== undefined) {\n          history = history.slice(offset, offset + limit);\n        } else if (offset > 0) {\n          history = history.slice(offset);\n        }\n      }\n\n      this.logger.debug('Query executed successfully', {\n        query: JSON.stringify(query),\n        resultCount: history.length,\n      });\n\n      return history;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to query analysis history', {\n        query: JSON.stringify(query),\n        error: message,\n      });\n      throw new Error(`Failed to query analysis history: ${message}`);\n    }\n  }\n\n  async getStats(query?: IAnalysisHistoryQuery): Promise<IAnalysisHistoryStats> {\n    try {\n      const records = await this.queryAnalysisHistory(query);\n\n      if (records.length === 0) {\n        return {\n          totalRecords: 0,\n          averageConfidenceScore: 0,\n          topTags: [],\n          analysisByProvider: [],\n          oldestAnalysis: null,\n          newestAnalysis: null,\n        };\n      }\n\n      // Calculate average confidence score\n      const totalConfidence = records.reduce((sum, r) => sum + r.confidence_score, 0);\n      const averageConfidenceScore = Math.round((totalConfidence / records.length) * 100) / 100;\n\n      // Count tag usage\n      const tagCounts = new Map<string, number>();\n      records.forEach((record) => {\n        record.tags.forEach((tag) => {\n          tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);\n        });\n      });\n      const topTags = Array.from(tagCounts.entries())\n        .map(([tag, count]) => ({ tag, count }))\n        .sort((a, b) => b.count - a.count)\n        .slice(0, 10);\n\n      // Count by provider\n      const providerCounts = new Map<string, number>();\n      records.forEach((record) => {\n        providerCounts.set(record.provider, (providerCounts.get(record.provider) || 0) + 1);\n      });\n      const analysisByProvider = Array.from(providerCounts.entries())\n        .map(([provider, count]) => ({ provider, count }))\n        .sort((a, b) => b.count - a.count);\n\n      // Find oldest and newest analysis\n      const sortedByTimestamp = [...records].sort((a, b) =>\n        a.timestamp.localeCompare(b.timestamp)\n      );\n      const oldestAnalysis = sortedByTimestamp[0]?.timestamp || null;\n      const newestAnalysis = sortedByTimestamp[sortedByTimestamp.length - 1]?.timestamp || null;\n\n      this.logger.debug('Statistics calculated successfully', {\n        totalRecords: records.length,\n        averageConfidenceScore,\n      });\n\n      return {\n        totalRecords: records.length,\n        averageConfidenceScore,\n        topTags,\n        analysisByProvider,\n        oldestAnalysis,\n        newestAnalysis,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to calculate analysis history stats', { error: message });\n      throw new Error(`Failed to calculate stats: ${message}`);\n    }\n  }\n\n  async deleteAnalysis(id: string): Promise<void> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const history = (data[STORAGE_KEY] as IAnalysisHistoryRecord[]) || [];\n\n      const filtered = history.filter((r) => r.id !== id);\n\n      if (filtered.length === history.length) {\n        this.logger.warn('Analysis record not found for deletion', { id });\n        return;\n      }\n\n      await this.storage.set({ [STORAGE_KEY]: filtered });\n\n      this.logger.debug('Analysis record deleted', { id });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to delete analysis record', { id, error: message });\n      throw new Error(`Failed to delete analysis record: ${message}`);\n    }\n  }\n\n  async deleteAnalysisByMessage(messageId: string): Promise<number> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const history = (data[STORAGE_KEY] as IAnalysisHistoryRecord[]) || [];\n\n      const filtered = history.filter((r) => r.messageId !== messageId);\n      const deletedCount = history.length - filtered.length;\n\n      if (deletedCount === 0) {\n        this.logger.debug('No analysis records found for message', { messageId });\n        return 0;\n      }\n\n      await this.storage.set({ [STORAGE_KEY]: filtered });\n\n      this.logger.debug('Analysis records deleted for message', {\n        messageId,\n        count: deletedCount,\n      });\n\n      return deletedCount;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to delete analysis records for message', {\n        messageId,\n        error: message,\n      });\n      throw new Error(`Failed to delete analysis records: ${message}`);\n    }\n  }\n\n  async clearAll(): Promise<number> {\n    try {\n      const data = await this.storage.get(STORAGE_KEY);\n      const history = (data[STORAGE_KEY] as IAnalysisHistoryRecord[]) || [];\n      const count = history.length;\n\n      await this.storage.set({ [STORAGE_KEY]: [] });\n\n      this.logger.info('All analysis history cleared', { count });\n      return count;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to clear analysis history', { error: message });\n      throw new Error(`Failed to clear analysis history: ${message}`);\n    }\n  }\n\n  async count(query?: IAnalysisHistoryQuery): Promise<number> {\n    try {\n      const records = await this.queryAnalysisHistory(query);\n      return records.length;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to count analysis records', { error: message });\n      throw new Error(`Failed to count analysis records: ${message}`);\n    }\n  }\n}\n",
        "last_modified": "2026-01-05T19:59:00.209195"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.056226",
  "last_updated": "2026-01-05T14:48:03.059958"
}