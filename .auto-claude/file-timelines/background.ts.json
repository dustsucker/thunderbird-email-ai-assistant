{
  "file_path": "background.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "/**\n * Thunderbird Email AI Assistant - Background Script\n *\n * Thin delegator that sets up Dependency Injection and delegates to\n * EmailEventListener and MessageHandler services.\n *\n * @module background\n */\n\nimport 'reflect-metadata';\nimport { container, injectable } from 'tsyringe';\n\n// ============================================================================\n// Core Interfaces\n// ============================================================================\n\nimport type { ILogger } from './src/infrastructure/interfaces/ILogger';\nimport type { ICache } from './src/infrastructure/interfaces/ICache';\nimport type { IQueue } from './src/infrastructure/interfaces/IQueue';\nimport type { IMailReader } from './src/infrastructure/interfaces/IMailReader';\nimport type { ITagManager } from './src/infrastructure/interfaces/ITagManager';\nimport type { IConfigRepository } from './src/infrastructure/interfaces/IConfigRepository';\n\n// ============================================================================\n// Core Implementations\n// ============================================================================\n\nimport { ConsoleLogger } from './src/infrastructure/logger/ConsoleLogger';\nimport { MemoryCache } from './src/infrastructure/cache/MemoryCache';\nimport { PriorityQueue } from './src/application/services/PriorityQueue';\nimport { ThunderbirdMailReader } from './src/interfaces/adapters/ThunderbirdMailReader';\nimport { ThunderbirdTagManager } from './src/interfaces/adapters/ThunderbirdTagManager';\nimport { IndexedDBConfigRepository } from './src/infrastructure/repositories/IndexedDBConfigRepository';\n\n// ============================================================================\n// Services\n// ============================================================================\n\nimport { EmailContentExtractor } from './src/domain/services/EmailContentExtractor';\nimport { TagService } from './src/domain/services/TagService';\nimport { AppConfigService } from './src/infrastructure/config/AppConfig';\nimport { RateLimiterService } from './src/application/services/RateLimiterService';\nimport { ProviderFactory } from './src/infrastructure/providers/ProviderFactory';\n\n// ============================================================================\n// Domain Types\n// ============================================================================\n\nimport type { IProviderSettings } from './src/infrastructure/interfaces/IProvider';\n\n// ============================================================================\n// Use Cases\n// ============================================================================\n\nimport { AnalyzeEmail } from './src/application/use-cases/AnalyzeEmail';\nimport { ApplyTagsToEmail } from './src/application/use-cases/ApplyTagsToEmail';\nimport { AnalyzeBatchEmails } from './src/application/use-cases/AnalyzeBatchEmails';\n\n// ============================================================================\n// Background Services\n// ============================================================================\n\nimport { EmailEventListener } from './src/interfaces/background/EmailEventListener';\nimport { MessageHandler } from './src/interfaces/background/MessageHandler';\n\n// ============================================================================\n// Types for Context Menu (Thunderbird API)\n// ============================================================================\n\n/**\n * Thunderbird folder structure for context menus.\n */\ninterface ThunderbirdFolder {\n  accountId: string;\n  id: string;\n  path: string;\n  name: string;\n  type: string;\n}\n\n/**\n * Folder menu click data.\n */\ninterface FolderMenuOnClickData {\n  menuItemId: string | number;\n  selectedFolders?: ThunderbirdFolder[];\n  modifiers: string[];\n  selectedMessages?: {\n    id: number | null;\n    messages: Array<{ id: number; date: string }>;\n  };\n}\n\n/**\n * Tab interface for browser tabs.\n */\ninterface Tab {\n  id: number;\n  type: string;\n  index?: number;\n  windowId?: number;\n  selected?: boolean;\n}\n\n// ============================================================================\n// Global Declarations (Thunderbird API)\n// ============================================================================\n\ndeclare const messenger: {\n  messages: {\n    onNewMailReceived: {\n      addListener(\n        callback: (folder: ThunderbirdFolder, messages: { messages: Array<{ id: number }> }) => void\n      ): void;\n    };\n    getFull(messageId: number): Promise<unknown>;\n    list(folderId?: string): Promise<{ messages: Array<{ id: number }> }>;\n    get(messageId: number): Promise<{ id: number; tags?: string[] }>;\n    update(messageId: number, properties: { tags: string[] }): Promise<void>;\n  };\n  messageDisplay: {\n    getDisplayedMessage(tabId?: number): Promise<{ id: number } | null>;\n  };\n  storage: {\n    local: {\n      get(keys?: Record<string, unknown> | string[] | string): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n  runtime: {\n    onInstalled: {\n      addListener(callback: (details: { reason: string }) => void): void;\n    };\n    onSuspend: {\n      addListener(callback: () => void): void;\n    };\n    sendMessage(message: {\n      action: string;\n      folderId?: string;\n      messageId?: string;\n    }): Promise<unknown>;\n  };\n  menus: {\n    create(createProperties: Record<string, unknown>, callback?: () => void): void;\n    onClicked: {\n      addListener(callback: (info: FolderMenuOnClickData, tab: Tab) => void): void;\n    };\n  };\n  browserAction?: {\n    onClicked?: {\n      addListener(callback: (tab: Tab) => void): void;\n    };\n  };\n  action?: {\n    onClicked?: {\n      addListener(callback: (tab: Tab) => void): void;\n    };\n  };\n  notifications: {\n    create(options: {\n      type: string;\n      iconUrl: string;\n      title: string;\n      message: string;\n    }): Promise<string>;\n  };\n};\n\ndeclare const browser: {\n  runtime?: {\n    lastError?: { message: string };\n  };\n};\n\n// ============================================================================\n// Logger Wrapper (for startup before DI container)\n// ============================================================================\n\n/**\n * Simple console logger for startup before DI container is ready.\n */\nconst startupLogger = {\n  info: (message: string, meta?: Record<string, unknown>) => {\n    console.log(`[Background Startup] ${message}`, meta || '');\n  },\n  warn: (message: string, meta?: Record<string, unknown>) => {\n    console.warn(`[Background Startup] ${message}`, meta || '');\n  },\n  error: (message: string, error?: unknown) => {\n    console.error(`[Background Startup] ${message}`, error || '');\n  },\n};\n\n// ============================================================================\n// Background Script Main Class\n// ============================================================================\n\n/**\n * Background Script Main Class\n *\n * @class BackgroundScript\n */\n@injectable()\nclass BackgroundScript {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private eventListener: EmailEventListener | null = null;\n  private messageHandler: MessageHandler | null = null;\n  private logger: ILogger | null = null;\n  private analyzeEmail: AnalyzeEmail | null = null;\n  private analyzeBatch: AnalyzeBatchEmails | null = null;\n  private appConfigService: AppConfigService | null = null;\n  private isInitialized = false;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor() {\n    startupLogger.info('BackgroundScript class instantiated');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Initializes the background script.\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      startupLogger.warn('Background script already initialized');\n      return;\n    }\n\n    startupLogger.info('Initializing background script...');\n\n    try {\n      // Step 1: Setup DI container\n      this.setupDIContainer();\n\n      // Step 2: Resolve logger\n      this.logger = container.resolve<ILogger>('ILogger');\n      this.logger.info('Background script initialization started');\n\n      // Step 3: Resolve background services\n      this.eventListener = container.resolve<EmailEventListener>(EmailEventListener);\n      this.messageHandler = container.resolve<MessageHandler>(MessageHandler);\n\n      // Step 3.5: Resolve use cases and config service for context menu handlers\n      this.analyzeEmail = container.resolve<AnalyzeEmail>(AnalyzeEmail);\n      this.analyzeBatch = container.resolve<AnalyzeBatchEmails>(AnalyzeBatchEmails);\n      this.appConfigService = container.resolve<AppConfigService>(AppConfigService);\n\n      // Step 4: Start background services\n      this.eventListener.start();\n      this.messageHandler.start();\n\n      // Step 5: Register context menus\n      this.registerContextMenus();\n\n      // Step 6: Register toolbar button\n      this.registerToolbarButton();\n\n      // Step 7: Register onInstalled handler\n      this.registerInstallHandler();\n\n      // Step 8: Register shutdown handler\n      this.registerShutdownHandler();\n\n      this.isInitialized = true;\n      this.logger.info('Background script initialization completed successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      startupLogger.error('Failed to initialize background script', error);\n      throw new Error(`Background script initialization failed: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Shutdowns the background script.\n   */\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) {\n      startupLogger.warn('Background script not initialized, nothing to shutdown');\n      return;\n    }\n\n    startupLogger.info('Shutting down background script...');\n\n    try {\n      if (this.eventListener) {\n        this.eventListener.stop();\n        this.logger?.info('EmailEventListener stopped');\n      }\n\n      if (this.messageHandler) {\n        this.messageHandler.stop();\n        this.logger?.info('MessageHandler stopped');\n      }\n\n      this.isInitialized = false;\n      this.logger?.info('Background script shutdown completed successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      startupLogger.error('Failed to shutdown background script', error);\n      throw new Error(`Background script shutdown failed: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - DI Container Setup\n  // ==========================================================================\n\n  /**\n   * Sets up TSyringe DI container.\n   */\n  private setupDIContainer(): void {\n    startupLogger.info('Setting up DI container...');\n\n    // ------------------------------------------------------------------------\n    // Register Core Interfaces\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton<ILogger>('ILogger', ConsoleLogger);\n    container.registerSingleton<ICache>('ICache', MemoryCache);\n    container.registerSingleton<IQueue>('IQueue', PriorityQueue);\n    container.registerSingleton<IMailReader>('IMailReader', ThunderbirdMailReader);\n    container.registerSingleton<ITagManager>('ITagManager', ThunderbirdTagManager);\n    container.registerSingleton<IConfigRepository>('IConfigRepository', IndexedDBConfigRepository);\n\n    startupLogger.info('Core interfaces registered');\n\n    // ------------------------------------------------------------------------\n    // Register Services\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('ProviderFactory', ProviderFactory);\n    container.registerSingleton('EmailContentExtractor', EmailContentExtractor);\n    container.registerSingleton('TagService', TagService);\n    container.registerSingleton('AppConfigService', AppConfigService);\n    container.registerSingleton('RateLimiterService', RateLimiterService);\n\n    startupLogger.info('Services registered');\n\n    // ------------------------------------------------------------------------\n    // Register Use Cases\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('AnalyzeEmail', AnalyzeEmail);\n    container.registerSingleton('ApplyTagsToEmail', ApplyTagsToEmail);\n    container.registerSingleton('AnalyzeBatchEmails', AnalyzeBatchEmails);\n\n    startupLogger.info('Use cases registered');\n\n    // ------------------------------------------------------------------------\n    // Register Background Services\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('EmailEventListener', EmailEventListener);\n    container.registerSingleton('MessageHandler', MessageHandler);\n\n    startupLogger.info('Background services registered');\n    startupLogger.info('DI container setup completed');\n  }\n\n  // ==========================================================================\n  // Private Methods - Context Menus\n  // ==========================================================================\n\n  /**\n   * Registers Thunderbird context menus.\n   */\n  private registerContextMenus(): void {\n    this.logger?.info('Registering context menus...');\n\n    try {\n      // Folder context menu: \"Analysiere diesen Ordner\"\n      messenger.menus.create(\n        {\n          id: 'batch-analyze-folder',\n          title: 'Analysiere diesen Ordner',\n          contexts: ['folder_pane'],\n          visible: true,\n        },\n        () => {\n          if (browser.runtime && browser.runtime.lastError) {\n            this.logger?.error('Failed to create folder context menu', browser.runtime.lastError);\n          } else {\n            this.logger?.info('Folder context menu registered');\n          }\n        }\n      );\n\n      // Message list context menu: \"AI-Analyse\"\n      messenger.menus.create(\n        {\n          id: 'analyze-single-message-list',\n          title: 'AI-Analyse',\n          contexts: ['message_list'],\n          visible: true,\n        },\n        () => {\n          if (browser.runtime && browser.runtime.lastError) {\n            this.logger?.error(\n              'Failed to create message list context menu',\n              browser.runtime.lastError\n            );\n          } else {\n            this.logger?.info('Message list context menu registered');\n          }\n        }\n      );\n\n      // Message display context menu: \"AI-Analyse\"\n      messenger.menus.create(\n        {\n          id: 'analyze-single-message-display',\n          title: 'AI-Analyse',\n          contexts: ['message_display_action_menu'],\n          visible: true,\n        },\n        () => {\n          if (browser.runtime && browser.runtime.lastError) {\n            this.logger?.error(\n              'Failed to create message display context menu',\n              browser.runtime.lastError\n            );\n          } else {\n            this.logger?.info('Message display context menu registered');\n          }\n        }\n      );\n\n      // Register context menu click handler\n      messenger.menus.onClicked.addListener(this.handleContextMenuClick.bind(this));\n\n      this.logger?.info('All context menus registered successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to register context menus', { error: errorMessage });\n    }\n  }\n\n  /**\n   * Handles context menu clicks.\n   */\n  private async handleContextMenuClick(info: FolderMenuOnClickData, _tab: Tab): Promise<void> {\n    // Extract message data for proper access to messages array\n    const messageData = info.selectedMessages;\n\n    // Detailed debug logging before any conditions\n    this.logger?.info('Context menu clicked', {\n      menuItemId: info.menuItemId,\n      menuItemIdType: typeof info.menuItemId,\n      hasSelectedMessages: messageData !== undefined,\n      hasMessagesProperty: messageData?.messages !== undefined,\n      messageCount: messageData?.messages?.length ?? 0,\n      hasSelectedFolders: info.selectedFolders !== undefined,\n      folderCount: info.selectedFolders?.length ?? 0,\n      fullInfo: info,\n    });\n\n    try {\n      if (typeof info.menuItemId !== 'string') {\n        this.logger?.warn('Invalid menuItemId type', { menuItemId: info.menuItemId });\n        return;\n      }\n\n      const menuItemId = info.menuItemId as string;\n\n      // Handle folder batch analysis\n      if (menuItemId === 'batch-analyze-folder') {\n        if (!info.selectedFolders) {\n          this.logger?.warn('Folder batch analysis requested but no folders selected', {\n            menuItemId,\n          });\n          return;\n        }\n\n        const folders = info.selectedFolders;\n        if (folders.length === 0) {\n          this.logger?.warn('Folder batch analysis requested but folder list is empty', {\n            menuItemId,\n            folderCount: 0,\n          });\n          return;\n        }\n\n        const folder = folders[0];\n        this.logger?.info('Starting batch analysis for folder', {\n          folderId: folder.id,\n          folderName: folder.name,\n        });\n\n        // Show notification\n        await messenger.notifications.create({\n          type: 'basic',\n          iconUrl: 'icon.png',\n          title: 'Batch-Analysis gestartet',\n          message: `Batch-Analysis f\u00fcr Ordner \"${folder.name}\" gestartet`,\n        });\n\n        try {\n          this.logger?.info('Batch Step 1: Getting provider settings...');\n          const providerSettings = await this.getProviderSettings();\n\n          this.logger?.info('Batch Step 2: Provider settings retrieved', {\n            provider: providerSettings.provider,\n            hasApiKey: !!providerSettings.apiKey,\n          });\n\n          if (!providerSettings.provider) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Fehler',\n              message: 'Kein Provider konfiguriert. Bitte \u00fcberpr\u00fcfen Sie Ihre Einstellungen.',\n            });\n            return;\n          }\n\n          // Get messages to analyze\n          const messageIds = await this.getMessagesToAnalyze(folder.id);\n\n          if (messageIds.length === 0) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Keine Nachrichten',\n              message: `Keine Nachrichten in Ordner \"${folder.name}\" gefunden.`,\n            });\n            return;\n          }\n\n          this.logger?.info('Batch Step 3: Starting batch analysis', {\n            messageCount: messageIds.length,\n          });\n\n          // Direct use case call\n          const result = await this.analyzeBatch!.execute(messageIds, {\n            providerSettings,\n            priority: 1,\n            concurrency: 3,\n          });\n\n          this.logger?.info('Batch analysis completed successfully', {\n            total: result.total,\n            successful: result.successCount,\n            failed: result.failureCount,\n          });\n\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Batch-Analysis abgeschlossen',\n            message: `Analyzed ${result.successCount}/${result.total} messages successfully.`,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          const errorStack = error instanceof Error ? error.stack : undefined;\n          this.logger?.error('Failed to execute batch analysis', {\n            error: errorMessage,\n            stack: errorStack,\n          });\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Fehler',\n            message: `Batch-Analyse fehlgeschlagen: ${errorMessage}`,\n          });\n        }\n        return;\n      }\n\n      // Handle single message analysis\n      if (\n        menuItemId === 'analyze-single-message-list' ||\n        menuItemId === 'analyze-single-message-display'\n      ) {\n        if (!messageData) {\n          this.logger?.warn('Single message analysis requested but no messages selected', {\n            menuItemId,\n          });\n          return;\n        }\n\n        const messages = messageData.messages || [];\n        if (messages.length === 0) {\n          this.logger?.warn('Single message analysis requested but message list is empty', {\n            menuItemId,\n            messageCount: 0,\n          });\n          return;\n        }\n\n        const messageId = messages[0].id;\n        this.logger?.info('Starting single message analysis', { messageId });\n\n        // Show notification\n        await messenger.notifications.create({\n          type: 'basic',\n          iconUrl: 'icon.png',\n          title: 'Analyse gestartet',\n          message: `Analyse f\u00fcr Nachricht ${messageId} gestartet`,\n        });\n\n        try {\n          this.logger?.info('Step 1: Getting provider settings...');\n          const providerSettings = await this.getProviderSettings();\n\n          this.logger?.info('Step 2: Provider settings retrieved', {\n            provider: providerSettings.provider,\n            hasApiKey: !!providerSettings.apiKey,\n          });\n\n          if (!providerSettings.provider) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Fehler',\n              message: 'Kein Provider konfiguriert. Bitte \u00fcberpr\u00fcfen Sie Ihre Einstellungen.',\n            });\n            return;\n          }\n\n          this.logger?.info('Step 3: Calling analyzeEmail.execute()...');\n          const result = await this.analyzeEmail!.execute(String(messageId), providerSettings);\n\n          this.logger?.info('Single message analysis completed successfully', {\n            messageId,\n            tags: result.tags,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          const errorStack = error instanceof Error ? error.stack : undefined;\n          this.logger?.error('Failed to analyze single message', {\n            messageId,\n            error: errorMessage,\n            stack: errorStack,\n          });\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Fehler',\n            message: `Analyse fehlgeschlagen: ${errorMessage}`,\n          });\n        }\n        return;\n      }\n\n      this.logger?.warn('Unknown context menu item', {\n        menuItemId,\n        hasSelectedMessages: messageData !== undefined,\n        hasSelectedFolders: info.selectedFolders !== undefined,\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const errorStack = error instanceof Error ? error.stack : undefined;\n      this.logger?.error('[DEBUG-background] Failed to handle context menu click', {\n        error: errorMessage,\n        stack: errorStack,\n      });\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Toolbar Button\n  // ==========================================================================\n\n  /**\n   * Registers toolbar button click handler.\n   */\n  private registerToolbarButton(): void {\n    this.logger?.info('Registering toolbar button...');\n\n    const browserAction = messenger.browserAction || messenger.action;\n\n    if (browserAction && browserAction.onClicked) {\n      browserAction.onClicked.addListener(async (tab: Tab) => {\n        this.logger?.info('Toolbar button clicked', { tabId: tab.id });\n\n        try {\n          const displayedMessage = await messenger.messageDisplay.getDisplayedMessage(tab.id);\n\n          if (!displayedMessage) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Keine Nachricht',\n              message: 'Keine Nachricht in diesem Tab angezeigt',\n            });\n            return;\n          }\n\n          const messageId = displayedMessage.id;\n          this.logger?.info('Toolbar button: Starting single message analysis', { messageId });\n\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Analyse gestartet',\n            message: `Analyse f\u00fcr Nachricht ${messageId} gestartet`,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          this.logger?.error('Failed to handle toolbar button click', { error: errorMessage });\n        }\n      });\n\n      this.logger?.info('Toolbar button registered successfully');\n    } else {\n      this.logger?.warn('Browser action API not available for toolbar button');\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Install Handler\n  // ==========================================================================\n\n  /**\n   * Registers onInstalled handler for extension install/update.\n   */\n  private registerInstallHandler(): void {\n    this.logger?.info('Registering onInstalled handler...');\n\n    if (messenger.runtime && messenger.runtime.onInstalled) {\n      messenger.runtime.onInstalled.addListener(async (details) => {\n        if (details.reason === 'install') {\n          this.logger?.info('Extension installed, initializing default settings...');\n\n          try {\n            const configRepository = container.resolve<IConfigRepository>('IConfigRepository');\n\n            try {\n              await configRepository.getAppConfig();\n              this.logger?.info('App config already exists, skipping defaults');\n            } catch {\n              this.logger?.info('Setting default app config');\n              await configRepository.setAppConfig({\n                defaultProvider: 'ollama',\n                enableNotifications: true,\n                enableLogging: false,\n                modelConcurrencyLimits: undefined,\n              });\n            }\n\n            try {\n              await configRepository.getProviderSettings('ollama');\n              this.logger?.info('Ollama provider settings already exist, skipping defaults');\n            } catch {\n              this.logger?.info('Setting default ollama provider settings');\n              await configRepository.setProviderSettings('ollama', {\n                apiKey: '',\n                model: 'gemma3:27b',\n                apiUrl: 'http://localhost:11434/api/generate',\n              });\n            }\n\n            this.logger?.info('Default configuration initialized successfully');\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            this.logger?.error('Failed to initialize default configuration', {\n              error: errorMessage,\n            });\n          }\n        }\n      });\n    } else {\n      this.logger?.warn('Runtime onInstalled handler not available');\n    }\n\n    this.logger?.info('Install handler registered');\n  }\n\n  // ==========================================================================\n  // Private Methods - Shutdown Handler\n  // ==========================================================================\n\n  /**\n   * Registers shutdown handler for extension cleanup.\n   */\n  private registerShutdownHandler(): void {\n    this.logger?.info('Registering shutdown handler...');\n\n    if (messenger.runtime && messenger.runtime.onSuspend) {\n      messenger.runtime.onSuspend.addListener(async () => {\n        this.logger?.info('Extension suspending, cleaning up...');\n        await this.shutdown();\n      });\n    } else {\n      this.logger?.warn('Runtime suspend handler not available');\n    }\n\n    this.logger?.info('Shutdown handler registered');\n  }\n\n  // ==========================================================================\n  // Private Methods - Helper for Context Menu Handlers\n  // ==========================================================================\n\n  /**\n   * Gets provider settings from app config.\n   *\n   * @returns Provider settings\n   */\n  private async getProviderSettings(): Promise<IProviderSettings> {\n    if (!this.appConfigService) {\n      throw new Error('AppConfigService not initialized');\n    }\n\n    try {\n      this.logger?.info('Attempting to get app config...');\n      const appConfig = await this.appConfigService.getAppConfig();\n      const defaultProvider = appConfig.defaultProvider;\n\n      this.logger?.info('App config retrieved', { defaultProvider });\n\n      this.logger?.info(`Attempting to get provider settings for: ${defaultProvider}`);\n      const providerSettings = await this.appConfigService.getProviderSettings(defaultProvider);\n\n      this.logger?.info('Provider settings retrieved', {\n        apiKey: providerSettings.apiKey ? '***' : 'missing',\n      });\n\n      return {\n        provider: defaultProvider,\n        apiKey: providerSettings.apiKey,\n        model: providerSettings.model,\n        apiUrl: providerSettings.apiUrl,\n        additionalConfig: providerSettings.additionalConfig,\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const errorStack = error instanceof Error ? error.stack : undefined;\n      this.logger?.error('Failed to get provider settings', {\n        error: errorMessage,\n        stack: errorStack,\n      });\n      this.logger?.error('Returning empty provider settings - THIS WILL CAUSE ANALYSIS TO FAIL');\n      return { provider: '' };\n    }\n  }\n\n  /**\n   * Gets messages to analyze from folder.\n   *\n   * @param folderId - Folder ID\n   * @returns Array of message IDs\n   */\n  private async getMessagesToAnalyze(folderId: string): Promise<string[]> {\n    try {\n      const messages = await messenger.messages.list(folderId);\n      return messages.messages.map((message) => String(message.id));\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to get messages from folder', { folderId, error: errorMessage });\n      return [];\n    }\n  }\n}\n\n// ============================================================================\n// Extension Entry Point\n// ============================================================================\n\n/**\n * Main extension entry point.\n */\n(async function main(): Promise<void> {\n  startupLogger.info('Thunderbird Email AI Assistant - Background Script Loading');\n\n  try {\n    const backgroundScript = new BackgroundScript();\n    await backgroundScript.initialize();\n\n    startupLogger.info('Thunderbird Email AI Assistant - Ready');\n  } catch (error) {\n    startupLogger.error('Failed to start extension', error);\n\n    try {\n      if (typeof messenger !== 'undefined' && messenger.notifications) {\n        await messenger.notifications.create({\n          type: 'basic',\n          iconUrl: 'icon.png',\n          title: 'Fehler beim Starten',\n          message:\n            'Die Erweiterung konnte nicht gestartet werden. Bitte \u00fcberpr\u00fcfen Sie die Konsole.',\n        });\n      }\n    } catch {\n      // Ignore notification errors during startup\n    }\n\n    throw error;\n  }\n})();\n\n// ============================================================================\n// Export for Testing\n// ============================================================================\n\nexport { BackgroundScript };\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * Thunderbird Email AI Assistant - Background Script\n *\n * Thin delegator that sets up Dependency Injection and delegates to\n * EmailEventListener and MessageHandler services.\n *\n * @module background\n */\n\nimport 'reflect-metadata';\nimport { container, injectable } from 'tsyringe';\n\n// ============================================================================\n// Core Interfaces\n// ============================================================================\n\nimport type { ILogger } from './src/infrastructure/interfaces/ILogger';\nimport type { ICache } from './src/infrastructure/interfaces/ICache';\nimport type { IQueue } from './src/infrastructure/interfaces/IQueue';\nimport type { IMailReader } from './src/infrastructure/interfaces/IMailReader';\nimport type { ITagManager } from './src/infrastructure/interfaces/ITagManager';\nimport type { IConfigRepository } from './src/infrastructure/interfaces/IConfigRepository';\nimport type { IAnalysisHistoryRepository } from './src/infrastructure/interfaces/IAnalysisHistoryRepository';\nimport type { IReviewQueueRepository } from './src/infrastructure/interfaces/IReviewQueueRepository';\n\n// ============================================================================\n// Core Implementations\n// ============================================================================\n\nimport { ConsoleLogger } from './src/infrastructure/logger/ConsoleLogger';\nimport { MemoryCache } from './src/infrastructure/cache/MemoryCache';\nimport { PriorityQueue } from './src/application/services/PriorityQueue';\nimport { ThunderbirdMailReader } from './src/interfaces/adapters/ThunderbirdMailReader';\nimport { ThunderbirdTagManager } from './src/interfaces/adapters/ThunderbirdTagManager';\nimport { IndexedDBConfigRepository } from './src/infrastructure/repositories/IndexedDBConfigRepository';\nimport { AnalysisHistoryRepository } from './src/infrastructure/repositories/AnalysisHistoryRepository';\nimport { ReviewQueueRepository } from './src/infrastructure/repositories/ReviewQueueRepository';\n\n// ============================================================================\n// Services\n// ============================================================================\n\nimport { EmailContentExtractor } from './src/domain/services/EmailContentExtractor';\nimport { TagService } from './src/domain/services/TagService';\nimport { AppConfigService } from './src/infrastructure/config/AppConfig';\nimport { RateLimiterService } from './src/application/services/RateLimiterService';\nimport { ProviderFactory } from './src/infrastructure/providers/ProviderFactory';\n\n// ============================================================================\n// Domain Types\n// ============================================================================\n\nimport type { IProviderSettings, ITagResponse } from './src/infrastructure/interfaces/IProvider';\n\n// ============================================================================\n// Use Cases\n// ============================================================================\n\nimport { AnalyzeEmail } from './src/application/use-cases/AnalyzeEmail';\nimport { ApplyTagsToEmail } from './src/application/use-cases/ApplyTagsToEmail';\nimport { AnalyzeBatchEmails } from './src/application/use-cases/AnalyzeBatchEmails';\n\n// ============================================================================\n// Background Services\n// ============================================================================\n\nimport { EmailEventListener } from './src/interfaces/background/EmailEventListener';\nimport { MessageHandler } from './src/interfaces/background/MessageHandler';\nimport { AnalysisHistoryHandler } from './src/interfaces/background/AnalysisHistoryHandler';\nimport { ReviewQueueHandler } from './src/interfaces/background/ReviewQueueHandler';\n\n// ============================================================================\n// Types for Context Menu (Thunderbird API)\n// ============================================================================\n\n/**\n * Thunderbird folder structure for context menus.\n */\ninterface ThunderbirdFolder {\n  accountId: string;\n  id: string;\n  path: string;\n  name: string;\n  type: string;\n}\n\n/**\n * Folder menu click data.\n */\ninterface FolderMenuOnClickData {\n  menuItemId: string | number;\n  selectedFolders?: ThunderbirdFolder[];\n  modifiers: string[];\n  selectedMessages?: {\n    id: number | null;\n    messages: Array<{ id: number; date: string }>;\n  };\n}\n\n/**\n * Tab interface for browser tabs.\n */\ninterface Tab {\n  id: number;\n  type: string;\n  index?: number;\n  windowId?: number;\n  selected?: boolean;\n}\n\n// ============================================================================\n// Global Declarations (Thunderbird API)\n// ============================================================================\n\ndeclare const messenger: {\n  messages: {\n    onNewMailReceived: {\n      addListener(\n        callback: (folder: ThunderbirdFolder, messages: { messages: Array<{ id: number }> }) => void\n      ): void;\n    };\n    getFull(messageId: number): Promise<unknown>;\n    list(folderId?: string): Promise<{ messages: Array<{ id: number }> }>;\n    get(messageId: number): Promise<{ id: number; tags?: string[] }>;\n    update(messageId: number, properties: { tags: string[] }): Promise<void>;\n  };\n  messageDisplay: {\n    getDisplayedMessage(tabId?: number): Promise<{ id: number } | null>;\n  };\n  storage: {\n    local: {\n      get(keys?: Record<string, unknown> | string[] | string): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n  runtime: {\n    onInstalled: {\n      addListener(callback: (details: { reason: string }) => void): void;\n    };\n    onSuspend: {\n      addListener(callback: () => void): void;\n    };\n    sendMessage(message: {\n      action: string;\n      folderId?: string;\n      messageId?: string;\n    }): Promise<unknown>;\n  };\n  menus: {\n    create(createProperties: Record<string, unknown>, callback?: () => void): void;\n    onClicked: {\n      addListener(callback: (info: FolderMenuOnClickData, tab: Tab) => void): void;\n    };\n  };\n  browserAction?: {\n    onClicked?: {\n      addListener(callback: (tab: Tab) => void): void;\n    };\n  };\n  action?: {\n    onClicked?: {\n      addListener(callback: (tab: Tab) => void): void;\n    };\n  };\n  notifications: {\n    create(options: {\n      type: string;\n      iconUrl: string;\n      title: string;\n      message: string;\n    }): Promise<string>;\n  };\n};\n\ndeclare const browser: {\n  runtime?: {\n    lastError?: { message: string };\n  };\n};\n\n// ============================================================================\n// Logger Wrapper (for startup before DI container)\n// ============================================================================\n\n/**\n * Simple console logger for startup before DI container is ready.\n */\nconst startupLogger = {\n  info: (message: string, meta?: Record<string, unknown>) => {\n    console.log(`[Background Startup] ${message}`, meta || '');\n  },\n  warn: (message: string, meta?: Record<string, unknown>) => {\n    console.warn(`[Background Startup] ${message}`, meta || '');\n  },\n  error: (message: string, error?: unknown) => {\n    console.error(`[Background Startup] ${message}`, error || '');\n  },\n};\n\n// ============================================================================\n// Background Script Main Class\n// ============================================================================\n\n/**\n * Background Script Main Class\n *\n * @class BackgroundScript\n */\n@injectable()\nclass BackgroundScript {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private eventListener: EmailEventListener | null = null;\n  private messageHandler: MessageHandler | null = null;\n  private analysisHistoryHandler: AnalysisHistoryHandler | null = null;\n  private reviewQueueHandler: ReviewQueueHandler | null = null;\n  private logger: ILogger | null = null;\n  private analyzeEmail: AnalyzeEmail | null = null;\n  private analyzeBatch: AnalyzeBatchEmails | null = null;\n  private appConfigService: AppConfigService | null = null;\n  private isInitialized = false;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor() {\n    startupLogger.info('BackgroundScript class instantiated');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Initializes the background script.\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      startupLogger.warn('Background script already initialized');\n      return;\n    }\n\n    startupLogger.info('Initializing background script...');\n\n    try {\n      // Step 1: Setup DI container\n      this.setupDIContainer();\n\n      // Step 2: Resolve logger\n      this.logger = container.resolve<ILogger>('ILogger');\n      this.logger.info('Background script initialization started');\n\n      // Step 3: Resolve background services\n      this.eventListener = container.resolve<EmailEventListener>(EmailEventListener);\n      this.messageHandler = container.resolve<MessageHandler>(MessageHandler);\n      this.analysisHistoryHandler = container.resolve<AnalysisHistoryHandler>(AnalysisHistoryHandler);\n      this.reviewQueueHandler = container.resolve<ReviewQueueHandler>(ReviewQueueHandler);\n\n      // Step 3.5: Resolve use cases and config service for context menu handlers\n      this.analyzeEmail = container.resolve<AnalyzeEmail>(AnalyzeEmail);\n      this.analyzeBatch = container.resolve<AnalyzeBatchEmails>(AnalyzeBatchEmails);\n      this.appConfigService = container.resolve<AppConfigService>(AppConfigService);\n\n      // Step 4: Start background services\n      this.eventListener.start();\n      this.messageHandler.start();\n      this.analysisHistoryHandler.start();\n      this.reviewQueueHandler.start();\n\n      // Step 5: Register context menus\n      this.registerContextMenus();\n\n      // Step 6: Register toolbar button\n      this.registerToolbarButton();\n\n      // Step 7: Register onInstalled handler\n      this.registerInstallHandler();\n\n      // Step 8: Register shutdown handler\n      this.registerShutdownHandler();\n\n      this.isInitialized = true;\n      this.logger.info('Background script initialization completed successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      startupLogger.error('Failed to initialize background script', error);\n      throw new Error(`Background script initialization failed: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Shutdowns the background script.\n   */\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) {\n      startupLogger.warn('Background script not initialized, nothing to shutdown');\n      return;\n    }\n\n    startupLogger.info('Shutting down background script...');\n\n    try {\n      if (this.eventListener) {\n        this.eventListener.stop();\n        this.logger?.info('EmailEventListener stopped');\n      }\n\n      if (this.messageHandler) {\n        this.messageHandler.stop();\n        this.logger?.info('MessageHandler stopped');\n      }\n\n      if (this.analysisHistoryHandler) {\n        this.analysisHistoryHandler.stop();\n        this.logger?.info('AnalysisHistoryHandler stopped');\n      }\n\n      if (this.reviewQueueHandler) {\n        this.reviewQueueHandler.stop();\n        this.logger?.info('ReviewQueueHandler stopped');\n      }\n\n      this.isInitialized = false;\n      this.logger?.info('Background script shutdown completed successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      startupLogger.error('Failed to shutdown background script', error);\n      throw new Error(`Background script shutdown failed: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - DI Container Setup\n  // ==========================================================================\n\n  /**\n   * Sets up TSyringe DI container.\n   */\n  private setupDIContainer(): void {\n    startupLogger.info('Setting up DI container...');\n\n    // ------------------------------------------------------------------------\n    // Register Core Interfaces\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton<ILogger>('ILogger', ConsoleLogger);\n    container.registerSingleton<ICache>('ICache', MemoryCache);\n    container.registerSingleton<IQueue>('IQueue', PriorityQueue);\n    container.registerSingleton<IMailReader>('IMailReader', ThunderbirdMailReader);\n    container.registerSingleton<ITagManager>('ITagManager', ThunderbirdTagManager);\n    container.registerSingleton<IConfigRepository>('IConfigRepository', IndexedDBConfigRepository);\n    container.registerSingleton<IAnalysisHistoryRepository>(\n      'IAnalysisHistoryRepository',\n      AnalysisHistoryRepository\n    );\n    container.registerSingleton<IReviewQueueRepository>(\n      'IReviewQueueRepository',\n      ReviewQueueRepository\n    );\n\n    startupLogger.info('Core interfaces registered');\n\n    // ------------------------------------------------------------------------\n    // Register Services\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('ProviderFactory', ProviderFactory);\n    container.registerSingleton('EmailContentExtractor', EmailContentExtractor);\n    container.registerSingleton('TagService', TagService);\n    container.registerSingleton('AppConfigService', AppConfigService);\n    container.registerSingleton('RateLimiterService', RateLimiterService);\n\n    startupLogger.info('Services registered');\n\n    // ------------------------------------------------------------------------\n    // Register Use Cases\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('AnalyzeEmail', AnalyzeEmail);\n    container.registerSingleton('ApplyTagsToEmail', ApplyTagsToEmail);\n    container.registerSingleton('AnalyzeBatchEmails', AnalyzeBatchEmails);\n\n    startupLogger.info('Use cases registered');\n\n    // ------------------------------------------------------------------------\n    // Register Background Services\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('EmailEventListener', EmailEventListener);\n    container.registerSingleton('MessageHandler', MessageHandler);\n    container.registerSingleton('AnalysisHistoryHandler', AnalysisHistoryHandler);\n    container.registerSingleton('ReviewQueueHandler', ReviewQueueHandler);\n\n    startupLogger.info('Background services registered');\n    startupLogger.info('DI container setup completed');\n  }\n\n  // ==========================================================================\n  // Private Methods - Context Menus\n  // ==========================================================================\n\n  /**\n   * Registers Thunderbird context menus.\n   */\n  private registerContextMenus(): void {\n    this.logger?.info('Registering context menus...');\n\n    try {\n      // Folder context menu: \"Analysiere diesen Ordner\"\n      messenger.menus.create(\n        {\n          id: 'batch-analyze-folder',\n          title: 'Analysiere diesen Ordner',\n          contexts: ['folder_pane'],\n          visible: true,\n        },\n        () => {\n          if (browser.runtime && browser.runtime.lastError) {\n            this.logger?.error('Failed to create folder context menu', browser.runtime.lastError);\n          } else {\n            this.logger?.info('Folder context menu registered');\n          }\n        }\n      );\n\n      // Message list context menu: \"AI-Analyse\"\n      messenger.menus.create(\n        {\n          id: 'analyze-single-message-list',\n          title: 'AI-Analyse',\n          contexts: ['message_list'],\n          visible: true,\n        },\n        () => {\n          if (browser.runtime && browser.runtime.lastError) {\n            this.logger?.error(\n              'Failed to create message list context menu',\n              browser.runtime.lastError\n            );\n          } else {\n            this.logger?.info('Message list context menu registered');\n          }\n        }\n      );\n\n      // Message display context menu: \"AI-Analyse\"\n      messenger.menus.create(\n        {\n          id: 'analyze-single-message-display',\n          title: 'AI-Analyse',\n          contexts: ['message_display_action_menu'],\n          visible: true,\n        },\n        () => {\n          if (browser.runtime && browser.runtime.lastError) {\n            this.logger?.error(\n              'Failed to create message display context menu',\n              browser.runtime.lastError\n            );\n          } else {\n            this.logger?.info('Message display context menu registered');\n          }\n        }\n      );\n\n      // Register context menu click handler\n      messenger.menus.onClicked.addListener(this.handleContextMenuClick.bind(this));\n\n      this.logger?.info('All context menus registered successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to register context menus', { error: errorMessage });\n    }\n  }\n\n  /**\n   * Handles context menu clicks.\n   */\n  private async handleContextMenuClick(info: FolderMenuOnClickData, _tab: Tab): Promise<void> {\n    // Extract message data for proper access to messages array\n    const messageData = info.selectedMessages;\n\n    // Detailed debug logging before any conditions\n    this.logger?.info('Context menu clicked', {\n      menuItemId: info.menuItemId,\n      menuItemIdType: typeof info.menuItemId,\n      hasSelectedMessages: messageData !== undefined,\n      hasMessagesProperty: messageData?.messages !== undefined,\n      messageCount: messageData?.messages?.length ?? 0,\n      hasSelectedFolders: info.selectedFolders !== undefined,\n      folderCount: info.selectedFolders?.length ?? 0,\n      fullInfo: info,\n    });\n\n    try {\n      if (typeof info.menuItemId !== 'string') {\n        this.logger?.warn('Invalid menuItemId type', { menuItemId: info.menuItemId });\n        return;\n      }\n\n      const menuItemId = info.menuItemId as string;\n\n      // Handle folder batch analysis\n      if (menuItemId === 'batch-analyze-folder') {\n        if (!info.selectedFolders) {\n          this.logger?.warn('Folder batch analysis requested but no folders selected', {\n            menuItemId,\n          });\n          return;\n        }\n\n        const folders = info.selectedFolders;\n        if (folders.length === 0) {\n          this.logger?.warn('Folder batch analysis requested but folder list is empty', {\n            menuItemId,\n            folderCount: 0,\n          });\n          return;\n        }\n\n        const folder = folders[0];\n        this.logger?.info('Starting batch analysis for folder', {\n          folderId: folder.id,\n          folderName: folder.name,\n        });\n\n        // Show notification\n        await messenger.notifications.create({\n          type: 'basic',\n          iconUrl: 'icon.png',\n          title: 'Batch-Analysis gestartet',\n          message: `Batch-Analysis f\u00fcr Ordner \"${folder.name}\" gestartet`,\n        });\n\n        try {\n          this.logger?.info('Batch Step 1: Getting provider settings...');\n          const providerSettings = await this.getProviderSettings();\n\n          this.logger?.info('Batch Step 2: Provider settings retrieved', {\n            provider: providerSettings.provider,\n            hasApiKey: !!providerSettings.apiKey,\n          });\n\n          if (!providerSettings.provider) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Fehler',\n              message: 'Kein Provider konfiguriert. Bitte \u00fcberpr\u00fcfen Sie Ihre Einstellungen.',\n            });\n            return;\n          }\n\n          // Get messages to analyze\n          const messageIds = await this.getMessagesToAnalyze(folder.id);\n\n          if (messageIds.length === 0) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Keine Nachrichten',\n              message: `Keine Nachrichten in Ordner \"${folder.name}\" gefunden.`,\n            });\n            return;\n          }\n\n          this.logger?.info('Batch Step 3: Starting batch analysis', {\n            messageCount: messageIds.length,\n          });\n\n          // Direct use case call\n          const result = await this.analyzeBatch!.execute(messageIds, {\n            providerSettings,\n            priority: 1,\n            concurrency: 3,\n          });\n\n          this.logger?.info('Batch analysis completed successfully', {\n            total: result.total,\n            successful: result.successCount,\n            failed: result.failureCount,\n          });\n\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Batch-Analysis abgeschlossen',\n            message: `Analyzed ${result.successCount}/${result.total} messages successfully.`,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          const errorStack = error instanceof Error ? error.stack : undefined;\n          this.logger?.error('Failed to execute batch analysis', {\n            error: errorMessage,\n            stack: errorStack,\n          });\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Fehler',\n            message: `Batch-Analyse fehlgeschlagen: ${errorMessage}`,\n          });\n        }\n        return;\n      }\n\n      // Handle single message analysis\n      if (\n        menuItemId === 'analyze-single-message-list' ||\n        menuItemId === 'analyze-single-message-display'\n      ) {\n        if (!messageData) {\n          this.logger?.warn('Single message analysis requested but no messages selected', {\n            menuItemId,\n          });\n          return;\n        }\n\n        const messages = messageData.messages || [];\n        if (messages.length === 0) {\n          this.logger?.warn('Single message analysis requested but message list is empty', {\n            menuItemId,\n            messageCount: 0,\n          });\n          return;\n        }\n\n        const messageId = messages[0].id;\n        this.logger?.info('Starting single message analysis', { messageId });\n\n        // Show notification\n        await messenger.notifications.create({\n          type: 'basic',\n          iconUrl: 'icon.png',\n          title: 'Analyse gestartet',\n          message: `Analyse f\u00fcr Nachricht ${messageId} gestartet`,\n        });\n\n        try {\n          this.logger?.info('Step 1: Getting provider settings...');\n          const providerSettings = await this.getProviderSettings();\n\n          this.logger?.info('Step 2: Provider settings retrieved', {\n            provider: providerSettings.provider,\n            hasApiKey: !!providerSettings.apiKey,\n          });\n\n          if (!providerSettings.provider) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Fehler',\n              message: 'Kein Provider konfiguriert. Bitte \u00fcberpr\u00fcfen Sie Ihre Einstellungen.',\n            });\n            return;\n          }\n\n          this.logger?.info('Step 3: Calling analyzeEmail.execute()...');\n          const result = await this.analyzeEmail!.execute(String(messageId), providerSettings);\n\n          this.logger?.info('Single message analysis completed successfully', {\n            messageId,\n            tags: result.tags,\n            confidence: result.confidence_score,\n          });\n\n          // Display notification with analysis results including confidence scores\n          await this.showAnalysisResultNotification(result, String(messageId));\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          const errorStack = error instanceof Error ? error.stack : undefined;\n          this.logger?.error('Failed to analyze single message', {\n            messageId,\n            error: errorMessage,\n            stack: errorStack,\n          });\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Fehler',\n            message: `Analyse fehlgeschlagen: ${errorMessage}`,\n          });\n        }\n        return;\n      }\n\n      this.logger?.warn('Unknown context menu item', {\n        menuItemId,\n        hasSelectedMessages: messageData !== undefined,\n        hasSelectedFolders: info.selectedFolders !== undefined,\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const errorStack = error instanceof Error ? error.stack : undefined;\n      this.logger?.error('[DEBUG-background] Failed to handle context menu click', {\n        error: errorMessage,\n        stack: errorStack,\n      });\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Toolbar Button\n  // ==========================================================================\n\n  /**\n   * Registers toolbar button click handler.\n   */\n  private registerToolbarButton(): void {\n    this.logger?.info('Registering toolbar button...');\n\n    const browserAction = messenger.browserAction || messenger.action;\n\n    if (browserAction && browserAction.onClicked) {\n      browserAction.onClicked.addListener(async (tab: Tab) => {\n        this.logger?.info('Toolbar button clicked', { tabId: tab.id });\n\n        try {\n          const displayedMessage = await messenger.messageDisplay.getDisplayedMessage(tab.id);\n\n          if (!displayedMessage) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Keine Nachricht',\n              message: 'Keine Nachricht in diesem Tab angezeigt',\n            });\n            return;\n          }\n\n          const messageId = displayedMessage.id;\n          this.logger?.info('Toolbar button: Starting single message analysis', { messageId });\n\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Analyse gestartet',\n            message: `Analyse f\u00fcr Nachricht ${messageId} gestartet`,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          this.logger?.error('Failed to handle toolbar button click', { error: errorMessage });\n        }\n      });\n\n      this.logger?.info('Toolbar button registered successfully');\n    } else {\n      this.logger?.warn('Browser action API not available for toolbar button');\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Install Handler\n  // ==========================================================================\n\n  /**\n   * Registers onInstalled handler for extension install/update.\n   */\n  private registerInstallHandler(): void {\n    this.logger?.info('Registering onInstalled handler...');\n\n    if (messenger.runtime && messenger.runtime.onInstalled) {\n      messenger.runtime.onInstalled.addListener(async (details) => {\n        if (details.reason === 'install') {\n          this.logger?.info('Extension installed, initializing default settings...');\n\n          try {\n            const configRepository = container.resolve<IConfigRepository>('IConfigRepository');\n\n            try {\n              await configRepository.getAppConfig();\n              this.logger?.info('App config already exists, skipping defaults');\n            } catch {\n              this.logger?.info('Setting default app config');\n              await configRepository.setAppConfig({\n                defaultProvider: 'ollama',\n                enableNotifications: true,\n                enableLogging: false,\n                modelConcurrencyLimits: undefined,\n                confidenceThreshold: 70,\n              });\n            }\n\n            try {\n              await configRepository.getProviderSettings('ollama');\n              this.logger?.info('Ollama provider settings already exist, skipping defaults');\n            } catch {\n              this.logger?.info('Setting default ollama provider settings');\n              await configRepository.setProviderSettings('ollama', {\n                apiKey: '',\n                model: 'gemma3:27b',\n                apiUrl: 'http://localhost:11434/api/generate',\n              });\n            }\n\n            this.logger?.info('Default configuration initialized successfully');\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            this.logger?.error('Failed to initialize default configuration', {\n              error: errorMessage,\n            });\n          }\n        }\n      });\n    } else {\n      this.logger?.warn('Runtime onInstalled handler not available');\n    }\n\n    this.logger?.info('Install handler registered');\n  }\n\n  // ==========================================================================\n  // Private Methods - Shutdown Handler\n  // ==========================================================================\n\n  /**\n   * Registers shutdown handler for extension cleanup.\n   */\n  private registerShutdownHandler(): void {\n    this.logger?.info('Registering shutdown handler...');\n\n    if (messenger.runtime && messenger.runtime.onSuspend) {\n      messenger.runtime.onSuspend.addListener(async () => {\n        this.logger?.info('Extension suspending, cleaning up...');\n        await this.shutdown();\n      });\n    } else {\n      this.logger?.warn('Runtime suspend handler not available');\n    }\n\n    this.logger?.info('Shutdown handler registered');\n  }\n\n  // ==========================================================================\n  // Private Methods - Helper for Context Menu Handlers\n  // ==========================================================================\n\n  /**\n   * Gets provider settings from app config.\n   *\n   * @returns Provider settings\n   */\n  private async getProviderSettings(): Promise<IProviderSettings> {\n    if (!this.appConfigService) {\n      throw new Error('AppConfigService not initialized');\n    }\n\n    try {\n      this.logger?.info('Attempting to get app config...');\n      const appConfig = await this.appConfigService.getAppConfig();\n      const defaultProvider = appConfig.defaultProvider;\n\n      this.logger?.info('App config retrieved', { defaultProvider });\n\n      this.logger?.info(`Attempting to get provider settings for: ${defaultProvider}`);\n      const providerSettings = await this.appConfigService.getProviderSettings(defaultProvider);\n\n      this.logger?.info('Provider settings retrieved', {\n        apiKey: providerSettings.apiKey ? '***' : 'missing',\n      });\n\n      return {\n        provider: defaultProvider,\n        apiKey: providerSettings.apiKey,\n        model: providerSettings.model,\n        apiUrl: providerSettings.apiUrl,\n        additionalConfig: providerSettings.additionalConfig,\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const errorStack = error instanceof Error ? error.stack : undefined;\n      this.logger?.error('Failed to get provider settings', {\n        error: errorMessage,\n        stack: errorStack,\n      });\n      this.logger?.error('Returning empty provider settings - THIS WILL CAUSE ANALYSIS TO FAIL');\n      return { provider: '' };\n    }\n  }\n\n  /**\n   * Gets messages to analyze from folder.\n   *\n   * @param folderId - Folder ID\n   * @returns Array of message IDs\n   */\n  private async getMessagesToAnalyze(folderId: string): Promise<string[]> {\n    try {\n      const messages = await messenger.messages.list(folderId);\n      return messages.messages.map((message) => String(message.id));\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to get messages from folder', { folderId, error: errorMessage });\n      return [];\n    }\n  }\n\n  /**\n   * Displays a notification with analysis results including confidence scores.\n   *\n   * Formats the analysis result to show tags with their confidence percentage,\n   * clearly distinguishing between auto-applied tags and tags requiring manual review\n   * due to low confidence scores.\n   *\n   * @param result - Analysis result containing tags and confidence score\n   * @param messageId - Message ID that was analyzed\n   */\n  private async showAnalysisResultNotification(result: ITagResponse, messageId: string): Promise<void> {\n    try {\n      const { tags, confidence_score } = result;\n\n      if (tags.length === 0) {\n        await messenger.notifications.create({\n          type: 'basic',\n          iconUrl: 'icon.png',\n          title: 'Analyse abgeschlossen',\n          message: `Nachricht ${messageId}: Keine Tags gefunden.`,\n        });\n        return;\n      }\n\n      // Get ApplyTagsToEmail use case to filter tags by threshold\n      const applyTagsToEmail = container.resolve<ApplyTagsToEmail>(ApplyTagsToEmail);\n      const filterResult = await applyTagsToEmail.filterTagsByThreshold(result);\n\n      // Build notification message with clear distinction between applied and filtered tags\n      let message = `Nachricht ${messageId}\\n\\n`;\n\n      // Show auto-applied tags\n      if (filterResult.autoApplyTags.length > 0) {\n        message += `\u2713 Angewendet: ${filterResult.autoApplyTags.join(', ')}\\n`;\n      }\n\n      // Show tags requiring manual review (below threshold)\n      if (filterResult.manualReviewTags.length > 0) {\n        message += `\\n\u26a0 Manuelle Pr\u00fcfung erforderlich:\\n`;\n        for (const item of filterResult.manualReviewTags) {\n          message += `  \u2022 ${item.tag} (${item.confidence}% < ${item.threshold}%)\\n`;\n        }\n      }\n\n      // Add overall confidence summary\n      let confidenceIndicator: string;\n      let confidenceLevel: string;\n\n      if (confidence_score >= 80) {\n        confidenceIndicator = '\ud83d\udfe2'; // Green - high confidence\n        confidenceLevel = 'Hoch';\n      } else if (confidence_score >= 60) {\n        confidenceIndicator = '\ud83d\udfe1'; // Yellow - medium confidence\n        confidenceLevel = 'Mittel';\n      } else {\n        confidenceIndicator = '\ud83d\udfe0'; // Orange - low confidence\n        confidenceLevel = 'Niedrig';\n      }\n\n      message += `\\nGesamt-Konfidenz: ${confidence_score}% (${confidenceLevel}) ${confidenceIndicator}`;\n\n      await messenger.notifications.create({\n        type: 'basic',\n        iconUrl: 'icon.png',\n        title: 'Analyse abgeschlossen',\n        message,\n      });\n\n      this.logger?.info('Analysis result notification displayed with threshold filtering', {\n        messageId,\n        totalTags: tags.length,\n        appliedTags: filterResult.autoApplyTags.length,\n        manualReviewTags: filterResult.manualReviewTags.length,\n        confidence: confidence_score,\n        confidenceLevel,\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to display analysis result notification', {\n        messageId,\n        error: errorMessage,\n      });\n    }\n  }\n}\n\n// ============================================================================\n// Extension Entry Point\n// ============================================================================\n\n/**\n * Main extension entry point.\n */\n(async function main(): Promise<void> {\n  startupLogger.info('Thunderbird Email AI Assistant - Background Script Loading');\n\n  try {\n    const backgroundScript = new BackgroundScript();\n    await backgroundScript.initialize();\n\n    startupLogger.info('Thunderbird Email AI Assistant - Ready');\n  } catch (error) {\n    startupLogger.error('Failed to start extension', error);\n\n    try {\n      if (typeof messenger !== 'undefined' && messenger.notifications) {\n        await messenger.notifications.create({\n          type: 'basic',\n          iconUrl: 'icon.png',\n          title: 'Fehler beim Starten',\n          message:\n            'Die Erweiterung konnte nicht gestartet werden. Bitte \u00fcberpr\u00fcfen Sie die Konsole.',\n        });\n      }\n    } catch {\n      // Ignore notification errors during startup\n    }\n\n    throw error;\n  }\n})();\n\n// ============================================================================\n// Export for Testing\n// ============================================================================\n\nexport { BackgroundScript };\n",
        "last_modified": "2026-01-05T19:59:00.200464"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "010-confidence-score-display-and-threshold-configurati": {
      "task_id": "010-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "bdfad3eb512d2cde785819b3e597f39d954633f3",
        "content": "/**\n * Thunderbird Email AI Assistant - Background Script\n *\n * Thin delegator that sets up Dependency Injection and delegates to\n * EmailEventListener and MessageHandler services.\n *\n * @module background\n */\n\nimport 'reflect-metadata';\nimport { container, injectable } from 'tsyringe';\n\n// ============================================================================\n// Core Interfaces\n// ============================================================================\n\nimport type { ILogger } from './src/infrastructure/interfaces/ILogger';\nimport type { ICache } from './src/infrastructure/interfaces/ICache';\nimport type { IQueue } from './src/infrastructure/interfaces/IQueue';\nimport type { IMailReader } from './src/infrastructure/interfaces/IMailReader';\nimport type { ITagManager } from './src/infrastructure/interfaces/ITagManager';\nimport type { IConfigRepository } from './src/infrastructure/interfaces/IConfigRepository';\n\n// ============================================================================\n// Core Implementations\n// ============================================================================\n\nimport { ConsoleLogger } from './src/infrastructure/logger/ConsoleLogger';\nimport { MemoryCache } from './src/infrastructure/cache/MemoryCache';\nimport { PriorityQueue } from './src/application/services/PriorityQueue';\nimport { ThunderbirdMailReader } from './src/interfaces/adapters/ThunderbirdMailReader';\nimport { ThunderbirdTagManager } from './src/interfaces/adapters/ThunderbirdTagManager';\nimport { IndexedDBConfigRepository } from './src/infrastructure/repositories/IndexedDBConfigRepository';\n\n// ============================================================================\n// Services\n// ============================================================================\n\nimport { EmailContentExtractor } from './src/domain/services/EmailContentExtractor';\nimport { TagService } from './src/domain/services/TagService';\nimport { AppConfigService } from './src/infrastructure/config/AppConfig';\nimport { RateLimiterService } from './src/application/services/RateLimiterService';\nimport { ProviderFactory } from './src/infrastructure/providers/ProviderFactory';\n\n// ============================================================================\n// Domain Types\n// ============================================================================\n\nimport type { IProviderSettings } from './src/infrastructure/interfaces/IProvider';\n\n// ============================================================================\n// Use Cases\n// ============================================================================\n\nimport { AnalyzeEmail } from './src/application/use-cases/AnalyzeEmail';\nimport { ApplyTagsToEmail } from './src/application/use-cases/ApplyTagsToEmail';\nimport { AnalyzeBatchEmails } from './src/application/use-cases/AnalyzeBatchEmails';\n\n// ============================================================================\n// Background Services\n// ============================================================================\n\nimport { EmailEventListener } from './src/interfaces/background/EmailEventListener';\nimport { MessageHandler } from './src/interfaces/background/MessageHandler';\n\n// ============================================================================\n// Types for Context Menu (Thunderbird API)\n// ============================================================================\n\n/**\n * Thunderbird folder structure for context menus.\n */\ninterface ThunderbirdFolder {\n  accountId: string;\n  id: string;\n  path: string;\n  name: string;\n  type: string;\n}\n\n/**\n * Folder menu click data.\n */\ninterface FolderMenuOnClickData {\n  menuItemId: string | number;\n  selectedFolders?: ThunderbirdFolder[];\n  modifiers: string[];\n  selectedMessages?: {\n    id: number | null;\n    messages: Array<{ id: number; date: string }>;\n  };\n}\n\n/**\n * Tab interface for browser tabs.\n */\ninterface Tab {\n  id: number;\n  type: string;\n  index?: number;\n  windowId?: number;\n  selected?: boolean;\n}\n\n// ============================================================================\n// Global Declarations (Thunderbird API)\n// ============================================================================\n\ndeclare const messenger: {\n  messages: {\n    onNewMailReceived: {\n      addListener(\n        callback: (folder: ThunderbirdFolder, messages: { messages: Array<{ id: number }> }) => void\n      ): void;\n    };\n    getFull(messageId: number): Promise<unknown>;\n    list(folderId?: string): Promise<{ messages: Array<{ id: number }> }>;\n    get(messageId: number): Promise<{ id: number; tags?: string[] }>;\n    update(messageId: number, properties: { tags: string[] }): Promise<void>;\n  };\n  messageDisplay: {\n    getDisplayedMessage(tabId?: number): Promise<{ id: number } | null>;\n  };\n  storage: {\n    local: {\n      get(keys?: Record<string, unknown> | string[] | string): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n  runtime: {\n    onInstalled: {\n      addListener(callback: (details: { reason: string }) => void): void;\n    };\n    onSuspend: {\n      addListener(callback: () => void): void;\n    };\n    sendMessage(message: {\n      action: string;\n      folderId?: string;\n      messageId?: string;\n    }): Promise<unknown>;\n  };\n  menus: {\n    create(createProperties: Record<string, unknown>, callback?: () => void): void;\n    onClicked: {\n      addListener(callback: (info: FolderMenuOnClickData, tab: Tab) => void): void;\n    };\n  };\n  browserAction?: {\n    onClicked?: {\n      addListener(callback: (tab: Tab) => void): void;\n    };\n  };\n  action?: {\n    onClicked?: {\n      addListener(callback: (tab: Tab) => void): void;\n    };\n  };\n  notifications: {\n    create(options: {\n      type: string;\n      iconUrl: string;\n      title: string;\n      message: string;\n    }): Promise<string>;\n  };\n};\n\ndeclare const browser: {\n  runtime?: {\n    lastError?: { message: string };\n  };\n};\n\n// ============================================================================\n// Logger Wrapper (for startup before DI container)\n// ============================================================================\n\n/**\n * Simple console logger for startup before DI container is ready.\n */\nconst startupLogger = {\n  info: (message: string, meta?: Record<string, unknown>) => {\n    console.log(`[Background Startup] ${message}`, meta || '');\n  },\n  warn: (message: string, meta?: Record<string, unknown>) => {\n    console.warn(`[Background Startup] ${message}`, meta || '');\n  },\n  error: (message: string, error?: unknown) => {\n    console.error(`[Background Startup] ${message}`, error || '');\n  },\n};\n\n// ============================================================================\n// Background Script Main Class\n// ============================================================================\n\n/**\n * Background Script Main Class\n *\n * @class BackgroundScript\n */\n@injectable()\nclass BackgroundScript {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private eventListener: EmailEventListener | null = null;\n  private messageHandler: MessageHandler | null = null;\n  private logger: ILogger | null = null;\n  private analyzeEmail: AnalyzeEmail | null = null;\n  private analyzeBatch: AnalyzeBatchEmails | null = null;\n  private appConfigService: AppConfigService | null = null;\n  private isInitialized = false;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor() {\n    startupLogger.info('BackgroundScript class instantiated');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Initializes the background script.\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      startupLogger.warn('Background script already initialized');\n      return;\n    }\n\n    startupLogger.info('Initializing background script...');\n\n    try {\n      // Step 1: Setup DI container\n      this.setupDIContainer();\n\n      // Step 2: Resolve logger\n      this.logger = container.resolve<ILogger>('ILogger');\n      this.logger.info('Background script initialization started');\n\n      // Step 3: Resolve background services\n      this.eventListener = container.resolve<EmailEventListener>(EmailEventListener);\n      this.messageHandler = container.resolve<MessageHandler>(MessageHandler);\n\n      // Step 3.5: Resolve use cases and config service for context menu handlers\n      this.analyzeEmail = container.resolve<AnalyzeEmail>(AnalyzeEmail);\n      this.analyzeBatch = container.resolve<AnalyzeBatchEmails>(AnalyzeBatchEmails);\n      this.appConfigService = container.resolve<AppConfigService>(AppConfigService);\n\n      // Step 4: Start background services\n      this.eventListener.start();\n      this.messageHandler.start();\n\n      // Step 5: Register context menus\n      this.registerContextMenus();\n\n      // Step 6: Register toolbar button\n      this.registerToolbarButton();\n\n      // Step 7: Register onInstalled handler\n      this.registerInstallHandler();\n\n      // Step 8: Register shutdown handler\n      this.registerShutdownHandler();\n\n      this.isInitialized = true;\n      this.logger.info('Background script initialization completed successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      startupLogger.error('Failed to initialize background script', error);\n      throw new Error(`Background script initialization failed: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Shutdowns the background script.\n   */\n  async shutdown(): Promise<void> {\n    if (!this.isInitialized) {\n      startupLogger.warn('Background script not initialized, nothing to shutdown');\n      return;\n    }\n\n    startupLogger.info('Shutting down background script...');\n\n    try {\n      if (this.eventListener) {\n        this.eventListener.stop();\n        this.logger?.info('EmailEventListener stopped');\n      }\n\n      if (this.messageHandler) {\n        this.messageHandler.stop();\n        this.logger?.info('MessageHandler stopped');\n      }\n\n      this.isInitialized = false;\n      this.logger?.info('Background script shutdown completed successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      startupLogger.error('Failed to shutdown background script', error);\n      throw new Error(`Background script shutdown failed: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - DI Container Setup\n  // ==========================================================================\n\n  /**\n   * Sets up TSyringe DI container.\n   */\n  private setupDIContainer(): void {\n    startupLogger.info('Setting up DI container...');\n\n    // ------------------------------------------------------------------------\n    // Register Core Interfaces\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton<ILogger>('ILogger', ConsoleLogger);\n    container.registerSingleton<ICache>('ICache', MemoryCache);\n    container.registerSingleton<IQueue>('IQueue', PriorityQueue);\n    container.registerSingleton<IMailReader>('IMailReader', ThunderbirdMailReader);\n    container.registerSingleton<ITagManager>('ITagManager', ThunderbirdTagManager);\n    container.registerSingleton<IConfigRepository>('IConfigRepository', IndexedDBConfigRepository);\n\n    startupLogger.info('Core interfaces registered');\n\n    // ------------------------------------------------------------------------\n    // Register Services\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('ProviderFactory', ProviderFactory);\n    container.registerSingleton('EmailContentExtractor', EmailContentExtractor);\n    container.registerSingleton('TagService', TagService);\n    container.registerSingleton('AppConfigService', AppConfigService);\n    container.registerSingleton('RateLimiterService', RateLimiterService);\n\n    startupLogger.info('Services registered');\n\n    // ------------------------------------------------------------------------\n    // Register Use Cases\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('AnalyzeEmail', AnalyzeEmail);\n    container.registerSingleton('ApplyTagsToEmail', ApplyTagsToEmail);\n    container.registerSingleton('AnalyzeBatchEmails', AnalyzeBatchEmails);\n\n    startupLogger.info('Use cases registered');\n\n    // ------------------------------------------------------------------------\n    // Register Background Services\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('EmailEventListener', EmailEventListener);\n    container.registerSingleton('MessageHandler', MessageHandler);\n\n    startupLogger.info('Background services registered');\n    startupLogger.info('DI container setup completed');\n  }\n\n  // ==========================================================================\n  // Private Methods - Context Menus\n  // ==========================================================================\n\n  /**\n   * Registers Thunderbird context menus.\n   */\n  private registerContextMenus(): void {\n    this.logger?.info('Registering context menus...');\n\n    try {\n      // Folder context menu: \"Analysiere diesen Ordner\"\n      messenger.menus.create(\n        {\n          id: 'batch-analyze-folder',\n          title: 'Analysiere diesen Ordner',\n          contexts: ['folder_pane'],\n          visible: true,\n        },\n        () => {\n          if (browser.runtime && browser.runtime.lastError) {\n            this.logger?.error('Failed to create folder context menu', browser.runtime.lastError);\n          } else {\n            this.logger?.info('Folder context menu registered');\n          }\n        }\n      );\n\n      // Message list context menu: \"AI-Analyse\"\n      messenger.menus.create(\n        {\n          id: 'analyze-single-message-list',\n          title: 'AI-Analyse',\n          contexts: ['message_list'],\n          visible: true,\n        },\n        () => {\n          if (browser.runtime && browser.runtime.lastError) {\n            this.logger?.error(\n              'Failed to create message list context menu',\n              browser.runtime.lastError\n            );\n          } else {\n            this.logger?.info('Message list context menu registered');\n          }\n        }\n      );\n\n      // Message display context menu: \"AI-Analyse\"\n      messenger.menus.create(\n        {\n          id: 'analyze-single-message-display',\n          title: 'AI-Analyse',\n          contexts: ['message_display_action_menu'],\n          visible: true,\n        },\n        () => {\n          if (browser.runtime && browser.runtime.lastError) {\n            this.logger?.error(\n              'Failed to create message display context menu',\n              browser.runtime.lastError\n            );\n          } else {\n            this.logger?.info('Message display context menu registered');\n          }\n        }\n      );\n\n      // Register context menu click handler\n      messenger.menus.onClicked.addListener(this.handleContextMenuClick.bind(this));\n\n      this.logger?.info('All context menus registered successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to register context menus', { error: errorMessage });\n    }\n  }\n\n  /**\n   * Handles context menu clicks.\n   */\n  private async handleContextMenuClick(info: FolderMenuOnClickData, _tab: Tab): Promise<void> {\n    // Extract message data for proper access to messages array\n    const messageData = info.selectedMessages;\n\n    // Detailed debug logging before any conditions\n    this.logger?.info('Context menu clicked', {\n      menuItemId: info.menuItemId,\n      menuItemIdType: typeof info.menuItemId,\n      hasSelectedMessages: messageData !== undefined,\n      hasMessagesProperty: messageData?.messages !== undefined,\n      messageCount: messageData?.messages?.length ?? 0,\n      hasSelectedFolders: info.selectedFolders !== undefined,\n      folderCount: info.selectedFolders?.length ?? 0,\n      fullInfo: info,\n    });\n\n    try {\n      if (typeof info.menuItemId !== 'string') {\n        this.logger?.warn('Invalid menuItemId type', { menuItemId: info.menuItemId });\n        return;\n      }\n\n      const menuItemId = info.menuItemId as string;\n\n      // Handle folder batch analysis\n      if (menuItemId === 'batch-analyze-folder') {\n        if (!info.selectedFolders) {\n          this.logger?.warn('Folder batch analysis requested but no folders selected', {\n            menuItemId,\n          });\n          return;\n        }\n\n        const folders = info.selectedFolders;\n        if (folders.length === 0) {\n          this.logger?.warn('Folder batch analysis requested but folder list is empty', {\n            menuItemId,\n            folderCount: 0,\n          });\n          return;\n        }\n\n        const folder = folders[0];\n        this.logger?.info('Starting batch analysis for folder', {\n          folderId: folder.id,\n          folderName: folder.name,\n        });\n\n        // Show notification\n        await messenger.notifications.create({\n          type: 'basic',\n          iconUrl: 'icon.png',\n          title: 'Batch-Analysis gestartet',\n          message: `Batch-Analysis f\u00fcr Ordner \"${folder.name}\" gestartet`,\n        });\n\n        try {\n          this.logger?.info('Batch Step 1: Getting provider settings...');\n          const providerSettings = await this.getProviderSettings();\n\n          this.logger?.info('Batch Step 2: Provider settings retrieved', {\n            provider: providerSettings.provider,\n            hasApiKey: !!providerSettings.apiKey,\n          });\n\n          if (!providerSettings.provider) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Fehler',\n              message: 'Kein Provider konfiguriert. Bitte \u00fcberpr\u00fcfen Sie Ihre Einstellungen.',\n            });\n            return;\n          }\n\n          // Get messages to analyze\n          const messageIds = await this.getMessagesToAnalyze(folder.id);\n\n          if (messageIds.length === 0) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Keine Nachrichten',\n              message: `Keine Nachrichten in Ordner \"${folder.name}\" gefunden.`,\n            });\n            return;\n          }\n\n          this.logger?.info('Batch Step 3: Starting batch analysis', {\n            messageCount: messageIds.length,\n          });\n\n          // Direct use case call\n          const result = await this.analyzeBatch!.execute(messageIds, {\n            providerSettings,\n            priority: 1,\n            concurrency: 3,\n          });\n\n          this.logger?.info('Batch analysis completed successfully', {\n            total: result.total,\n            successful: result.successCount,\n            failed: result.failureCount,\n          });\n\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Batch-Analysis abgeschlossen',\n            message: `Analyzed ${result.successCount}/${result.total} messages successfully.`,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          const errorStack = error instanceof Error ? error.stack : undefined;\n          this.logger?.error('Failed to execute batch analysis', {\n            error: errorMessage,\n            stack: errorStack,\n          });\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Fehler',\n            message: `Batch-Analyse fehlgeschlagen: ${errorMessage}`,\n          });\n        }\n        return;\n      }\n\n      // Handle single message analysis\n      if (\n        menuItemId === 'analyze-single-message-list' ||\n        menuItemId === 'analyze-single-message-display'\n      ) {\n        if (!messageData) {\n          this.logger?.warn('Single message analysis requested but no messages selected', {\n            menuItemId,\n          });\n          return;\n        }\n\n        const messages = messageData.messages || [];\n        if (messages.length === 0) {\n          this.logger?.warn('Single message analysis requested but message list is empty', {\n            menuItemId,\n            messageCount: 0,\n          });\n          return;\n        }\n\n        const messageId = messages[0].id;\n        this.logger?.info('Starting single message analysis', { messageId });\n\n        // Show notification\n        await messenger.notifications.create({\n          type: 'basic',\n          iconUrl: 'icon.png',\n          title: 'Analyse gestartet',\n          message: `Analyse f\u00fcr Nachricht ${messageId} gestartet`,\n        });\n\n        try {\n          this.logger?.info('Step 1: Getting provider settings...');\n          const providerSettings = await this.getProviderSettings();\n\n          this.logger?.info('Step 2: Provider settings retrieved', {\n            provider: providerSettings.provider,\n            hasApiKey: !!providerSettings.apiKey,\n          });\n\n          if (!providerSettings.provider) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Fehler',\n              message: 'Kein Provider konfiguriert. Bitte \u00fcberpr\u00fcfen Sie Ihre Einstellungen.',\n            });\n            return;\n          }\n\n          this.logger?.info('Step 3: Calling analyzeEmail.execute()...');\n          const result = await this.analyzeEmail!.execute(String(messageId), providerSettings);\n\n          this.logger?.info('Single message analysis completed successfully', {\n            messageId,\n            tags: result.tags,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          const errorStack = error instanceof Error ? error.stack : undefined;\n          this.logger?.error('Failed to analyze single message', {\n            messageId,\n            error: errorMessage,\n            stack: errorStack,\n          });\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Fehler',\n            message: `Analyse fehlgeschlagen: ${errorMessage}`,\n          });\n        }\n        return;\n      }\n\n      this.logger?.warn('Unknown context menu item', {\n        menuItemId,\n        hasSelectedMessages: messageData !== undefined,\n        hasSelectedFolders: info.selectedFolders !== undefined,\n      });\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const errorStack = error instanceof Error ? error.stack : undefined;\n      this.logger?.error('[DEBUG-background] Failed to handle context menu click', {\n        error: errorMessage,\n        stack: errorStack,\n      });\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Toolbar Button\n  // ==========================================================================\n\n  /**\n   * Registers toolbar button click handler.\n   */\n  private registerToolbarButton(): void {\n    this.logger?.info('Registering toolbar button...');\n\n    const browserAction = messenger.browserAction || messenger.action;\n\n    if (browserAction && browserAction.onClicked) {\n      browserAction.onClicked.addListener(async (tab: Tab) => {\n        this.logger?.info('Toolbar button clicked', { tabId: tab.id });\n\n        try {\n          const displayedMessage = await messenger.messageDisplay.getDisplayedMessage(tab.id);\n\n          if (!displayedMessage) {\n            await messenger.notifications.create({\n              type: 'basic',\n              iconUrl: 'icon.png',\n              title: 'Keine Nachricht',\n              message: 'Keine Nachricht in diesem Tab angezeigt',\n            });\n            return;\n          }\n\n          const messageId = displayedMessage.id;\n          this.logger?.info('Toolbar button: Starting single message analysis', { messageId });\n\n          await messenger.notifications.create({\n            type: 'basic',\n            iconUrl: 'icon.png',\n            title: 'Analyse gestartet',\n            message: `Analyse f\u00fcr Nachricht ${messageId} gestartet`,\n          });\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          this.logger?.error('Failed to handle toolbar button click', { error: errorMessage });\n        }\n      });\n\n      this.logger?.info('Toolbar button registered successfully');\n    } else {\n      this.logger?.warn('Browser action API not available for toolbar button');\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Install Handler\n  // ==========================================================================\n\n  /**\n   * Registers onInstalled handler for extension install/update.\n   */\n  private registerInstallHandler(): void {\n    this.logger?.info('Registering onInstalled handler...');\n\n    if (messenger.runtime && messenger.runtime.onInstalled) {\n      messenger.runtime.onInstalled.addListener(async (details) => {\n        if (details.reason === 'install') {\n          this.logger?.info('Extension installed, initializing default settings...');\n\n          try {\n            const configRepository = container.resolve<IConfigRepository>('IConfigRepository');\n\n            try {\n              await configRepository.getAppConfig();\n              this.logger?.info('App config already exists, skipping defaults');\n            } catch {\n              this.logger?.info('Setting default app config');\n              await configRepository.setAppConfig({\n                defaultProvider: 'ollama',\n                enableNotifications: true,\n                enableLogging: false,\n                modelConcurrencyLimits: undefined,\n              });\n            }\n\n            try {\n              await configRepository.getProviderSettings('ollama');\n              this.logger?.info('Ollama provider settings already exist, skipping defaults');\n            } catch {\n              this.logger?.info('Setting default ollama provider settings');\n              await configRepository.setProviderSettings('ollama', {\n                apiKey: '',\n                model: 'gemma3:27b',\n                apiUrl: 'http://localhost:11434/api/generate',\n              });\n            }\n\n            this.logger?.info('Default configuration initialized successfully');\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            this.logger?.error('Failed to initialize default configuration', {\n              error: errorMessage,\n            });\n          }\n        }\n      });\n    } else {\n      this.logger?.warn('Runtime onInstalled handler not available');\n    }\n\n    this.logger?.info('Install handler registered');\n  }\n\n  // ==========================================================================\n  // Private Methods - Shutdown Handler\n  // ==========================================================================\n\n  /**\n   * Registers shutdown handler for extension cleanup.\n   */\n  private registerShutdownHandler(): void {\n    this.logger?.info('Registering shutdown handler...');\n\n    if (messenger.runtime && messenger.runtime.onSuspend) {\n      messenger.runtime.onSuspend.addListener(async () => {\n        this.logger?.info('Extension suspending, cleaning up...');\n        await this.shutdown();\n      });\n    } else {\n      this.logger?.warn('Runtime suspend handler not available');\n    }\n\n    this.logger?.info('Shutdown handler registered');\n  }\n\n  // ==========================================================================\n  // Private Methods - Helper for Context Menu Handlers\n  // ==========================================================================\n\n  /**\n   * Gets provider settings from app config.\n   *\n   * @returns Provider settings\n   */\n  private async getProviderSettings(): Promise<IProviderSettings> {\n    if (!this.appConfigService) {\n      throw new Error('AppConfigService not initialized');\n    }\n\n    try {\n      this.logger?.info('Attempting to get app config...');\n      const appConfig = await this.appConfigService.getAppConfig();\n      const defaultProvider = appConfig.defaultProvider;\n\n      this.logger?.info('App config retrieved', { defaultProvider });\n\n      this.logger?.info(`Attempting to get provider settings for: ${defaultProvider}`);\n      const providerSettings = await this.appConfigService.getProviderSettings(defaultProvider);\n\n      this.logger?.info('Provider settings retrieved', {\n        apiKey: providerSettings.apiKey ? '***' : 'missing',\n      });\n\n      return {\n        provider: defaultProvider,\n        apiKey: providerSettings.apiKey,\n        model: providerSettings.model,\n        apiUrl: providerSettings.apiUrl,\n        additionalConfig: providerSettings.additionalConfig,\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const errorStack = error instanceof Error ? error.stack : undefined;\n      this.logger?.error('Failed to get provider settings', {\n        error: errorMessage,\n        stack: errorStack,\n      });\n      this.logger?.error('Returning empty provider settings - THIS WILL CAUSE ANALYSIS TO FAIL');\n      return { provider: '' };\n    }\n  }\n\n  /**\n   * Gets messages to analyze from folder.\n   *\n   * @param folderId - Folder ID\n   * @returns Array of message IDs\n   */\n  private async getMessagesToAnalyze(folderId: string): Promise<string[]> {\n    try {\n      const messages = await messenger.messages.list(folderId);\n      return messages.messages.map((message) => String(message.id));\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to get messages from folder', { folderId, error: errorMessage });\n      return [];\n    }\n  }\n}\n\n// ============================================================================\n// Extension Entry Point\n// ============================================================================\n\n/**\n * Main extension entry point.\n */\n(async function main(): Promise<void> {\n  startupLogger.info('Thunderbird Email AI Assistant - Background Script Loading');\n\n  try {\n    const backgroundScript = new BackgroundScript();\n    await backgroundScript.initialize();\n\n    startupLogger.info('Thunderbird Email AI Assistant - Ready');\n  } catch (error) {\n    startupLogger.error('Failed to start extension', error);\n\n    try {\n      if (typeof messenger !== 'undefined' && messenger.notifications) {\n        await messenger.notifications.create({\n          type: 'basic',\n          iconUrl: 'icon.png',\n          title: 'Fehler beim Starten',\n          message:\n            'Die Erweiterung konnte nicht gestartet werden. Bitte \u00fcberpr\u00fcfen Sie die Konsole.',\n        });\n      }\n    } catch {\n      // Ignore notification errors during startup\n    }\n\n    throw error;\n  }\n})();\n\n// ============================================================================\n// Export for Testing\n// ============================================================================\n\nexport { BackgroundScript };\n",
        "timestamp": "2026-01-06T07:24:51.082736"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "010-confidence-score-display-and-threshold-configurati",
        "description": "# Confidence Score Display and Threshold Configuration\n\nDisplay confidence scores for AI classifications and allow users to configure minimum confidence thresholds. Tags are only applied when confidence exceeds the threshold.\n\n## Rationale\nAddresses market gap-5: lack of transparency in AI decisions. Gmail and SaneBox don't explain why emails are categorized (pain-3-3). Users need to understand AI certainty and control when tags are applied to avoid incorrect classifications.\n\n## User Stories\n- As a cautious user, I want to see confidence scores so that I can understand how certain the AI is about its classifications\n- As a power user, I want to set minimum confidence thresholds so that only high-confidence tags are applied automatically\n\n## Acceptance Criteria\n- [ ] Confidence score (0-100%) is displayed alongside each tag suggestion\n- [ ] Global confidence threshold setting in options (default: 70%)\n- [ ] Per-tag confidence threshold override option\n- [ ] Low-confidence classifications are flagged for manual review\n- [ ] Confidence scores are stored with analysis history\n",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.142917",
  "last_updated": "2026-01-06T07:24:51.168974"
}