{
  "file_path": "src/interfaces/options/OptionsScript.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "/**\n * Options Script - DI Container Setup for Options Page\n *\n * Main entry point for options.ts. Sets up dependency injection,\n * initializes UI components, and manages tab navigation.\n *\n * @module interfaces/options/OptionsScript\n */\n\nimport 'reflect-metadata';\nimport { container, injectable } from 'tsyringe';\n\n// ============================================================================\n// Core Interfaces\n// ============================================================================\n\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\nimport type { ITagManager } from '@/infrastructure/interfaces/ITagManager';\nimport type { ICache } from '@/infrastructure/interfaces/ICache';\n\n// ============================================================================\n// Core Implementations\n// ============================================================================\n\nimport { ConsoleLogger } from '@/infrastructure/logger/ConsoleLogger';\nimport { IndexedDBConfigRepository } from '@/infrastructure/repositories/IndexedDBConfigRepository';\nimport { MemoryCache } from '@/infrastructure/cache/MemoryCache';\nimport { ThunderbirdTagManager } from '@/interfaces/adapters/ThunderbirdTagManager';\n\n// ============================================================================\n// Services\n// ============================================================================\n\nimport { ProviderFactory } from '@/infrastructure/providers/ProviderFactory';\nimport { EmailContentExtractor } from '@/domain/services/EmailContentExtractor';\nimport { TagService } from '@/domain/services/TagService';\nimport { AppConfigService } from '@/infrastructure/config/AppConfig';\nimport { RateLimiterService } from '@/application/services/RateLimiterService';\n\n// ============================================================================\n// Use Cases\n// ============================================================================\n\nimport { AnalyzeEmail } from '@/application/use-cases/AnalyzeEmail';\nimport { ApplyTagsToEmail } from '@/application/use-cases/ApplyTagsToEmail';\nimport { AnalyzeBatchEmails } from '@/application/use-cases/AnalyzeBatchEmails';\n\n// ============================================================================\n// Domain Events\n// ============================================================================\n\nimport { EventBus } from '@/domain/events/EventBus';\n\n// ============================================================================\n// UI Components\n// ============================================================================\n\nimport { SettingsForm } from './SettingsForm';\nimport { TagManagementUI } from './TagManagementUI';\nimport { BatchAnalysisUI } from './BatchAnalysisUI';\n\n// ============================================================================\n// DOM Element Interfaces\n// ============================================================================\n\n// ============================================================================\n// Browser API Declarations\n// ============================================================================\n// Browser API Declarations\n// ============================================================================\n\ndeclare const messenger: {\n  storage: {\n    local: {\n      get(keys?: Record<string, unknown> | string[] | string): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n};\n\ninterface CacheStatsResponse {\n  success: boolean;\n  totalEntries?: number;\n  hitRate?: number;\n  message?: string;\n}\n\ninterface CacheClearResponse {\n  success: boolean;\n  message: string;\n}\n\n// ============================================================================\n// Logger Wrapper (for startup before DI container)\n// ============================================================================\n\n/**\n * Simple console logger for startup before DI container is ready.\n */\nconst startupLogger = {\n  info: (message: string, meta?: Record<string, unknown>) => {\n    console.log(`[Options Startup] ${message}`, meta ?? '');\n  },\n  warn: (message: string, meta?: Record<string, unknown>) => {\n    console.warn(`[Options Startup] ${message}`, meta ?? '');\n  },\n  error: (message: string, error?: unknown) => {\n    console.error(`[Options Startup] ${message}`, error ?? '');\n  },\n};\n\n// ============================================================================\n// Options Script Main Class\n// ============================================================================\n\n/**\n * Options Script Main Class\n *\n * Orchestrates the options page initialization by setting up DI container,\n * registering services, and initializing UI components.\n *\n * @class OptionsScript\n */\n@injectable()\nclass OptionsScript {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private settingsForm: SettingsForm | null = null;\n  private tagManagementUI: TagManagementUI | null = null;\n  private batchAnalysisUI: BatchAnalysisUI | null = null;\n  private logger: ILogger | null = null;\n  private eventBus: EventBus | null = null;\n  private isInitialized = false;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor() {\n    startupLogger.info('OptionsScript class instantiated');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Initializes the options page.\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      startupLogger.warn('Options page already initialized');\n      return;\n    }\n\n    startupLogger.info('Initializing options page...');\n\n    try {\n      // Step 1: Setup DI container\n      this.setupDIContainer();\n\n      // Step 2: Resolve logger\n      this.logger = container.resolve<ILogger>('ILogger');\n      this.logger.info('Options page initialization started');\n\n      // Step 3: Resolve event bus\n      this.eventBus = container.resolve<EventBus>(EventBus);\n\n      // Step 4: Resolve UI components\n      this.settingsForm = container.resolve<SettingsForm>(SettingsForm);\n      this.tagManagementUI = container.resolve<TagManagementUI>(TagManagementUI);\n      this.batchAnalysisUI = container.resolve<BatchAnalysisUI>(BatchAnalysisUI);\n\n      // Step 5: Initialize UI components\n      this.initializeTabs();\n      await this.initializeSettingsForm();\n      await this.initializeTagManagement();\n      await this.initializeBatchAnalysis();\n      await this.initializeCacheManagement();\n\n      // Step 6: Setup runtime message listeners\n      this.setupRuntimeMessageListener();\n\n      this.isInitialized = true;\n      this.logger.info('Options page initialization completed successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      startupLogger.error('Failed to initialize options page', error);\n      throw new Error(`Options page initialization failed: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - DI Container Setup\n  // ==========================================================================\n\n  /**\n   * Sets up TSyringe DI container.\n   */\n  private setupDIContainer(): void {\n    startupLogger.info('Setting up DI container...');\n\n    // ------------------------------------------------------------------------\n    // Register Core Interfaces\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton<ILogger>('ILogger', ConsoleLogger);\n    container.registerSingleton<IConfigRepository>('IConfigRepository', IndexedDBConfigRepository);\n    container.registerSingleton<ICache>('ICache', MemoryCache);\n    container.registerSingleton<ITagManager>('ITagManager', ThunderbirdTagManager);\n\n    startupLogger.info('Core interfaces registered');\n\n    // ------------------------------------------------------------------------\n    // Register Services\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('ProviderFactory', ProviderFactory);\n    container.registerSingleton('EmailContentExtractor', EmailContentExtractor);\n    container.registerSingleton('TagService', TagService);\n    container.registerSingleton('AppConfigService', AppConfigService);\n    container.registerSingleton('RateLimiterService', RateLimiterService);\n\n    startupLogger.info('Services registered');\n\n    // ------------------------------------------------------------------------\n    // Register Use Cases\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('AnalyzeEmail', AnalyzeEmail);\n    container.registerSingleton('ApplyTagsToEmail', ApplyTagsToEmail);\n    container.registerSingleton('AnalyzeBatchEmails', AnalyzeBatchEmails);\n\n    startupLogger.info('Use cases registered');\n\n    // ------------------------------------------------------------------------\n    // Register Domain Events\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('EventBus', EventBus);\n\n    startupLogger.info('Event bus registered');\n\n    // ------------------------------------------------------------------------\n    // Register UI Components\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('SettingsForm', SettingsForm);\n    container.registerSingleton('TagManagementUI', TagManagementUI);\n    container.registerSingleton('BatchAnalysisUI', BatchAnalysisUI);\n\n    startupLogger.info('UI components registered');\n    startupLogger.info('DI container setup completed');\n  }\n\n  // ==========================================================================\n  // Private Methods - UI Initialization\n  // ==========================================================================\n\n  /**\n   * Initializes tab navigation.\n   */\n  private initializeTabs(): void {\n    this.logger?.debug('Initializing tabs');\n\n    const tabs = document.querySelectorAll<HTMLButtonElement>('.tab-button');\n    const tabContents = document.querySelectorAll<HTMLDivElement>('.tab-content');\n\n    tabs.forEach((tab) => {\n      tab.addEventListener('click', () => {\n        const targetTabId = tab.dataset.tab;\n\n        if (!targetTabId) {\n          this.logger?.warn('Tab does not have data-tab attribute', { tab: tab.textContent });\n          return;\n        }\n\n        tabs.forEach((t) => t.classList.remove('active'));\n        tab.classList.add('active');\n\n        tabContents.forEach((content) => content.classList.remove('active'));\n\n        const targetContent = document.getElementById(targetTabId);\n        if (targetContent) {\n          targetContent.classList.add('active');\n        } else {\n          this.logger?.warn('Target tab content not found', { tabId: targetTabId });\n        }\n      });\n    });\n\n    this.logger?.debug('Tabs initialized');\n  }\n\n  /**\n   * Initializes settings form.\n   */\n  private async initializeSettingsForm(): Promise<void> {\n    this.logger?.debug('Initializing settings form');\n\n    if (!this.settingsForm) {\n      throw new Error('Settings form not resolved from DI container');\n    }\n\n    this.settingsForm.render();\n    await this.settingsForm.loadSettings();\n\n    this.logger?.debug('Settings form initialized');\n  }\n\n  /**\n   * Initializes tag management UI.\n   */\n  private async initializeTagManagement(): Promise<void> {\n    this.logger?.debug('Initializing tag management UI');\n\n    if (!this.tagManagementUI) {\n      throw new Error('Tag management UI not resolved from DI container');\n    }\n\n    this.tagManagementUI.render();\n    await this.tagManagementUI.loadTags();\n\n    this.logger?.debug('Tag management UI initialized');\n  }\n\n  /**\n   * Initializes batch analysis UI.\n   */\n  private async initializeBatchAnalysis(): Promise<void> {\n    this.logger?.debug('Initializing batch analysis UI');\n\n    if (!this.batchAnalysisUI) {\n      throw new Error('Batch analysis UI not resolved from DI container');\n    }\n\n    this.batchAnalysisUI.render();\n\n    this.logger?.debug('Batch analysis UI initialized');\n  }\n\n  /**\n   * Initializes cache management.\n   */\n  private async initializeCacheManagement(): Promise<void> {\n    this.logger?.debug('Initializing cache management');\n\n    // Setup clear cache button\n    const clearCacheBtn = document.getElementById('clear-cache-btn') as HTMLButtonElement;\n    const cacheStatusMessage = document.getElementById('cache-status-message') as HTMLSpanElement;\n\n    if (clearCacheBtn && cacheStatusMessage) {\n      clearCacheBtn.addEventListener('click', async () => {\n        try {\n          clearCacheBtn.disabled = true;\n          cacheStatusMessage.textContent = 'Cache wird geleert...';\n\n          const response = await this.sendMessage<CacheClearResponse>({ action: 'clearCache' });\n\n          cacheStatusMessage.textContent = response.message;\n\n          // Refresh cache stats after clearing\n          await this.updateCacheStats();\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          this.logger?.error('Failed to clear cache', { error: errorMessage });\n          cacheStatusMessage.textContent = `Fehler beim Leeren des Cache: ${errorMessage}`;\n        } finally {\n          clearCacheBtn.disabled = false;\n        }\n      });\n    }\n\n    // Load cache stats\n    await this.updateCacheStats();\n\n    this.logger?.debug('Cache management initialized');\n  }\n\n  /**\n   * Updates cache statistics display.\n   */\n  private async updateCacheStats(): Promise<void> {\n    const cacheStats = document.getElementById('cache-stats') as HTMLSpanElement;\n\n    if (!cacheStats) {\n      return;\n    }\n\n    try {\n      const response = await this.sendMessage<CacheStatsResponse>({ action: 'getCacheStats' });\n\n      if (\n        response.success &&\n        response.totalEntries !== undefined &&\n        response.hitRate !== undefined\n      ) {\n        cacheStats.textContent = `Cache-Eintr\u00e4ge: ${response.totalEntries} | Hit-Rate: ${response.hitRate}%`;\n      } else {\n        cacheStats.textContent = response.message ?? 'Cache-Statistiken nicht verf\u00fcgbar';\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to get cache stats', { error: errorMessage });\n      cacheStats.textContent = 'Fehler beim Laden der Statistiken';\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Event Bus Integration\n  // ==========================================================================\n\n  /**\n   * Sets up runtime message listeners.\n   *\n   * Listens for messages from background script and responds accordingly.\n   */\n  private setupRuntimeMessageListener(): void {\n    this.logger?.debug('Setting up runtime message listeners');\n\n    if (typeof window !== 'undefined' && 'browser' in window) {\n      const browser = (window as any).browser;\n      if (browser?.runtime?.onMessage) {\n        browser.runtime.onMessage.addListener(\n          (message: unknown, _sender: unknown, sendResponse: (response?: unknown) => void) => {\n            // Type guard for message with action\n            if (typeof message === 'object' && message !== null && 'action' in message) {\n              const typedMessage = message as Record<string, unknown>;\n\n              // Handle different actions\n              switch (typedMessage.action) {\n                case 'showError':\n                  this.logger?.warn('Error message received', { error: typedMessage });\n                  break;\n                case 'batchProgress':\n                  // Update batch progress UI if needed\n                  if (this.batchAnalysisUI) {\n                    this.batchAnalysisUI.updateProgress().catch((error) => {\n                      this.logger?.error('Failed to update batch progress', { error });\n                    });\n                  }\n                  break;\n                default:\n                  // Log unknown actions\n                  this.logger?.debug('Unknown message action', { action: typedMessage.action });\n              }\n\n              sendResponse({ success: true });\n              return false;\n            }\n\n            return false; // Let other handlers process the message\n          }\n        );\n      }\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Utilities\n  // ==========================================================================\n\n  /**\n   * Sends a message to the background script.\n   *\n   * @param message - Message to send\n   * @returns Promise resolving to response\n   */\n  private sendMessage<T = unknown>(message: unknown): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      if (typeof window !== 'undefined' && 'browser' in window) {\n        const browser = (window as any).browser;\n        if (browser?.runtime) {\n          browser.runtime.sendMessage(message, (response: unknown) => {\n            const lastError = browser.runtime?.lastError;\n            if (lastError) {\n              reject(new Error(lastError.message));\n            } else {\n              resolve(response as T);\n            }\n          });\n        } else {\n          reject(new Error('Browser runtime not available'));\n        }\n      } else {\n        reject(new Error('Browser runtime not available'));\n      }\n    });\n  }\n}\n\n// ============================================================================\n// Extension Entry Point\n// ============================================================================\n\n/**\n * Main extension entry point.\n */\n(async function main(): Promise<void> {\n  startupLogger.info('Thunderbird Email AI Assistant - Options Script Loading');\n\n  try {\n    const optionsScript = new OptionsScript();\n    await optionsScript.initialize();\n\n    startupLogger.info('Thunderbird Email AI Assistant - Options Page Ready');\n  } catch (error) {\n    startupLogger.error('Failed to initialize options page', error);\n    document.body.innerHTML = `\n      <div style=\"color: red; padding: 20px;\">\n        <h2>Error initializing options page</h2>\n        <p>${error instanceof Error ? error.message : String(error)}</p>\n        <p>Please check the browser console for more details.</p>\n      </div>\n    `;\n  }\n})();\n\n// ============================================================================\n// Export for Testing\n// ============================================================================\n\nexport { OptionsScript };\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * Options Script - DI Container Setup for Options Page\n *\n * Main entry point for options.ts. Sets up dependency injection,\n * initializes UI components, and manages tab navigation.\n *\n * @module interfaces/options/OptionsScript\n */\n\nimport 'reflect-metadata';\nimport { container, injectable } from 'tsyringe';\n\n// ============================================================================\n// Core Interfaces\n// ============================================================================\n\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\nimport type { ITagManager } from '@/infrastructure/interfaces/ITagManager';\nimport type { ICache } from '@/infrastructure/interfaces/ICache';\nimport type { IReviewQueueRepository } from '@/infrastructure/interfaces/IReviewQueueRepository';\nimport type { IAnalysisHistoryRepository } from '@/infrastructure/interfaces/IAnalysisHistoryRepository';\n\n// ============================================================================\n// Core Implementations\n// ============================================================================\n\nimport { ConsoleLogger } from '@/infrastructure/logger/ConsoleLogger';\nimport { IndexedDBConfigRepository } from '@/infrastructure/repositories/IndexedDBConfigRepository';\nimport { MemoryCache } from '@/infrastructure/cache/MemoryCache';\nimport { ThunderbirdTagManager } from '@/interfaces/adapters/ThunderbirdTagManager';\nimport { ReviewQueueRepository } from '@/infrastructure/repositories/ReviewQueueRepository';\nimport { AnalysisHistoryRepository } from '@/infrastructure/repositories/AnalysisHistoryRepository';\n\n// ============================================================================\n// Services\n// ============================================================================\n\nimport { ProviderFactory } from '@/infrastructure/providers/ProviderFactory';\nimport { EmailContentExtractor } from '@/domain/services/EmailContentExtractor';\nimport { TagService } from '@/domain/services/TagService';\nimport { AppConfigService } from '@/infrastructure/config/AppConfig';\nimport { RateLimiterService } from '@/application/services/RateLimiterService';\n\n// ============================================================================\n// Use Cases\n// ============================================================================\n\nimport { AnalyzeEmail } from '@/application/use-cases/AnalyzeEmail';\nimport { ApplyTagsToEmail } from '@/application/use-cases/ApplyTagsToEmail';\nimport { AnalyzeBatchEmails } from '@/application/use-cases/AnalyzeBatchEmails';\n\n// ============================================================================\n// Domain Events\n// ============================================================================\n\nimport { EventBus } from '@/domain/events/EventBus';\n\n// ============================================================================\n// UI Components\n// ============================================================================\n\nimport { SettingsForm } from './SettingsForm';\nimport { TagManagementUI } from './TagManagementUI';\nimport { BatchAnalysisUI } from './BatchAnalysisUI';\nimport { ReviewQueueUI } from './ReviewQueueUI';\nimport { AnalysisHistoryUI } from './AnalysisHistoryUI';\n\n// ============================================================================\n// DOM Element Interfaces\n// ============================================================================\n\n// ============================================================================\n// Browser API Declarations\n// ============================================================================\n// Browser API Declarations\n// ============================================================================\n\ndeclare const messenger: {\n  storage: {\n    local: {\n      get(keys?: Record<string, unknown> | string[] | string): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n};\n\ninterface CacheStatsResponse {\n  success: boolean;\n  totalEntries?: number;\n  hitRate?: number;\n  message?: string;\n}\n\ninterface CacheClearResponse {\n  success: boolean;\n  message: string;\n}\n\n// ============================================================================\n// Logger Wrapper (for startup before DI container)\n// ============================================================================\n\n/**\n * Simple console logger for startup before DI container is ready.\n */\nconst startupLogger = {\n  info: (message: string, meta?: Record<string, unknown>) => {\n    console.log(`[Options Startup] ${message}`, meta ?? '');\n  },\n  warn: (message: string, meta?: Record<string, unknown>) => {\n    console.warn(`[Options Startup] ${message}`, meta ?? '');\n  },\n  error: (message: string, error?: unknown) => {\n    console.error(`[Options Startup] ${message}`, error ?? '');\n  },\n};\n\n// ============================================================================\n// Options Script Main Class\n// ============================================================================\n\n/**\n * Options Script Main Class\n *\n * Orchestrates the options page initialization by setting up DI container,\n * registering services, and initializing UI components.\n *\n * @class OptionsScript\n */\n@injectable()\nclass OptionsScript {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private settingsForm: SettingsForm | null = null;\n  private tagManagementUI: TagManagementUI | null = null;\n  private batchAnalysisUI: BatchAnalysisUI | null = null;\n  private reviewQueueUI: ReviewQueueUI | null = null;\n  private analysisHistoryUI: AnalysisHistoryUI | null = null;\n  private logger: ILogger | null = null;\n  private eventBus: EventBus | null = null;\n  private isInitialized = false;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor() {\n    startupLogger.info('OptionsScript class instantiated');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Initializes the options page.\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      startupLogger.warn('Options page already initialized');\n      return;\n    }\n\n    startupLogger.info('Initializing options page...');\n\n    try {\n      // Step 1: Setup DI container\n      this.setupDIContainer();\n\n      // Step 2: Resolve logger\n      this.logger = container.resolve<ILogger>('ILogger');\n      this.logger.info('Options page initialization started');\n\n      // Step 3: Resolve event bus\n      this.eventBus = container.resolve<EventBus>(EventBus);\n\n      // Step 4: Resolve UI components\n      this.settingsForm = container.resolve<SettingsForm>(SettingsForm);\n      this.tagManagementUI = container.resolve<TagManagementUI>(TagManagementUI);\n      this.batchAnalysisUI = container.resolve<BatchAnalysisUI>(BatchAnalysisUI);\n      this.reviewQueueUI = container.resolve<ReviewQueueUI>(ReviewQueueUI);\n      this.analysisHistoryUI = container.resolve<AnalysisHistoryUI>(AnalysisHistoryUI);\n\n      // Step 5: Initialize UI components\n      this.initializeTabs();\n      await this.initializeSettingsForm();\n      await this.initializeTagManagement();\n      await this.initializeBatchAnalysis();\n      await this.initializeReviewQueue();\n      await this.initializeAnalysisHistory();\n      await this.initializeCacheManagement();\n\n      // Step 6: Setup runtime message listeners\n      this.setupRuntimeMessageListener();\n\n      this.isInitialized = true;\n      this.logger.info('Options page initialization completed successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      startupLogger.error('Failed to initialize options page', error);\n      throw new Error(`Options page initialization failed: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - DI Container Setup\n  // ==========================================================================\n\n  /**\n   * Sets up TSyringe DI container.\n   */\n  private setupDIContainer(): void {\n    startupLogger.info('Setting up DI container...');\n\n    // ------------------------------------------------------------------------\n    // Register Core Interfaces\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton<ILogger>('ILogger', ConsoleLogger);\n    container.registerSingleton<IConfigRepository>('IConfigRepository', IndexedDBConfigRepository);\n    container.registerSingleton<ICache>('ICache', MemoryCache);\n    container.registerSingleton<ITagManager>('ITagManager', ThunderbirdTagManager);\n    container.registerSingleton<IReviewQueueRepository>('IReviewQueueRepository', ReviewQueueRepository);\n    container.registerSingleton<IAnalysisHistoryRepository>('IAnalysisHistoryRepository', AnalysisHistoryRepository);\n\n    startupLogger.info('Core interfaces registered');\n\n    // ------------------------------------------------------------------------\n    // Register Services\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('ProviderFactory', ProviderFactory);\n    container.registerSingleton('EmailContentExtractor', EmailContentExtractor);\n    container.registerSingleton('TagService', TagService);\n    container.registerSingleton('AppConfigService', AppConfigService);\n    container.registerSingleton('RateLimiterService', RateLimiterService);\n\n    startupLogger.info('Services registered');\n\n    // ------------------------------------------------------------------------\n    // Register Use Cases\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('AnalyzeEmail', AnalyzeEmail);\n    container.registerSingleton('ApplyTagsToEmail', ApplyTagsToEmail);\n    container.registerSingleton('AnalyzeBatchEmails', AnalyzeBatchEmails);\n\n    startupLogger.info('Use cases registered');\n\n    // ------------------------------------------------------------------------\n    // Register Domain Events\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('EventBus', EventBus);\n\n    startupLogger.info('Event bus registered');\n\n    // ------------------------------------------------------------------------\n    // Register UI Components\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('SettingsForm', SettingsForm);\n    container.registerSingleton('TagManagementUI', TagManagementUI);\n    container.registerSingleton('BatchAnalysisUI', BatchAnalysisUI);\n    container.registerSingleton('ReviewQueueUI', ReviewQueueUI);\n    container.registerSingleton('AnalysisHistoryUI', AnalysisHistoryUI);\n\n    startupLogger.info('UI components registered');\n    startupLogger.info('DI container setup completed');\n  }\n\n  // ==========================================================================\n  // Private Methods - UI Initialization\n  // ==========================================================================\n\n  /**\n   * Initializes tab navigation.\n   */\n  private initializeTabs(): void {\n    this.logger?.debug('Initializing tabs');\n\n    const tabs = document.querySelectorAll<HTMLButtonElement>('.tab-button');\n    const tabContents = document.querySelectorAll<HTMLDivElement>('.tab-content');\n\n    tabs.forEach((tab) => {\n      tab.addEventListener('click', () => {\n        const targetTabId = tab.dataset.tab;\n\n        if (!targetTabId) {\n          this.logger?.warn('Tab does not have data-tab attribute', { tab: tab.textContent });\n          return;\n        }\n\n        tabs.forEach((t) => t.classList.remove('active'));\n        tab.classList.add('active');\n\n        tabContents.forEach((content) => content.classList.remove('active'));\n\n        const targetContent = document.getElementById(targetTabId);\n        if (targetContent) {\n          targetContent.classList.add('active');\n        } else {\n          this.logger?.warn('Target tab content not found', { tabId: targetTabId });\n        }\n      });\n    });\n\n    this.logger?.debug('Tabs initialized');\n  }\n\n  /**\n   * Initializes settings form.\n   */\n  private async initializeSettingsForm(): Promise<void> {\n    this.logger?.debug('Initializing settings form');\n\n    if (!this.settingsForm) {\n      throw new Error('Settings form not resolved from DI container');\n    }\n\n    this.settingsForm.render();\n    await this.settingsForm.loadSettings();\n\n    this.logger?.debug('Settings form initialized');\n  }\n\n  /**\n   * Initializes tag management UI.\n   */\n  private async initializeTagManagement(): Promise<void> {\n    this.logger?.debug('Initializing tag management UI');\n\n    if (!this.tagManagementUI) {\n      throw new Error('Tag management UI not resolved from DI container');\n    }\n\n    this.tagManagementUI.render();\n    await this.tagManagementUI.loadTags();\n\n    this.logger?.debug('Tag management UI initialized');\n  }\n\n  /**\n   * Initializes batch analysis UI.\n   */\n  private async initializeBatchAnalysis(): Promise<void> {\n    this.logger?.debug('Initializing batch analysis UI');\n\n    if (!this.batchAnalysisUI) {\n      throw new Error('Batch analysis UI not resolved from DI container');\n    }\n\n    this.batchAnalysisUI.render();\n\n    this.logger?.debug('Batch analysis UI initialized');\n  }\n\n  /**\n   * Initializes review queue UI.\n   */\n  private async initializeReviewQueue(): Promise<void> {\n    this.logger?.debug('Initializing review queue UI');\n\n    if (!this.reviewQueueUI) {\n      throw new Error('Review queue UI not resolved from DI container');\n    }\n\n    this.reviewQueueUI.render();\n    await this.reviewQueueUI.loadReviewQueue();\n\n    this.logger?.debug('Review queue UI initialized');\n  }\n\n  /**\n   * Initializes analysis history UI.\n   */\n  private async initializeAnalysisHistory(): Promise<void> {\n    this.logger?.debug('Initializing analysis history UI');\n\n    if (!this.analysisHistoryUI) {\n      throw new Error('Analysis history UI not resolved from DI container');\n    }\n\n    this.analysisHistoryUI.render();\n    await this.analysisHistoryUI.loadAnalysisHistory();\n\n    this.logger?.debug('Analysis history UI initialized');\n  }\n\n  /**\n   * Initializes cache management.\n   */\n  private async initializeCacheManagement(): Promise<void> {\n    this.logger?.debug('Initializing cache management');\n\n    // Setup clear cache button\n    const clearCacheBtn = document.getElementById('clear-cache-btn') as HTMLButtonElement;\n    const cacheStatusMessage = document.getElementById('cache-status-message') as HTMLSpanElement;\n\n    if (clearCacheBtn && cacheStatusMessage) {\n      clearCacheBtn.addEventListener('click', async () => {\n        try {\n          clearCacheBtn.disabled = true;\n          cacheStatusMessage.textContent = 'Cache wird geleert...';\n\n          const response = await this.sendMessage<CacheClearResponse>({ action: 'clearCache' });\n\n          cacheStatusMessage.textContent = response.message;\n\n          // Refresh cache stats after clearing\n          await this.updateCacheStats();\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          this.logger?.error('Failed to clear cache', { error: errorMessage });\n          cacheStatusMessage.textContent = `Fehler beim Leeren des Cache: ${errorMessage}`;\n        } finally {\n          clearCacheBtn.disabled = false;\n        }\n      });\n    }\n\n    // Load cache stats\n    await this.updateCacheStats();\n\n    this.logger?.debug('Cache management initialized');\n  }\n\n  /**\n   * Updates cache statistics display.\n   */\n  private async updateCacheStats(): Promise<void> {\n    const cacheStats = document.getElementById('cache-stats') as HTMLSpanElement;\n\n    if (!cacheStats) {\n      return;\n    }\n\n    try {\n      const response = await this.sendMessage<CacheStatsResponse>({ action: 'getCacheStats' });\n\n      if (\n        response.success &&\n        response.totalEntries !== undefined &&\n        response.hitRate !== undefined\n      ) {\n        cacheStats.textContent = `Cache-Eintr\u00e4ge: ${response.totalEntries} | Hit-Rate: ${response.hitRate}%`;\n      } else {\n        cacheStats.textContent = response.message ?? 'Cache-Statistiken nicht verf\u00fcgbar';\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to get cache stats', { error: errorMessage });\n      cacheStats.textContent = 'Fehler beim Laden der Statistiken';\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Event Bus Integration\n  // ==========================================================================\n\n  /**\n   * Sets up runtime message listeners.\n   *\n   * Listens for messages from background script and responds accordingly.\n   */\n  private setupRuntimeMessageListener(): void {\n    this.logger?.debug('Setting up runtime message listeners');\n\n    if (typeof window !== 'undefined' && 'browser' in window) {\n      const browser = (window as any).browser;\n      if (browser?.runtime?.onMessage) {\n        browser.runtime.onMessage.addListener(\n          (message: unknown, _sender: unknown, sendResponse: (response?: unknown) => void) => {\n            // Type guard for message with action\n            if (typeof message === 'object' && message !== null && 'action' in message) {\n              const typedMessage = message as Record<string, unknown>;\n\n              // Handle different actions\n              switch (typedMessage.action) {\n                case 'showError':\n                  this.logger?.warn('Error message received', { error: typedMessage });\n                  break;\n                case 'batchProgress':\n                  // Update batch progress UI if needed\n                  if (this.batchAnalysisUI) {\n                    this.batchAnalysisUI.updateProgress().catch((error) => {\n                      this.logger?.error('Failed to update batch progress', { error });\n                    });\n                  }\n                  break;\n                default:\n                  // Log unknown actions\n                  this.logger?.debug('Unknown message action', { action: typedMessage.action });\n              }\n\n              sendResponse({ success: true });\n              return false;\n            }\n\n            return false; // Let other handlers process the message\n          }\n        );\n      }\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Utilities\n  // ==========================================================================\n\n  /**\n   * Sends a message to the background script.\n   *\n   * @param message - Message to send\n   * @returns Promise resolving to response\n   */\n  private sendMessage<T = unknown>(message: unknown): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      if (typeof window !== 'undefined' && 'browser' in window) {\n        const browser = (window as any).browser;\n        if (browser?.runtime) {\n          browser.runtime.sendMessage(message, (response: unknown) => {\n            const lastError = browser.runtime?.lastError;\n            if (lastError) {\n              reject(new Error(lastError.message));\n            } else {\n              resolve(response as T);\n            }\n          });\n        } else {\n          reject(new Error('Browser runtime not available'));\n        }\n      } else {\n        reject(new Error('Browser runtime not available'));\n      }\n    });\n  }\n}\n\n// ============================================================================\n// Extension Entry Point\n// ============================================================================\n\n/**\n * Main extension entry point.\n */\n(async function main(): Promise<void> {\n  startupLogger.info('Thunderbird Email AI Assistant - Options Script Loading');\n\n  try {\n    const optionsScript = new OptionsScript();\n    await optionsScript.initialize();\n\n    startupLogger.info('Thunderbird Email AI Assistant - Options Page Ready');\n  } catch (error) {\n    startupLogger.error('Failed to initialize options page', error);\n    document.body.innerHTML = `\n      <div style=\"color: red; padding: 20px;\">\n        <h2>Error initializing options page</h2>\n        <p>${error instanceof Error ? error.message : String(error)}</p>\n        <p>Please check the browser console for more details.</p>\n      </div>\n    `;\n  }\n})();\n\n// ============================================================================\n// Export for Testing\n// ============================================================================\n\nexport { OptionsScript };\n",
        "last_modified": "2026-01-05T19:59:00.212459"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "010-confidence-score-display-and-threshold-configurati": {
      "task_id": "010-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "bdfad3eb512d2cde785819b3e597f39d954633f3",
        "content": "/**\n * Options Script - DI Container Setup for Options Page\n *\n * Main entry point for options.ts. Sets up dependency injection,\n * initializes UI components, and manages tab navigation.\n *\n * @module interfaces/options/OptionsScript\n */\n\nimport 'reflect-metadata';\nimport { container, injectable } from 'tsyringe';\n\n// ============================================================================\n// Core Interfaces\n// ============================================================================\n\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\nimport type { ITagManager } from '@/infrastructure/interfaces/ITagManager';\nimport type { ICache } from '@/infrastructure/interfaces/ICache';\n\n// ============================================================================\n// Core Implementations\n// ============================================================================\n\nimport { ConsoleLogger } from '@/infrastructure/logger/ConsoleLogger';\nimport { IndexedDBConfigRepository } from '@/infrastructure/repositories/IndexedDBConfigRepository';\nimport { MemoryCache } from '@/infrastructure/cache/MemoryCache';\nimport { ThunderbirdTagManager } from '@/interfaces/adapters/ThunderbirdTagManager';\n\n// ============================================================================\n// Services\n// ============================================================================\n\nimport { ProviderFactory } from '@/infrastructure/providers/ProviderFactory';\nimport { EmailContentExtractor } from '@/domain/services/EmailContentExtractor';\nimport { TagService } from '@/domain/services/TagService';\nimport { AppConfigService } from '@/infrastructure/config/AppConfig';\nimport { RateLimiterService } from '@/application/services/RateLimiterService';\n\n// ============================================================================\n// Use Cases\n// ============================================================================\n\nimport { AnalyzeEmail } from '@/application/use-cases/AnalyzeEmail';\nimport { ApplyTagsToEmail } from '@/application/use-cases/ApplyTagsToEmail';\nimport { AnalyzeBatchEmails } from '@/application/use-cases/AnalyzeBatchEmails';\n\n// ============================================================================\n// Domain Events\n// ============================================================================\n\nimport { EventBus } from '@/domain/events/EventBus';\n\n// ============================================================================\n// UI Components\n// ============================================================================\n\nimport { SettingsForm } from './SettingsForm';\nimport { TagManagementUI } from './TagManagementUI';\nimport { BatchAnalysisUI } from './BatchAnalysisUI';\n\n// ============================================================================\n// DOM Element Interfaces\n// ============================================================================\n\n// ============================================================================\n// Browser API Declarations\n// ============================================================================\n// Browser API Declarations\n// ============================================================================\n\ndeclare const messenger: {\n  storage: {\n    local: {\n      get(keys?: Record<string, unknown> | string[] | string): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n};\n\ninterface CacheStatsResponse {\n  success: boolean;\n  totalEntries?: number;\n  hitRate?: number;\n  message?: string;\n}\n\ninterface CacheClearResponse {\n  success: boolean;\n  message: string;\n}\n\n// ============================================================================\n// Logger Wrapper (for startup before DI container)\n// ============================================================================\n\n/**\n * Simple console logger for startup before DI container is ready.\n */\nconst startupLogger = {\n  info: (message: string, meta?: Record<string, unknown>) => {\n    console.log(`[Options Startup] ${message}`, meta ?? '');\n  },\n  warn: (message: string, meta?: Record<string, unknown>) => {\n    console.warn(`[Options Startup] ${message}`, meta ?? '');\n  },\n  error: (message: string, error?: unknown) => {\n    console.error(`[Options Startup] ${message}`, error ?? '');\n  },\n};\n\n// ============================================================================\n// Options Script Main Class\n// ============================================================================\n\n/**\n * Options Script Main Class\n *\n * Orchestrates the options page initialization by setting up DI container,\n * registering services, and initializing UI components.\n *\n * @class OptionsScript\n */\n@injectable()\nclass OptionsScript {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private settingsForm: SettingsForm | null = null;\n  private tagManagementUI: TagManagementUI | null = null;\n  private batchAnalysisUI: BatchAnalysisUI | null = null;\n  private logger: ILogger | null = null;\n  private eventBus: EventBus | null = null;\n  private isInitialized = false;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor() {\n    startupLogger.info('OptionsScript class instantiated');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Initializes the options page.\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      startupLogger.warn('Options page already initialized');\n      return;\n    }\n\n    startupLogger.info('Initializing options page...');\n\n    try {\n      // Step 1: Setup DI container\n      this.setupDIContainer();\n\n      // Step 2: Resolve logger\n      this.logger = container.resolve<ILogger>('ILogger');\n      this.logger.info('Options page initialization started');\n\n      // Step 3: Resolve event bus\n      this.eventBus = container.resolve<EventBus>(EventBus);\n\n      // Step 4: Resolve UI components\n      this.settingsForm = container.resolve<SettingsForm>(SettingsForm);\n      this.tagManagementUI = container.resolve<TagManagementUI>(TagManagementUI);\n      this.batchAnalysisUI = container.resolve<BatchAnalysisUI>(BatchAnalysisUI);\n\n      // Step 5: Initialize UI components\n      this.initializeTabs();\n      await this.initializeSettingsForm();\n      await this.initializeTagManagement();\n      await this.initializeBatchAnalysis();\n      await this.initializeCacheManagement();\n\n      // Step 6: Setup runtime message listeners\n      this.setupRuntimeMessageListener();\n\n      this.isInitialized = true;\n      this.logger.info('Options page initialization completed successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      startupLogger.error('Failed to initialize options page', error);\n      throw new Error(`Options page initialization failed: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - DI Container Setup\n  // ==========================================================================\n\n  /**\n   * Sets up TSyringe DI container.\n   */\n  private setupDIContainer(): void {\n    startupLogger.info('Setting up DI container...');\n\n    // ------------------------------------------------------------------------\n    // Register Core Interfaces\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton<ILogger>('ILogger', ConsoleLogger);\n    container.registerSingleton<IConfigRepository>('IConfigRepository', IndexedDBConfigRepository);\n    container.registerSingleton<ICache>('ICache', MemoryCache);\n    container.registerSingleton<ITagManager>('ITagManager', ThunderbirdTagManager);\n\n    startupLogger.info('Core interfaces registered');\n\n    // ------------------------------------------------------------------------\n    // Register Services\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('ProviderFactory', ProviderFactory);\n    container.registerSingleton('EmailContentExtractor', EmailContentExtractor);\n    container.registerSingleton('TagService', TagService);\n    container.registerSingleton('AppConfigService', AppConfigService);\n    container.registerSingleton('RateLimiterService', RateLimiterService);\n\n    startupLogger.info('Services registered');\n\n    // ------------------------------------------------------------------------\n    // Register Use Cases\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('AnalyzeEmail', AnalyzeEmail);\n    container.registerSingleton('ApplyTagsToEmail', ApplyTagsToEmail);\n    container.registerSingleton('AnalyzeBatchEmails', AnalyzeBatchEmails);\n\n    startupLogger.info('Use cases registered');\n\n    // ------------------------------------------------------------------------\n    // Register Domain Events\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('EventBus', EventBus);\n\n    startupLogger.info('Event bus registered');\n\n    // ------------------------------------------------------------------------\n    // Register UI Components\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('SettingsForm', SettingsForm);\n    container.registerSingleton('TagManagementUI', TagManagementUI);\n    container.registerSingleton('BatchAnalysisUI', BatchAnalysisUI);\n\n    startupLogger.info('UI components registered');\n    startupLogger.info('DI container setup completed');\n  }\n\n  // ==========================================================================\n  // Private Methods - UI Initialization\n  // ==========================================================================\n\n  /**\n   * Initializes tab navigation.\n   */\n  private initializeTabs(): void {\n    this.logger?.debug('Initializing tabs');\n\n    const tabs = document.querySelectorAll<HTMLButtonElement>('.tab-button');\n    const tabContents = document.querySelectorAll<HTMLDivElement>('.tab-content');\n\n    tabs.forEach((tab) => {\n      tab.addEventListener('click', () => {\n        const targetTabId = tab.dataset.tab;\n\n        if (!targetTabId) {\n          this.logger?.warn('Tab does not have data-tab attribute', { tab: tab.textContent });\n          return;\n        }\n\n        tabs.forEach((t) => t.classList.remove('active'));\n        tab.classList.add('active');\n\n        tabContents.forEach((content) => content.classList.remove('active'));\n\n        const targetContent = document.getElementById(targetTabId);\n        if (targetContent) {\n          targetContent.classList.add('active');\n        } else {\n          this.logger?.warn('Target tab content not found', { tabId: targetTabId });\n        }\n      });\n    });\n\n    this.logger?.debug('Tabs initialized');\n  }\n\n  /**\n   * Initializes settings form.\n   */\n  private async initializeSettingsForm(): Promise<void> {\n    this.logger?.debug('Initializing settings form');\n\n    if (!this.settingsForm) {\n      throw new Error('Settings form not resolved from DI container');\n    }\n\n    this.settingsForm.render();\n    await this.settingsForm.loadSettings();\n\n    this.logger?.debug('Settings form initialized');\n  }\n\n  /**\n   * Initializes tag management UI.\n   */\n  private async initializeTagManagement(): Promise<void> {\n    this.logger?.debug('Initializing tag management UI');\n\n    if (!this.tagManagementUI) {\n      throw new Error('Tag management UI not resolved from DI container');\n    }\n\n    this.tagManagementUI.render();\n    await this.tagManagementUI.loadTags();\n\n    this.logger?.debug('Tag management UI initialized');\n  }\n\n  /**\n   * Initializes batch analysis UI.\n   */\n  private async initializeBatchAnalysis(): Promise<void> {\n    this.logger?.debug('Initializing batch analysis UI');\n\n    if (!this.batchAnalysisUI) {\n      throw new Error('Batch analysis UI not resolved from DI container');\n    }\n\n    this.batchAnalysisUI.render();\n\n    this.logger?.debug('Batch analysis UI initialized');\n  }\n\n  /**\n   * Initializes cache management.\n   */\n  private async initializeCacheManagement(): Promise<void> {\n    this.logger?.debug('Initializing cache management');\n\n    // Setup clear cache button\n    const clearCacheBtn = document.getElementById('clear-cache-btn') as HTMLButtonElement;\n    const cacheStatusMessage = document.getElementById('cache-status-message') as HTMLSpanElement;\n\n    if (clearCacheBtn && cacheStatusMessage) {\n      clearCacheBtn.addEventListener('click', async () => {\n        try {\n          clearCacheBtn.disabled = true;\n          cacheStatusMessage.textContent = 'Cache wird geleert...';\n\n          const response = await this.sendMessage<CacheClearResponse>({ action: 'clearCache' });\n\n          cacheStatusMessage.textContent = response.message;\n\n          // Refresh cache stats after clearing\n          await this.updateCacheStats();\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          this.logger?.error('Failed to clear cache', { error: errorMessage });\n          cacheStatusMessage.textContent = `Fehler beim Leeren des Cache: ${errorMessage}`;\n        } finally {\n          clearCacheBtn.disabled = false;\n        }\n      });\n    }\n\n    // Load cache stats\n    await this.updateCacheStats();\n\n    this.logger?.debug('Cache management initialized');\n  }\n\n  /**\n   * Updates cache statistics display.\n   */\n  private async updateCacheStats(): Promise<void> {\n    const cacheStats = document.getElementById('cache-stats') as HTMLSpanElement;\n\n    if (!cacheStats) {\n      return;\n    }\n\n    try {\n      const response = await this.sendMessage<CacheStatsResponse>({ action: 'getCacheStats' });\n\n      if (\n        response.success &&\n        response.totalEntries !== undefined &&\n        response.hitRate !== undefined\n      ) {\n        cacheStats.textContent = `Cache-Eintr\u00e4ge: ${response.totalEntries} | Hit-Rate: ${response.hitRate}%`;\n      } else {\n        cacheStats.textContent = response.message ?? 'Cache-Statistiken nicht verf\u00fcgbar';\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to get cache stats', { error: errorMessage });\n      cacheStats.textContent = 'Fehler beim Laden der Statistiken';\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Event Bus Integration\n  // ==========================================================================\n\n  /**\n   * Sets up runtime message listeners.\n   *\n   * Listens for messages from background script and responds accordingly.\n   */\n  private setupRuntimeMessageListener(): void {\n    this.logger?.debug('Setting up runtime message listeners');\n\n    if (typeof window !== 'undefined' && 'browser' in window) {\n      const browser = (window as any).browser;\n      if (browser?.runtime?.onMessage) {\n        browser.runtime.onMessage.addListener(\n          (message: unknown, _sender: unknown, sendResponse: (response?: unknown) => void) => {\n            // Type guard for message with action\n            if (typeof message === 'object' && message !== null && 'action' in message) {\n              const typedMessage = message as Record<string, unknown>;\n\n              // Handle different actions\n              switch (typedMessage.action) {\n                case 'showError':\n                  this.logger?.warn('Error message received', { error: typedMessage });\n                  break;\n                case 'batchProgress':\n                  // Update batch progress UI if needed\n                  if (this.batchAnalysisUI) {\n                    this.batchAnalysisUI.updateProgress().catch((error) => {\n                      this.logger?.error('Failed to update batch progress', { error });\n                    });\n                  }\n                  break;\n                default:\n                  // Log unknown actions\n                  this.logger?.debug('Unknown message action', { action: typedMessage.action });\n              }\n\n              sendResponse({ success: true });\n              return false;\n            }\n\n            return false; // Let other handlers process the message\n          }\n        );\n      }\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Utilities\n  // ==========================================================================\n\n  /**\n   * Sends a message to the background script.\n   *\n   * @param message - Message to send\n   * @returns Promise resolving to response\n   */\n  private sendMessage<T = unknown>(message: unknown): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      if (typeof window !== 'undefined' && 'browser' in window) {\n        const browser = (window as any).browser;\n        if (browser?.runtime) {\n          browser.runtime.sendMessage(message, (response: unknown) => {\n            const lastError = browser.runtime?.lastError;\n            if (lastError) {\n              reject(new Error(lastError.message));\n            } else {\n              resolve(response as T);\n            }\n          });\n        } else {\n          reject(new Error('Browser runtime not available'));\n        }\n      } else {\n        reject(new Error('Browser runtime not available'));\n      }\n    });\n  }\n}\n\n// ============================================================================\n// Extension Entry Point\n// ============================================================================\n\n/**\n * Main extension entry point.\n */\n(async function main(): Promise<void> {\n  startupLogger.info('Thunderbird Email AI Assistant - Options Script Loading');\n\n  try {\n    const optionsScript = new OptionsScript();\n    await optionsScript.initialize();\n\n    startupLogger.info('Thunderbird Email AI Assistant - Options Page Ready');\n  } catch (error) {\n    startupLogger.error('Failed to initialize options page', error);\n    document.body.innerHTML = `\n      <div style=\"color: red; padding: 20px;\">\n        <h2>Error initializing options page</h2>\n        <p>${error instanceof Error ? error.message : String(error)}</p>\n        <p>Please check the browser console for more details.</p>\n      </div>\n    `;\n  }\n})();\n\n// ============================================================================\n// Export for Testing\n// ============================================================================\n\nexport { OptionsScript };\n",
        "timestamp": "2026-01-06T07:24:51.082736"
      },
      "worktree_state": {
        "content": "/**\n * Options Script - DI Container Setup for Options Page\n *\n * Main entry point for options.ts. Sets up dependency injection,\n * initializes UI components, and manages tab navigation.\n *\n * @module interfaces/options/OptionsScript\n */\n\nimport 'reflect-metadata';\nimport { container, injectable } from 'tsyringe';\n\n// ============================================================================\n// Core Interfaces\n// ============================================================================\n\nimport type { ILogger } from '@/infrastructure/interfaces/ILogger';\nimport type { IConfigRepository } from '@/infrastructure/interfaces/IConfigRepository';\nimport type { ITagManager } from '@/infrastructure/interfaces/ITagManager';\nimport type { ICache } from '@/infrastructure/interfaces/ICache';\n\n// ============================================================================\n// Core Implementations\n// ============================================================================\n\nimport { ConsoleLogger } from '@/infrastructure/logger/ConsoleLogger';\nimport { IndexedDBConfigRepository } from '@/infrastructure/repositories/IndexedDBConfigRepository';\nimport { MemoryCache } from '@/infrastructure/cache/MemoryCache';\nimport { ThunderbirdTagManager } from '@/interfaces/adapters/ThunderbirdTagManager';\n\n// ============================================================================\n// Services\n// ============================================================================\n\nimport { ProviderFactory } from '@/infrastructure/providers/ProviderFactory';\nimport { EmailContentExtractor } from '@/domain/services/EmailContentExtractor';\nimport { TagService } from '@/domain/services/TagService';\nimport { AppConfigService } from '@/infrastructure/config/AppConfig';\nimport { RateLimiterService } from '@/application/services/RateLimiterService';\n\n// ============================================================================\n// Use Cases\n// ============================================================================\n\nimport { AnalyzeEmail } from '@/application/use-cases/AnalyzeEmail';\nimport { ApplyTagsToEmail } from '@/application/use-cases/ApplyTagsToEmail';\nimport { AnalyzeBatchEmails } from '@/application/use-cases/AnalyzeBatchEmails';\n\n// ============================================================================\n// Domain Events\n// ============================================================================\n\nimport { EventBus } from '@/domain/events/EventBus';\n\n// ============================================================================\n// UI Components\n// ============================================================================\n\nimport { SettingsForm } from './SettingsForm';\nimport { TagManagementUI } from './TagManagementUI';\nimport { BatchAnalysisUI } from './BatchAnalysisUI';\nimport { AnalysisResultsUI } from './AnalysisResultsUI';\nimport { ManualReviewPanel } from './ManualReviewPanel';\n\n// ============================================================================\n// DOM Element Interfaces\n// ============================================================================\n\n// ============================================================================\n// Browser API Declarations\n// ============================================================================\n// Browser API Declarations\n// ============================================================================\n\ndeclare const messenger: {\n  storage: {\n    local: {\n      get(keys?: Record<string, unknown> | string[] | string): Promise<Record<string, unknown>>;\n      set(items: Record<string, unknown>): Promise<void>;\n    };\n  };\n};\n\ninterface CacheStatsResponse {\n  success: boolean;\n  totalEntries?: number;\n  hitRate?: number;\n  message?: string;\n}\n\ninterface CacheClearResponse {\n  success: boolean;\n  message: string;\n}\n\n// ============================================================================\n// Logger Wrapper (for startup before DI container)\n// ============================================================================\n\n/**\n * Simple console logger for startup before DI container is ready.\n */\nconst startupLogger = {\n  info: (message: string, meta?: Record<string, unknown>) => {\n    console.log(`[Options Startup] ${message}`, meta ?? '');\n  },\n  warn: (message: string, meta?: Record<string, unknown>) => {\n    console.warn(`[Options Startup] ${message}`, meta ?? '');\n  },\n  error: (message: string, error?: unknown) => {\n    console.error(`[Options Startup] ${message}`, error ?? '');\n  },\n};\n\n// ============================================================================\n// Options Script Main Class\n// ============================================================================\n\n/**\n * Options Script Main Class\n *\n * Orchestrates the options page initialization by setting up DI container,\n * registering services, and initializing UI components.\n *\n * @class OptionsScript\n */\n@injectable()\nclass OptionsScript {\n  // ==========================================================================\n  // Private Fields\n  // ==========================================================================\n\n  private settingsForm: SettingsForm | null = null;\n  private tagManagementUI: TagManagementUI | null = null;\n  private batchAnalysisUI: BatchAnalysisUI | null = null;\n  private analysisResultsUI: AnalysisResultsUI | null = null;\n  private manualReviewPanel: ManualReviewPanel | null = null;\n  private logger: ILogger | null = null;\n  private eventBus: EventBus | null = null;\n  private isInitialized = false;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n\n  constructor() {\n    startupLogger.info('OptionsScript class instantiated');\n  }\n\n  // ==========================================================================\n  // Public Methods\n  // ==========================================================================\n\n  /**\n   * Initializes the options page.\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      startupLogger.warn('Options page already initialized');\n      return;\n    }\n\n    startupLogger.info('Initializing options page...');\n\n    try {\n      // Step 1: Setup DI container\n      this.setupDIContainer();\n\n      // Step 2: Resolve logger\n      this.logger = container.resolve<ILogger>('ILogger');\n      this.logger.info('Options page initialization started');\n\n      // Step 3: Resolve event bus\n      this.eventBus = container.resolve<EventBus>(EventBus);\n\n      // Step 4: Resolve UI components\n      this.settingsForm = container.resolve<SettingsForm>(SettingsForm);\n      this.tagManagementUI = container.resolve<TagManagementUI>(TagManagementUI);\n      this.batchAnalysisUI = container.resolve<BatchAnalysisUI>(BatchAnalysisUI);\n      this.analysisResultsUI = container.resolve<AnalysisResultsUI>(AnalysisResultsUI);\n      this.manualReviewPanel = container.resolve<ManualReviewPanel>(ManualReviewPanel);\n\n      // Step 5: Initialize UI components\n      this.initializeTabs();\n      await this.initializeSettingsForm();\n      await this.initializeTagManagement();\n      await this.initializeBatchAnalysis();\n      await this.initializeAnalysisResults();\n      await this.initializeManualReview();\n      await this.initializeCacheManagement();\n\n      // Step 6: Setup runtime message listeners\n      this.setupRuntimeMessageListener();\n\n      this.isInitialized = true;\n      this.logger.info('Options page initialization completed successfully');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      startupLogger.error('Failed to initialize options page', error);\n      throw new Error(`Options page initialization failed: ${errorMessage}`);\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - DI Container Setup\n  // ==========================================================================\n\n  /**\n   * Sets up TSyringe DI container.\n   */\n  private setupDIContainer(): void {\n    startupLogger.info('Setting up DI container...');\n\n    // ------------------------------------------------------------------------\n    // Register Core Interfaces\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton<ILogger>('ILogger', ConsoleLogger);\n    container.registerSingleton<IConfigRepository>('IConfigRepository', IndexedDBConfigRepository);\n    container.registerSingleton<ICache>('ICache', MemoryCache);\n    container.registerSingleton<ITagManager>('ITagManager', ThunderbirdTagManager);\n\n    startupLogger.info('Core interfaces registered');\n\n    // ------------------------------------------------------------------------\n    // Register Services\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('ProviderFactory', ProviderFactory);\n    container.registerSingleton('EmailContentExtractor', EmailContentExtractor);\n    container.registerSingleton('TagService', TagService);\n    container.registerSingleton('AppConfigService', AppConfigService);\n    container.registerSingleton('RateLimiterService', RateLimiterService);\n\n    startupLogger.info('Services registered');\n\n    // ------------------------------------------------------------------------\n    // Register Use Cases\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('AnalyzeEmail', AnalyzeEmail);\n    container.registerSingleton('ApplyTagsToEmail', ApplyTagsToEmail);\n    container.registerSingleton('AnalyzeBatchEmails', AnalyzeBatchEmails);\n\n    startupLogger.info('Use cases registered');\n\n    // ------------------------------------------------------------------------\n    // Register Domain Events\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('EventBus', EventBus);\n\n    startupLogger.info('Event bus registered');\n\n    // ------------------------------------------------------------------------\n    // Register UI Components\n    // ------------------------------------------------------------------------\n\n    container.registerSingleton('SettingsForm', SettingsForm);\n    container.registerSingleton('TagManagementUI', TagManagementUI);\n    container.registerSingleton('BatchAnalysisUI', BatchAnalysisUI);\n    container.registerSingleton('AnalysisResultsUI', AnalysisResultsUI);\n    container.registerSingleton('ManualReviewPanel', ManualReviewPanel);\n\n    startupLogger.info('UI components registered');\n    startupLogger.info('DI container setup completed');\n  }\n\n  // ==========================================================================\n  // Private Methods - UI Initialization\n  // ==========================================================================\n\n  /**\n   * Initializes tab navigation.\n   */\n  private initializeTabs(): void {\n    this.logger?.debug('Initializing tabs');\n\n    const tabs = document.querySelectorAll<HTMLButtonElement>('.tab-button');\n    const tabContents = document.querySelectorAll<HTMLDivElement>('.tab-content');\n\n    tabs.forEach((tab) => {\n      tab.addEventListener('click', () => {\n        const targetTabId = tab.dataset.tab;\n\n        if (!targetTabId) {\n          this.logger?.warn('Tab does not have data-tab attribute', { tab: tab.textContent });\n          return;\n        }\n\n        tabs.forEach((t) => t.classList.remove('active'));\n        tab.classList.add('active');\n\n        tabContents.forEach((content) => content.classList.remove('active'));\n\n        const targetContent = document.getElementById(targetTabId);\n        if (targetContent) {\n          targetContent.classList.add('active');\n        } else {\n          this.logger?.warn('Target tab content not found', { tabId: targetTabId });\n        }\n      });\n    });\n\n    this.logger?.debug('Tabs initialized');\n  }\n\n  /**\n   * Initializes settings form.\n   */\n  private async initializeSettingsForm(): Promise<void> {\n    this.logger?.debug('Initializing settings form');\n\n    if (!this.settingsForm) {\n      throw new Error('Settings form not resolved from DI container');\n    }\n\n    this.settingsForm.render();\n    await this.settingsForm.loadSettings();\n\n    this.logger?.debug('Settings form initialized');\n  }\n\n  /**\n   * Initializes tag management UI.\n   */\n  private async initializeTagManagement(): Promise<void> {\n    this.logger?.debug('Initializing tag management UI');\n\n    if (!this.tagManagementUI) {\n      throw new Error('Tag management UI not resolved from DI container');\n    }\n\n    this.tagManagementUI.render();\n    await this.tagManagementUI.loadTags();\n\n    this.logger?.debug('Tag management UI initialized');\n  }\n\n  /**\n   * Initializes batch analysis UI.\n   */\n  private async initializeBatchAnalysis(): Promise<void> {\n    this.logger?.debug('Initializing batch analysis UI');\n\n    if (!this.batchAnalysisUI) {\n      throw new Error('Batch analysis UI not resolved from DI container');\n    }\n\n    this.batchAnalysisUI.render();\n\n    this.logger?.debug('Batch analysis UI initialized');\n  }\n\n  /**\n   * Initializes analysis results UI.\n   */\n  private async initializeAnalysisResults(): Promise<void> {\n    this.logger?.debug('Initializing analysis results UI');\n\n    if (!this.analysisResultsUI) {\n      throw new Error('Analysis results UI not resolved from DI container');\n    }\n\n    this.analysisResultsUI.render();\n\n    // Setup refresh button\n    const refreshBtn = document.getElementById('refresh-results-btn') as HTMLButtonElement;\n    if (refreshBtn) {\n      refreshBtn.addEventListener('click', async () => {\n        try {\n          refreshBtn.disabled = true;\n          refreshBtn.textContent = 'Wird geladen...';\n          await this.analysisResultsUI!.refresh();\n        } catch (error) {\n          this.logger?.error('Failed to refresh analysis results', { error });\n        } finally {\n          refreshBtn.disabled = false;\n          refreshBtn.textContent = 'Aktualisieren';\n        }\n      });\n    }\n\n    this.logger?.debug('Analysis results UI initialized');\n  }\n\n  /**\n   * Initializes manual review panel UI.\n   */\n  private async initializeManualReview(): Promise<void> {\n    this.logger?.debug('Initializing manual review panel UI');\n\n    if (!this.manualReviewPanel) {\n      throw new Error('Manual review panel not resolved from DI container');\n    }\n\n    this.manualReviewPanel.render();\n\n    // Setup refresh button\n    const refreshBtn = document.getElementById('refresh-review-btn') as HTMLButtonElement;\n    if (refreshBtn) {\n      refreshBtn.addEventListener('click', async () => {\n        try {\n          refreshBtn.disabled = true;\n          refreshBtn.textContent = 'Wird geladen...';\n          await this.manualReviewPanel!.refresh();\n        } catch (error) {\n          this.logger?.error('Failed to refresh manual review panel', { error });\n        } finally {\n          refreshBtn.disabled = false;\n          refreshBtn.textContent = 'Aktualisieren';\n        }\n      });\n    }\n\n    this.logger?.debug('Manual review panel UI initialized');\n  }\n\n  /**\n   * Initializes cache management.\n   */\n  private async initializeCacheManagement(): Promise<void> {\n    this.logger?.debug('Initializing cache management');\n\n    // Setup clear cache button\n    const clearCacheBtn = document.getElementById('clear-cache-btn') as HTMLButtonElement;\n    const cacheStatusMessage = document.getElementById('cache-status-message') as HTMLSpanElement;\n\n    if (clearCacheBtn && cacheStatusMessage) {\n      clearCacheBtn.addEventListener('click', async () => {\n        try {\n          clearCacheBtn.disabled = true;\n          cacheStatusMessage.textContent = 'Cache wird geleert...';\n\n          const response = await this.sendMessage<CacheClearResponse>({ action: 'clearCache' });\n\n          cacheStatusMessage.textContent = response.message;\n\n          // Refresh cache stats after clearing\n          await this.updateCacheStats();\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          this.logger?.error('Failed to clear cache', { error: errorMessage });\n          cacheStatusMessage.textContent = `Fehler beim Leeren des Cache: ${errorMessage}`;\n        } finally {\n          clearCacheBtn.disabled = false;\n        }\n      });\n    }\n\n    // Load cache stats\n    await this.updateCacheStats();\n\n    this.logger?.debug('Cache management initialized');\n  }\n\n  /**\n   * Updates cache statistics display.\n   */\n  private async updateCacheStats(): Promise<void> {\n    const cacheStats = document.getElementById('cache-stats') as HTMLSpanElement;\n\n    if (!cacheStats) {\n      return;\n    }\n\n    try {\n      const response = await this.sendMessage<CacheStatsResponse>({ action: 'getCacheStats' });\n\n      if (\n        response.success &&\n        response.totalEntries !== undefined &&\n        response.hitRate !== undefined\n      ) {\n        cacheStats.textContent = `Cache-Eintr\u00e4ge: ${response.totalEntries} | Hit-Rate: ${response.hitRate}%`;\n      } else {\n        cacheStats.textContent = response.message ?? 'Cache-Statistiken nicht verf\u00fcgbar';\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this.logger?.error('Failed to get cache stats', { error: errorMessage });\n      cacheStats.textContent = 'Fehler beim Laden der Statistiken';\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Event Bus Integration\n  // ==========================================================================\n\n  /**\n   * Sets up runtime message listeners.\n   *\n   * Listens for messages from background script and responds accordingly.\n   */\n  private setupRuntimeMessageListener(): void {\n    this.logger?.debug('Setting up runtime message listeners');\n\n    if (typeof window !== 'undefined' && 'browser' in window) {\n      const browser = (window as any).browser;\n      if (browser?.runtime?.onMessage) {\n        browser.runtime.onMessage.addListener(\n          (message: unknown, _sender: unknown, sendResponse: (response?: unknown) => void) => {\n            // Type guard for message with action\n            if (typeof message === 'object' && message !== null && 'action' in message) {\n              const typedMessage = message as Record<string, unknown>;\n\n              // Handle different actions\n              switch (typedMessage.action) {\n                case 'showError':\n                  this.logger?.warn('Error message received', { error: typedMessage });\n                  break;\n                case 'batchProgress':\n                  // Update batch progress UI if needed\n                  if (this.batchAnalysisUI) {\n                    this.batchAnalysisUI.updateProgress().catch((error) => {\n                      this.logger?.error('Failed to update batch progress', { error });\n                    });\n                  }\n                  break;\n                default:\n                  // Log unknown actions\n                  this.logger?.debug('Unknown message action', { action: typedMessage.action });\n              }\n\n              sendResponse({ success: true });\n              return false;\n            }\n\n            return false; // Let other handlers process the message\n          }\n        );\n      }\n    }\n  }\n\n  // ==========================================================================\n  // Private Methods - Utilities\n  // ==========================================================================\n\n  /**\n   * Sends a message to the background script.\n   *\n   * @param message - Message to send\n   * @returns Promise resolving to response\n   */\n  private sendMessage<T = unknown>(message: unknown): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      if (typeof window !== 'undefined' && 'browser' in window) {\n        const browser = (window as any).browser;\n        if (browser?.runtime) {\n          browser.runtime.sendMessage(message, (response: unknown) => {\n            const lastError = browser.runtime?.lastError;\n            if (lastError) {\n              reject(new Error(lastError.message));\n            } else {\n              resolve(response as T);\n            }\n          });\n        } else {\n          reject(new Error('Browser runtime not available'));\n        }\n      } else {\n        reject(new Error('Browser runtime not available'));\n      }\n    });\n  }\n}\n\n// ============================================================================\n// Extension Entry Point\n// ============================================================================\n\n/**\n * Main extension entry point.\n */\n(async function main(): Promise<void> {\n  startupLogger.info('Thunderbird Email AI Assistant - Options Script Loading');\n\n  try {\n    const optionsScript = new OptionsScript();\n    await optionsScript.initialize();\n\n    startupLogger.info('Thunderbird Email AI Assistant - Options Page Ready');\n  } catch (error) {\n    startupLogger.error('Failed to initialize options page', error);\n    document.body.innerHTML = `\n      <div style=\"color: red; padding: 20px;\">\n        <h2>Error initializing options page</h2>\n        <p>${error instanceof Error ? error.message : String(error)}</p>\n        <p>Please check the browser console for more details.</p>\n      </div>\n    `;\n  }\n})();\n\n// ============================================================================\n// Export for Testing\n// ============================================================================\n\nexport { OptionsScript };\n",
        "last_modified": "2026-01-06T15:39:51.891250"
      },
      "task_intent": {
        "title": "010-confidence-score-display-and-threshold-configurati",
        "description": "# Confidence Score Display and Threshold Configuration\n\nDisplay confidence scores for AI classifications and allow users to configure minimum confidence thresholds. Tags are only applied when confidence exceeds the threshold.\n\n## Rationale\nAddresses market gap-5: lack of transparency in AI decisions. Gmail and SaneBox don't explain why emails are categorized (pain-3-3). Users need to understand AI certainty and control when tags are applied to avoid incorrect classifications.\n\n## User Stories\n- As a cautious user, I want to see confidence scores so that I can understand how certain the AI is about its classifications\n- As a power user, I want to set minimum confidence thresholds so that only high-confidence tags are applied automatically\n\n## Acceptance Criteria\n- [ ] Confidence score (0-100%) is displayed alongside each tag suggestion\n- [ ] Global confidence threshold setting in options (default: 70%)\n- [ ] Per-tag confidence threshold override option\n- [ ] Low-confidence classifications are flagged for manual review\n- [ ] Confidence scores are stored with analysis history\n",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.139301",
  "last_updated": "2026-01-06T07:24:51.134065"
}