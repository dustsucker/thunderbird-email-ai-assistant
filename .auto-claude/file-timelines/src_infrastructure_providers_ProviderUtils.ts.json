{
  "file_path": "src/infrastructure/providers/ProviderUtils.ts",
  "main_branch_history": [],
  "task_views": {
    "003-confidence-score-display-and-threshold-configurati": {
      "task_id": "003-confidence-score-display-and-threshold-configurati",
      "branch_point": {
        "commit_hash": "f6a57e8f6ff34822855d2c5f711f425bd9bc6897",
        "content": "/**\n * Utility functions for provider implementations\n * @module providers/utils\n */\n\nimport type { AppConfig, CustomTags } from '@/shared/types/ProviderTypes';\nimport type { RequestBody } from './BaseProvider';\nimport { Provider, DEFAULT_CUSTOM_TAGS } from '../../../core/config';\n\n// ============================================================================\n// TYPE DEFINITIONS AND INTERFACES\n// ============================================================================\n\n/**\n * Log levels for the logger\n */\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n}\n\n/**\n * Error severity levels for UI display\n * - CRITICAL: Shows as alert/dialog, requires user attention\n * - WARNING: Shows as toast notification, non-blocking\n * - INFO: Shows as status message, informational only\n */\nexport enum ErrorSeverity {\n  INFO = 'info',\n  WARNING = 'warning',\n  CRITICAL = 'critical',\n}\n\n/**\n * Error types for categorization\n */\nexport enum ErrorType {\n  API = 'api', // API call failures\n  PROVIDER = 'provider', // Provider-specific errors\n  USER = 'user', // User configuration/validation errors\n  SYSTEM = 'system', // System-level errors (storage, permissions)\n  NETWORK = 'network', // Network connectivity errors\n  VALIDATION = 'validation', // Input validation errors\n}\n\n/**\n * Error display message for runtime communication\n */\nexport interface ErrorDisplay {\n  message: string;\n  severity: ErrorSeverity;\n  type?: ErrorType;\n  context?: LoggerContext;\n}\n\n/**\n * Runtime message for error display\n */\nexport interface ShowErrorRuntimeMessage {\n  action: 'showError';\n  error: ErrorDisplay;\n}\n\n/**\n * Log context object with optional metadata\n */\nexport type LoggerContext = Record<string, unknown>;\n\n/**\n * Sanitized log context with stringified values\n */\ntype SanitizedContext = Record<string, unknown> | string;\n\n/**\n * Logger interface with typed methods\n */\nexport interface Logger {\n  debug(message: string, context?: LoggerContext): void;\n  info(message: string, context?: LoggerContext): void;\n  warn(message: string, context?: LoggerContext): void;\n  error(message: string, context?: LoggerContext): void;\n  setLogLevel(level: LogLevel): void;\n}\n\n/**\n * Error types for transient error detection\n */\ninterface BaseError extends Error {\n  name: string;\n  message: string;\n  cause?: {\n    code?: string;\n    [key: string]: unknown;\n  };\n}\n\n/**\n * Type guard for error objects\n */\nfunction isError(value: unknown): value is Error {\n  return (\n    value instanceof Error || (typeof value === 'object' && value !== null && 'message' in value)\n  );\n}\n\n/**\n * Type guard for errors with cause property\n */\nfunction isErrorWithCause(error: Error): error is BaseError {\n  return 'cause' in error && typeof error.cause === 'object' && error.cause !== null;\n}\n\n/**\n * HTTP Response with status\n */\nexport interface HttpResponse {\n  status: number;\n  [key: string]: unknown;\n}\n\n/**\n * Configuration options for retry with backoff\n */\nexport interface RetryConfig {\n  /** Maximum number of retry attempts */\n  maxRetries?: number;\n  /** Base delay in milliseconds */\n  baseDelay?: number;\n  /** Exponential backoff multiplier */\n  factor?: number;\n  /** Jitter factor for random delay variation (0-1) */\n  jitter?: number;\n}\n\n/**\n * Schema field definition for validation\n */\ninterface SchemaField<T = unknown> {\n  type: 'string' | 'number' | 'array' | 'boolean';\n  required: boolean;\n  default: T;\n  itemType?: string;\n  validate?: (value: unknown) => boolean;\n}\n\n/**\n * Schema definition map\n */\ntype SchemaDefinition = Record<string, SchemaField>;\n\n/**\n * Tag response from LLM\n */\nexport interface TagResponse {\n  tags: string[];\n  confidence: number;\n  reasoning: string;\n  [key: string]: unknown;\n}\n\n/**\n * Validated unknown data\n */\nexport type Validated<T> = T;\n\n// ============================================================================\n// API SCHEMA DEFINITIONS\n// ============================================================================\n\n/**\n * Schema definition for Tag responses\n */\nconst TAG_RESPONSE_SCHEMA: SchemaDefinition = {\n  tags: {\n    type: 'array',\n    itemType: 'string',\n    required: true,\n    default: [] as string[],\n  },\n  confidence: {\n    type: 'number',\n    required: true,\n    default: 0.5,\n    validate: (value: unknown): boolean => typeof value === 'number' && value >= 0 && value <= 1,\n  },\n  reasoning: {\n    type: 'string',\n    required: false,\n    default: '',\n  },\n};\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Masks an API key for logging purposes\n * Shows first 7 and last 3 characters with ellipsis in between\n *\n * @param key - The API key to mask\n * @returns Masked key string\n *\n * @example\n * maskApiKey('sk-1234567890abcdef') // Returns 'sk-1234...def'\n * maskApiKey('short') // Returns '***'\n * maskApiKey(null) // Returns 'not set'\n */\nexport function maskApiKey(key: unknown): string {\n  if (!key || typeof key !== 'string') return 'not set';\n  if (key.length <= 10) return '***';\n  return key.slice(0, 7) + '...' + key.slice(-3);\n}\n\n// ============================================================================\n// LOGGER IMPLEMENTATION\n// ============================================================================\n\nlet currentLogLevel: LogLevel = LogLevel.INFO;\n\n/**\n * Sets the current log level\n *\n * @param level - The log level to set\n */\nfunction setLogLevel(level: LogLevel): void {\n  currentLogLevel = level;\n}\n\n/**\n * Internal logging function\n *\n * @param level - The log level\n * @param message - The log message\n * @param context - Optional context object\n */\nfunction log(level: LogLevel, message: string, context: LoggerContext = {}): void {\n  if (level >= currentLogLevel) {\n    const timestamp = new Date().toISOString();\n    const levelName = LogLevel[level];\n    // Separate log calls to prevent browser DevTools from showing raw context object\n    console.log(`[${timestamp}] [${levelName}] ${message}`);\n    if (Object.keys(context).length > 0) {\n      const sanitizedContext = sanitizeContext(context);\n      console.log('Context:', sanitizedContext);\n    }\n  }\n}\n\n/**\n * Sanitizes context object by masking sensitive fields recursively\n * Handles nested objects and arrays to ensure API keys are never logged\n *\n * @param context - The context object to sanitize\n * @param depth - Current recursion depth (prevents infinite recursion)\n * @returns Sanitized context object\n */\nfunction sanitizeContext(context: LoggerContext, depth: number = 0): SanitizedContext {\n  const MAX_DEPTH = 10;\n\n  if (!context || typeof context !== 'object') return context;\n  if (depth > MAX_DEPTH) return '[Max depth reached]';\n\n  const sanitized: SanitizedContext = {};\n  const keyPatterns = ['key', 'token', 'password', 'secret'];\n\n  for (const [key, value] of Object.entries(context)) {\n    const isSensitive = keyPatterns.some((pattern) => key.toLowerCase().includes(pattern));\n\n    if (isSensitive) {\n      // Mask sensitive values\n      sanitized[key] = maskApiKey(value);\n    } else if (Array.isArray(value)) {\n      // Recursively sanitize array elements\n      sanitized[key] = value.map((item) =>\n        typeof item === 'object' && item !== null\n          ? sanitizeContext(item as LoggerContext, depth + 1)\n          : item\n      );\n    } else if (typeof value === 'object' && value !== null) {\n      // Recursively sanitize nested objects\n      sanitized[key] = sanitizeContext(value as LoggerContext, depth + 1);\n    } else {\n      sanitized[key] = value;\n    }\n  }\n\n  return sanitized;\n}\n\n/**\n * Logger instance with typed methods\n */\nexport const logger: Logger = {\n  debug: (msg: string, ctx?: LoggerContext): void => log(LogLevel.DEBUG, msg, ctx),\n  info: (msg: string, ctx?: LoggerContext): void => log(LogLevel.INFO, msg, ctx),\n  warn: (msg: string, ctx?: LoggerContext): void => log(LogLevel.WARN, msg, ctx),\n  error: (msg: string, ctx?: LoggerContext): void => log(LogLevel.ERROR, msg, ctx),\n  setLogLevel,\n};\n\n// ============================================================================\n// ERROR DISPLAY HELPERS\n// ============================================================================\n\n/**\n * Logs an error and sends it to the UI for display\n * This is the standard error handling function for the entire application\n *\n * @param error - The error to handle (can be Error, string, or unknown)\n * @param type - Error type for categorization\n * @param context - Additional context information\n * @param customMessage - Optional custom message to override the error message\n */\nexport function logAndDisplayError(\n  error: unknown,\n  type: ErrorType = ErrorType.SYSTEM,\n  context: LoggerContext = {},\n  customMessage?: string\n): void {\n  // Extract error message\n  const errorMessage = customMessage || (error instanceof Error ? error.message : String(error));\n\n  // Determine severity based on error type and content\n  const severity = determineErrorSeverity(error, type);\n\n  // Create error display object\n  const errorDisplay: ErrorDisplay = {\n    message: errorMessage,\n    severity,\n    type,\n    context,\n  };\n\n  // Log the error with full context\n  logger.error(`[${type.toUpperCase()}] ${errorMessage}`, {\n    ...context,\n    severity,\n    errorMessage,\n    stack: error instanceof Error ? error.stack : undefined,\n  });\n\n  // Send error to UI via runtime message\n  sendErrorToUI(errorDisplay).catch((sendError) => {\n    logger.error('Failed to send error to UI', {\n      originalError: errorMessage,\n      sendError: sendError instanceof Error ? sendError.message : String(sendError),\n    });\n  });\n}\n\n/**\n * Determines error severity based on error type and content\n *\n * @param error - The error to evaluate\n * @param type - Error type\n * @returns Appropriate severity level\n */\nfunction determineErrorSeverity(error: unknown, type: ErrorType): ErrorSeverity {\n  const errorMessage =\n    error instanceof Error ? error.message.toLowerCase() : String(error).toLowerCase();\n\n  // CRITICAL errors\n  if (type === ErrorType.SYSTEM) {\n    return ErrorSeverity.CRITICAL;\n  }\n  if (errorMessage.includes('permission')) {\n    return ErrorSeverity.CRITICAL;\n  }\n  if (errorMessage.includes('configuration')) {\n    return ErrorSeverity.CRITICAL;\n  }\n\n  // WARNING errors\n  if (type === ErrorType.NETWORK || type === ErrorType.API) {\n    return ErrorSeverity.WARNING;\n  }\n  if (errorMessage.includes('timeout')) {\n    return ErrorSeverity.WARNING;\n  }\n  if (errorMessage.includes('rate limit')) {\n    return ErrorSeverity.WARNING;\n  }\n\n  // INFO errors (usually validation or user input issues)\n  if (type === ErrorType.VALIDATION || type === ErrorType.USER) {\n    return ErrorSeverity.INFO;\n  }\n\n  // Default to CRITICAL for unknown errors\n  return ErrorSeverity.CRITICAL;\n}\n\n/**\n * Sends error display message to UI via runtime API\n * Note: This function works in background script context\n *\n * @param errorDisplay - Error information to display\n */\nasync function sendErrorToUI(errorDisplay: ErrorDisplay): Promise<void> {\n  try {\n    // Check if we're in a browser extension context\n    // @ts-expect-error - browser runtime API is available in extension context\n    if (typeof browser !== 'undefined' && browser.runtime) {\n      const message: ShowErrorRuntimeMessage = {\n        action: 'showError',\n        error: errorDisplay,\n      };\n\n      // Try to send message to options page\n      // @ts-expect-error - browser runtime sendMessage is valid for WebExtensions\n      browser.runtime.sendMessage(message).catch((reason: unknown) => {\n        // Options page might not be open, this is acceptable\n        const errorMsg = reason instanceof Error ? reason.message : String(reason);\n        if (!errorMsg.includes('Receiving end does not exist')) {\n          logger.warn('Failed to send error to UI', { error: errorMsg });\n        }\n      });\n    }\n  } catch (error) {\n    // Runtime API not available (not in extension context)\n    logger.debug('Runtime API not available for error display');\n  }\n}\n\n// ============================================================================\n// JSON EXTRACTION\n// ============================================================================\n\n/**\n * Type guard for unknown data being a string\n */\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Extracts the first valid JSON object from a text string\n * Handles nested objects by counting braces\n *\n * @param text - Text potentially containing JSON\n * @returns Extracted JSON string\n * @throws {Error} If no valid JSON object is found\n *\n * @example\n * extractJson('Here is some text {\"key\": \"value\"} more text') // Returns '{\"key\": \"value\"}'\n * extractJson('{\"nested\": {\"deep\": true}}') // Returns '{\"nested\": {\"deep\": true}}'\n */\nexport function extractJson(text: unknown): string {\n  if (!isString(text)) {\n    throw new Error('Input must be a string');\n  }\n\n  let firstBrace = -1;\n  let braceCount = 0;\n\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '{') {\n      if (firstBrace === -1) firstBrace = i;\n      braceCount++;\n    } else if (text[i] === '}') {\n      braceCount--;\n      if (braceCount === 0 && firstBrace !== -1) {\n        const extracted = text.substring(firstBrace, i + 1);\n        logger.info('[LLM-EXTRACT-JSON] Extracted JSON:', {\n          startIdx: firstBrace,\n          endIdx: i + 1,\n          length: extracted.length,\n          preview: extracted.substring(0, 200),\n        });\n        return extracted;\n      }\n    }\n  }\n\n  logger.info('[LLM-EXTRACT-JSON] No JSON found in text', {\n    textLength: text.length,\n    hasBrace: text.includes('{'),\n    preview: text.substring(0, 200),\n  });\n  throw new Error('Could not find a valid JSON object in the response.');\n}\n\n// ============================================================================\n// RETRY WITH BACKOFF\n// ============================================================================\n\n/**\n * Checks if an error is a transient (retryable) error\n * Transient errors include network errors and connection resets\n *\n * @param error - The error to check\n * @returns True if the error is transient\n */\nfunction isTransientError(error: unknown): boolean {\n  if (!isError(error)) return false;\n\n  if (error.name === 'TypeError' && error.message.includes('fetch')) return true;\n  if (error.name === 'NetworkError') return true;\n\n  if (isErrorWithCause(error)) {\n    const code = error.cause?.code;\n    if (code === 'ECONNRESET' || code === 'ECONNREFUSED') return true;\n  }\n\n  return false;\n}\n\n/**\n * Checks if an HTTP status code is retryable\n * Retryable statuses: 5xx, 408 (Request Timeout), 429 (Too Many Requests)\n *\n * @param status - HTTP status code\n * @returns True if the status is retryable\n */\nfunction isRetryableStatus(status: number): boolean {\n  return status >= 500 || status === 408 || status === 429;\n}\n\n/**\n * Type guard for objects with status property\n */\nfunction hasStatus(obj: unknown): obj is { status: number } {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    'status' in obj &&\n    typeof (obj as { status: unknown }).status === 'number'\n  );\n}\n\n/**\n * Retries an async function with exponential backoff and jitter\n *\n * @template T - Return type of the function\n * @param fn - Async function to retry\n * @param options - Retry configuration options\n * @returns Promise resolving to the function result\n * @throws The last error if all retries are exhausted\n *\n * @example\n * await retryWithBackoff(() => fetch('/api/data'), { maxRetries: 3 })\n *\n * @example\n * await retryWithBackoff(() => fetchData(), {\n *   maxRetries: 5,\n *   baseDelay: 2000,\n *   factor: 2,\n *   jitter: 0.3\n * })\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  options: RetryConfig = {}\n): Promise<T> {\n  const { maxRetries = 3, baseDelay = 1000, factor = 2, jitter = 0.5 } = options;\n\n  let lastError: unknown;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      const result = await fn();\n\n      // Check if result has retryable status\n      if (hasStatus(result) && isRetryableStatus(result.status)) {\n        throw new Error(`HTTP ${result.status}`);\n      }\n\n      return result;\n    } catch (error) {\n      lastError = error;\n\n      const hasErrorStatus =\n        isError(error) && typeof (error as unknown as { status?: unknown }).status === 'number';\n      const status = hasErrorStatus ? (error as unknown as { status: number }).status : null;\n      const isTransient = isTransientError(error) || (status !== null && isRetryableStatus(status));\n\n      if (attempt === maxRetries || !isTransient) {\n        throw lastError;\n      }\n\n      // Calculate delay with exponential backoff and jitter\n      const exponentialDelay = baseDelay * Math.pow(factor, attempt);\n      const jitterAmount = exponentialDelay * jitter * (Math.random() * 2 - 1);\n      const delay = exponentialDelay + jitterAmount;\n\n      await new Promise<void>((resolve) => setTimeout(resolve, Math.max(0, delay)));\n    }\n  }\n\n  throw lastError;\n}\n\n// ============================================================================\n// VALIDATION\n// ============================================================================\n\n/**\n * Logs validation errors\n *\n * @param message - Error message\n * @param details - Additional error details\n */\nfunction logError(message: string, details: LoggerContext = {}): void {\n  logger.error(`[Validation Error] ${message}`, details);\n}\n\n/**\n * Validates and sanitizes a value against a schema definition\n *\n * @template T - Expected type of the value\n * @param value - The value to validate\n * @param schema - Schema definition\n * @param fieldName - Name of the field being validated\n * @returns Validated and sanitized value\n */\nfunction validateValue<T>(value: unknown, schema: SchemaField<T>, fieldName: string): T {\n  // Handle missing/undefined values\n  if (value === undefined || value === null) {\n    if (schema.required) {\n      logError(`Missing required field: ${fieldName}`, { received: value });\n    }\n    return schema.default;\n  }\n\n  // Type validation and conversion\n  switch (schema.type) {\n    case 'string': {\n      if (typeof value !== 'string') {\n        logError(`Type mismatch for ${fieldName}: expected string`, {\n          received: typeof value,\n        });\n        return schema.default;\n      }\n      return value as T;\n    }\n\n    case 'number': {\n      let numValue: number;\n\n      if (typeof value !== 'number') {\n        const converted = Number(value);\n        if (isNaN(converted)) {\n          logError(`Type mismatch for ${fieldName}: expected number`, {\n            received: typeof value,\n          });\n          return schema.default;\n        }\n        numValue = converted;\n      } else {\n        numValue = value;\n      }\n\n      if (schema.validate && !schema.validate(numValue as unknown)) {\n        logError(`Validation failed for ${fieldName}`, { received: numValue });\n        return schema.default;\n      }\n\n      return numValue as T;\n    }\n\n    case 'array': {\n      if (!Array.isArray(value)) {\n        logError(`Type mismatch for ${fieldName}: expected array`, {\n          received: typeof value,\n        });\n        return schema.default;\n      }\n\n      return value as T;\n    }\n\n    case 'boolean': {\n      if (typeof value !== 'boolean') {\n        logError(`Type mismatch for ${fieldName}: expected boolean`, {\n          received: typeof value,\n        });\n        return schema.default;\n      }\n\n      return value as T;\n    }\n\n    default:\n      return schema.default;\n  }\n}\n\n/**\n * Type guard for parsed JSON object\n */\nfunction isJsonObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n/**\n * Validates an LLM response against the Tag schema\n * Handles JSON parsing errors, schema validation, and fallbacks\n *\n * @param response - Raw response (string or already parsed object)\n * @returns Validated response with fallback values\n *\n * @example\n * validateLLMResponse('{\"tags\": [\"work\", \"urgent\"], \"confidence\": 0.8}')\n * // Returns { tags: [\"work\", \"urgent\"], confidence: 0.8, reasoning: \"\" }\n *\n * @example\n * validateLLMResponse('Some text {\"tags\": [\"personal\"]} more text')\n * // Returns { tags: [\"personal\"], confidence: 0.5, reasoning: \"\" }\n *\n * @example\n * validateLLMResponse('invalid json')\n * // Returns { tags: [], confidence: 0.5, reasoning: \"\" }\n */\nexport function validateLLMResponse(response: unknown): TagResponse {\n  // Log raw response for debugging\n  logger.info('[LLM-RAW-RESPONSE] Raw LLM response:', {\n    type: typeof response,\n    preview:\n      typeof response === 'string'\n        ? response.substring(0, 500)\n        : JSON.stringify(response).substring(0, 500),\n    isNull: response === null,\n    isUndefined: response === undefined,\n    isEmpty: typeof response === 'string' && response.trim().length === 0,\n  });\n\n  let parsed: Record<string, unknown>;\n\n  // Parse JSON if response is a string\n  if (isString(response)) {\n    try {\n      // First try to extract JSON if it's embedded in text\n      const jsonText = extractJson(response);\n      parsed = JSON.parse(jsonText) as Record<string, unknown>;\n      logger.info('[LLM-PARSED-JSON] Parsed JSON (extracted):', {\n        keys: Object.keys(parsed),\n        hasTags: 'tags' in parsed,\n        hasConfidence: 'confidence' in parsed,\n        tagsValue: parsed.tags,\n        confidenceValue: parsed.confidence,\n      });\n    } catch (error) {\n      // Fallback: try parsing the whole string as JSON\n      try {\n        parsed = JSON.parse(response) as Record<string, unknown>;\n        logger.info('[LLM-PARSED-JSON] Parsed JSON (fallback):', {\n          keys: Object.keys(parsed),\n          hasTags: 'tags' in parsed,\n          hasConfidence: 'confidence' in parsed,\n          tagsValue: parsed.tags,\n          confidenceValue: parsed.confidence,\n        });\n      } catch (parseError) {\n        const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);\n        logError('Failed to parse JSON response', {\n          error: errorMessage,\n          response: response.substring(0, 200),\n        });\n        // Return fallback response\n        return {\n          tags: [],\n          confidence: 0.5,\n          reasoning: '',\n        };\n      }\n    }\n  } else if (isJsonObject(response)) {\n    parsed = response;\n    logger.info('[LLM-PARSED-JSON] Parsed JSON (object input):', {\n      keys: Object.keys(parsed),\n      hasTags: 'tags' in parsed,\n      hasConfidence: 'confidence' in parsed,\n      tagsValue: parsed.tags,\n      confidenceValue: parsed.confidence,\n    });\n  } else {\n    logError('Invalid response type', { type: typeof response });\n    return {\n      tags: [],\n      confidence: 0.5,\n      reasoning: '',\n    };\n  }\n\n  // Validate each field against schema\n  const validated = {} as TagResponse;\n  for (const [fieldName, schema] of Object.entries(TAG_RESPONSE_SCHEMA)) {\n    validated[fieldName as keyof TagResponse] = validateValue(\n      parsed[fieldName] as unknown,\n      schema,\n      fieldName\n    );\n  }\n\n  return validated;\n}\n\n// ============================================================================\n// APP CONFIG VALIDATION\n// ============================================================================\n\n/**\n * Type guard for checking if a value is a valid CustomTags array\n * @param value - Value to check\n * @returns True if value is a valid CustomTags array\n */\nfunction isCustomTags(value: unknown): value is CustomTags {\n  if (!Array.isArray(value)) return false;\n\n  for (const item of value) {\n    if (typeof item !== 'object' || item === null) return false;\n    const tag = item as Record<string, unknown>;\n\n    if (typeof tag.key !== 'string' || tag.key.trim().length === 0) return false;\n    if (typeof tag.name !== 'string' || tag.name.trim().length === 0) return false;\n    if (typeof tag.color !== 'string' || !/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(tag.color))\n      return false;\n    // prompt is optional\n  }\n\n  return true;\n}\n\n/**\n * Validates and sanitizes a partial AppConfig from storage\n * @param result - Storage result to validate\n * @returns Validated Partial<AppConfig> with fallback values for invalid fields\n */\nexport function validateAppConfig(result: Record<string, unknown>): Partial<AppConfig> {\n  const validated: Partial<AppConfig> = {};\n\n  // Validate provider (string, must be valid provider)\n  if (typeof result.provider === 'string') {\n    if (Object.values(Provider).includes(result.provider as Provider)) {\n      validated.provider = result.provider as Provider;\n    }\n  }\n\n  // Validate boolean fields\n  if (typeof result.enableNotifications === 'boolean') {\n    validated.enableNotifications = result.enableNotifications;\n  }\n  if (typeof result.enableLogging === 'boolean') {\n    validated.enableLogging = result.enableLogging;\n  }\n\n  // Validate API key fields (strings)\n  if (typeof result.openaiApiKey === 'string') {\n    validated.openaiApiKey = result.openaiApiKey;\n  }\n  if (typeof result.geminiApiKey === 'string') {\n    validated.geminiApiKey = result.geminiApiKey;\n  }\n  if (typeof result.claudeApiKey === 'string') {\n    validated.claudeApiKey = result.claudeApiKey;\n  }\n  if (typeof result.mistralApiKey === 'string') {\n    validated.mistralApiKey = result.mistralApiKey;\n  }\n  if (typeof result.deepseekApiKey === 'string') {\n    validated.deepseekApiKey = result.deepseekApiKey;\n  }\n  if (typeof result.zaiPaasApiKey === 'string') {\n    validated.zaiPaasApiKey = result.zaiPaasApiKey;\n  }\n  if (typeof result.zaiCodingApiKey === 'string') {\n    validated.zaiCodingApiKey = result.zaiCodingApiKey;\n  }\n\n  if (typeof result.ollamaApiUrl === 'string') {\n    validated.ollamaApiUrl = result.ollamaApiUrl;\n  }\n  if (typeof result.ollamaModel === 'string') {\n    validated.ollamaModel = result.ollamaModel;\n  }\n  if (typeof result.zaiPaasModel === 'string') {\n    validated.zaiPaasModel = result.zaiPaasModel;\n  }\n  if (typeof result.zaiCodingModel === 'string') {\n    validated.zaiCodingModel = result.zaiCodingModel;\n  }\n\n  // Validate customTags (array of Tag objects)\n  if (isCustomTags(result.customTags)) {\n    validated.customTags = result.customTags;\n  }\n\n  return validated;\n}\n\n/**\n * Validates customTags storage result\n * @param result - Storage result containing customTags\n * @returns Validated customTags or default if invalid\n */\nexport function validateCustomTagsResult(result: Record<string, unknown>): {\n  customTags: CustomTags;\n} {\n  if (isCustomTags(result.customTags)) {\n    return { customTags: result.customTags };\n  }\n\n  return { customTags: DEFAULT_CUSTOM_TAGS };\n}\n\n// ============================================================================\n// REQUEST BODY VALIDATION\n// ============================================================================\n\n/**\n * Validates that a value is a valid RequestBody (non-null object)\n * @param payload - Payload to validate\n * @returns Validated RequestBody\n * @throws {Error} If payload is invalid\n */\nexport function validateRequestBody(payload: unknown): RequestBody {\n  if (typeof payload !== 'object' || payload === null) {\n    throw new Error('RequestBody must be a non-null object');\n  }\n\n  return payload as Record<string, unknown>;\n}\n\n// ============================================================================\n// DEBOUNCE UTILITY\n// ============================================================================\n\n/**\n * Creates a debounced version of a function that delays invoking func until after wait milliseconds\n * have elapsed since the last time the debounced function was invoked.\n *\n * @template T - Function type to debounce\n * @param func - Function to debounce\n * @param wait - Delay in milliseconds\n * @returns Debounced function\n *\n * @example\n * const debouncedSearch = debounce((query: string) => searchAPI(query), 500);\n * inputElement.addEventListener('input', () => debouncedSearch(inputElement.value));\n */\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: number | null = null;\n\n  return function (this: any, ...args: Parameters<T>) {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n    timeout = window.setTimeout(() => func.apply(this, args), wait);\n  };\n}\n\n// ============================================================================\n// TYPE GUARDS FOR COMMON TYPES\n// ============================================================================\n\n/**\n * Type guard for BatchAnalysisProgress\n * @param value - Value to check\n * @returns True if value is a valid BatchAnalysisProgress\n */\nexport function isBatchAnalysisProgress(value: unknown): value is BatchAnalysisProgress {\n  if (typeof value !== 'object' || value === null) return false;\n\n  const obj = value as Record<string, unknown>;\n  const validStatuses = ['idle', 'running', 'completed', 'cancelled', 'error'];\n\n  return (\n    typeof obj.status === 'string' &&\n    validStatuses.includes(obj.status) &&\n    typeof obj.total === 'number' &&\n    typeof obj.processed === 'number' &&\n    typeof obj.successful === 'number' &&\n    typeof obj.failed === 'number' &&\n    typeof obj.startTime === 'number'\n  );\n}\n\n// Import BatchAnalysisProgress type for type guard\ntype BatchAnalysisProgress = {\n  status: 'idle' | 'running' | 'completed' | 'cancelled' | 'error';\n  total: number;\n  processed: number;\n  successful: number;\n  failed: number;\n  startTime: number;\n  endTime?: number;\n  errorMessage?: string;\n};\n",
        "timestamp": "2026-01-05T14:48:03.044500"
      },
      "worktree_state": {
        "content": "/**\n * Utility functions for provider implementations\n * @module providers/utils\n */\n\nimport type { AppConfig, CustomTags } from '@/shared/types/ProviderTypes';\nimport type { RequestBody } from './BaseProvider';\nimport { Provider, DEFAULT_CUSTOM_TAGS } from '../../../core/config';\n\n// ============================================================================\n// TYPE DEFINITIONS AND INTERFACES\n// ============================================================================\n\n/**\n * Log levels for the logger\n */\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n}\n\n/**\n * Error severity levels for UI display\n * - CRITICAL: Shows as alert/dialog, requires user attention\n * - WARNING: Shows as toast notification, non-blocking\n * - INFO: Shows as status message, informational only\n */\nexport enum ErrorSeverity {\n  INFO = 'info',\n  WARNING = 'warning',\n  CRITICAL = 'critical',\n}\n\n/**\n * Error types for categorization\n */\nexport enum ErrorType {\n  API = 'api', // API call failures\n  PROVIDER = 'provider', // Provider-specific errors\n  USER = 'user', // User configuration/validation errors\n  SYSTEM = 'system', // System-level errors (storage, permissions)\n  NETWORK = 'network', // Network connectivity errors\n  VALIDATION = 'validation', // Input validation errors\n}\n\n/**\n * Error display message for runtime communication\n */\nexport interface ErrorDisplay {\n  message: string;\n  severity: ErrorSeverity;\n  type?: ErrorType;\n  context?: LoggerContext;\n}\n\n/**\n * Runtime message for error display\n */\nexport interface ShowErrorRuntimeMessage {\n  action: 'showError';\n  error: ErrorDisplay;\n}\n\n/**\n * Log context object with optional metadata\n */\nexport type LoggerContext = Record<string, unknown>;\n\n/**\n * Sanitized log context with stringified values\n */\ntype SanitizedContext = Record<string, unknown> | string;\n\n/**\n * Logger interface with typed methods\n */\nexport interface Logger {\n  debug(message: string, context?: LoggerContext): void;\n  info(message: string, context?: LoggerContext): void;\n  warn(message: string, context?: LoggerContext): void;\n  error(message: string, context?: LoggerContext): void;\n  setLogLevel(level: LogLevel): void;\n}\n\n/**\n * Error types for transient error detection\n */\ninterface BaseError extends Error {\n  name: string;\n  message: string;\n  cause?: {\n    code?: string;\n    [key: string]: unknown;\n  };\n}\n\n/**\n * Type guard for error objects\n */\nfunction isError(value: unknown): value is Error {\n  return (\n    value instanceof Error || (typeof value === 'object' && value !== null && 'message' in value)\n  );\n}\n\n/**\n * Type guard for errors with cause property\n */\nfunction isErrorWithCause(error: Error): error is BaseError {\n  return 'cause' in error && typeof error.cause === 'object' && error.cause !== null;\n}\n\n/**\n * HTTP Response with status\n */\nexport interface HttpResponse {\n  status: number;\n  [key: string]: unknown;\n}\n\n/**\n * Configuration options for retry with backoff\n */\nexport interface RetryConfig {\n  /** Maximum number of retry attempts */\n  maxRetries?: number;\n  /** Base delay in milliseconds */\n  baseDelay?: number;\n  /** Exponential backoff multiplier */\n  factor?: number;\n  /** Jitter factor for random delay variation (0-1) */\n  jitter?: number;\n}\n\n/**\n * Schema field definition for validation\n */\ninterface SchemaField<T = unknown> {\n  type: 'string' | 'number' | 'array' | 'boolean';\n  required: boolean;\n  default: T;\n  itemType?: string;\n  validate?: (value: unknown) => boolean;\n}\n\n/**\n * Schema definition map\n */\ntype SchemaDefinition = Record<string, SchemaField>;\n\n/**\n * Tag response from LLM\n */\nexport interface TagResponse {\n  tags: string[];\n  confidence: number;\n  confidence_score: number;\n  reasoning: string;\n  [key: string]: unknown;\n}\n\n/**\n * Validated unknown data\n */\nexport type Validated<T> = T;\n\n// ============================================================================\n// API SCHEMA DEFINITIONS\n// ============================================================================\n\n/**\n * Schema definition for Tag responses\n */\nconst TAG_RESPONSE_SCHEMA: SchemaDefinition = {\n  tags: {\n    type: 'array',\n    itemType: 'string',\n    required: true,\n    default: [] as string[],\n  },\n  confidence: {\n    type: 'number',\n    required: true,\n    default: 0.5,\n    validate: (value: unknown): boolean => typeof value === 'number' && value >= 0 && value <= 1,\n  },\n  reasoning: {\n    type: 'string',\n    required: false,\n    default: '',\n  },\n};\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Masks an API key for logging purposes\n * Shows first 7 and last 3 characters with ellipsis in between\n *\n * @param key - The API key to mask\n * @returns Masked key string\n *\n * @example\n * maskApiKey('sk-1234567890abcdef') // Returns 'sk-1234...def'\n * maskApiKey('short') // Returns '***'\n * maskApiKey(null) // Returns 'not set'\n */\nexport function maskApiKey(key: unknown): string {\n  if (!key || typeof key !== 'string') return 'not set';\n  if (key.length <= 10) return '***';\n  return key.slice(0, 7) + '...' + key.slice(-3);\n}\n\n// ============================================================================\n// LOGGER IMPLEMENTATION\n// ============================================================================\n\nlet currentLogLevel: LogLevel = LogLevel.INFO;\n\n/**\n * Sets the current log level\n *\n * @param level - The log level to set\n */\nfunction setLogLevel(level: LogLevel): void {\n  currentLogLevel = level;\n}\n\n/**\n * Internal logging function\n *\n * @param level - The log level\n * @param message - The log message\n * @param context - Optional context object\n */\nfunction log(level: LogLevel, message: string, context: LoggerContext = {}): void {\n  if (level >= currentLogLevel) {\n    const timestamp = new Date().toISOString();\n    const levelName = LogLevel[level];\n    // Separate log calls to prevent browser DevTools from showing raw context object\n    console.log(`[${timestamp}] [${levelName}] ${message}`);\n    if (Object.keys(context).length > 0) {\n      const sanitizedContext = sanitizeContext(context);\n      console.log('Context:', sanitizedContext);\n    }\n  }\n}\n\n/**\n * Sanitizes context object by masking sensitive fields recursively\n * Handles nested objects and arrays to ensure API keys are never logged\n *\n * @param context - The context object to sanitize\n * @param depth - Current recursion depth (prevents infinite recursion)\n * @returns Sanitized context object\n */\nfunction sanitizeContext(context: LoggerContext, depth: number = 0): SanitizedContext {\n  const MAX_DEPTH = 10;\n\n  if (!context || typeof context !== 'object') return context;\n  if (depth > MAX_DEPTH) return '[Max depth reached]';\n\n  const sanitized: SanitizedContext = {};\n  const keyPatterns = ['key', 'token', 'password', 'secret'];\n\n  for (const [key, value] of Object.entries(context)) {\n    const isSensitive = keyPatterns.some((pattern) => key.toLowerCase().includes(pattern));\n\n    if (isSensitive) {\n      // Mask sensitive values\n      sanitized[key] = maskApiKey(value);\n    } else if (Array.isArray(value)) {\n      // Recursively sanitize array elements\n      sanitized[key] = value.map((item) =>\n        typeof item === 'object' && item !== null\n          ? sanitizeContext(item as LoggerContext, depth + 1)\n          : item\n      );\n    } else if (typeof value === 'object' && value !== null) {\n      // Recursively sanitize nested objects\n      sanitized[key] = sanitizeContext(value as LoggerContext, depth + 1);\n    } else {\n      sanitized[key] = value;\n    }\n  }\n\n  return sanitized;\n}\n\n/**\n * Logger instance with typed methods\n */\nexport const logger: Logger = {\n  debug: (msg: string, ctx?: LoggerContext): void => log(LogLevel.DEBUG, msg, ctx),\n  info: (msg: string, ctx?: LoggerContext): void => log(LogLevel.INFO, msg, ctx),\n  warn: (msg: string, ctx?: LoggerContext): void => log(LogLevel.WARN, msg, ctx),\n  error: (msg: string, ctx?: LoggerContext): void => log(LogLevel.ERROR, msg, ctx),\n  setLogLevel,\n};\n\n// ============================================================================\n// ERROR DISPLAY HELPERS\n// ============================================================================\n\n/**\n * Logs an error and sends it to the UI for display\n * This is the standard error handling function for the entire application\n *\n * @param error - The error to handle (can be Error, string, or unknown)\n * @param type - Error type for categorization\n * @param context - Additional context information\n * @param customMessage - Optional custom message to override the error message\n */\nexport function logAndDisplayError(\n  error: unknown,\n  type: ErrorType = ErrorType.SYSTEM,\n  context: LoggerContext = {},\n  customMessage?: string\n): void {\n  // Extract error message\n  const errorMessage = customMessage || (error instanceof Error ? error.message : String(error));\n\n  // Determine severity based on error type and content\n  const severity = determineErrorSeverity(error, type);\n\n  // Create error display object\n  const errorDisplay: ErrorDisplay = {\n    message: errorMessage,\n    severity,\n    type,\n    context,\n  };\n\n  // Log the error with full context\n  logger.error(`[${type.toUpperCase()}] ${errorMessage}`, {\n    ...context,\n    severity,\n    errorMessage,\n    stack: error instanceof Error ? error.stack : undefined,\n  });\n\n  // Send error to UI via runtime message\n  sendErrorToUI(errorDisplay).catch((sendError) => {\n    logger.error('Failed to send error to UI', {\n      originalError: errorMessage,\n      sendError: sendError instanceof Error ? sendError.message : String(sendError),\n    });\n  });\n}\n\n/**\n * Determines error severity based on error type and content\n *\n * @param error - The error to evaluate\n * @param type - Error type\n * @returns Appropriate severity level\n */\nfunction determineErrorSeverity(error: unknown, type: ErrorType): ErrorSeverity {\n  const errorMessage =\n    error instanceof Error ? error.message.toLowerCase() : String(error).toLowerCase();\n\n  // CRITICAL errors\n  if (type === ErrorType.SYSTEM) {\n    return ErrorSeverity.CRITICAL;\n  }\n  if (errorMessage.includes('permission')) {\n    return ErrorSeverity.CRITICAL;\n  }\n  if (errorMessage.includes('configuration')) {\n    return ErrorSeverity.CRITICAL;\n  }\n\n  // WARNING errors\n  if (type === ErrorType.NETWORK || type === ErrorType.API) {\n    return ErrorSeverity.WARNING;\n  }\n  if (errorMessage.includes('timeout')) {\n    return ErrorSeverity.WARNING;\n  }\n  if (errorMessage.includes('rate limit')) {\n    return ErrorSeverity.WARNING;\n  }\n\n  // INFO errors (usually validation or user input issues)\n  if (type === ErrorType.VALIDATION || type === ErrorType.USER) {\n    return ErrorSeverity.INFO;\n  }\n\n  // Default to CRITICAL for unknown errors\n  return ErrorSeverity.CRITICAL;\n}\n\n/**\n * Sends error display message to UI via runtime API\n * Note: This function works in background script context\n *\n * @param errorDisplay - Error information to display\n */\nasync function sendErrorToUI(errorDisplay: ErrorDisplay): Promise<void> {\n  try {\n    // Check if we're in a browser extension context\n    // @ts-expect-error - browser runtime API is available in extension context\n    if (typeof browser !== 'undefined' && browser.runtime) {\n      const message: ShowErrorRuntimeMessage = {\n        action: 'showError',\n        error: errorDisplay,\n      };\n\n      // Try to send message to options page\n      // @ts-expect-error - browser runtime sendMessage is valid for WebExtensions\n      browser.runtime.sendMessage(message).catch((reason: unknown) => {\n        // Options page might not be open, this is acceptable\n        const errorMsg = reason instanceof Error ? reason.message : String(reason);\n        if (!errorMsg.includes('Receiving end does not exist')) {\n          logger.warn('Failed to send error to UI', { error: errorMsg });\n        }\n      });\n    }\n  } catch (error) {\n    // Runtime API not available (not in extension context)\n    logger.debug('Runtime API not available for error display');\n  }\n}\n\n// ============================================================================\n// JSON EXTRACTION\n// ============================================================================\n\n/**\n * Type guard for unknown data being a string\n */\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Extracts the first valid JSON object from a text string\n * Handles nested objects by counting braces\n *\n * @param text - Text potentially containing JSON\n * @returns Extracted JSON string\n * @throws {Error} If no valid JSON object is found\n *\n * @example\n * extractJson('Here is some text {\"key\": \"value\"} more text') // Returns '{\"key\": \"value\"}'\n * extractJson('{\"nested\": {\"deep\": true}}') // Returns '{\"nested\": {\"deep\": true}}'\n */\nexport function extractJson(text: unknown): string {\n  if (!isString(text)) {\n    throw new Error('Input must be a string');\n  }\n\n  let firstBrace = -1;\n  let braceCount = 0;\n\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] === '{') {\n      if (firstBrace === -1) firstBrace = i;\n      braceCount++;\n    } else if (text[i] === '}') {\n      braceCount--;\n      if (braceCount === 0 && firstBrace !== -1) {\n        const extracted = text.substring(firstBrace, i + 1);\n        logger.info('[LLM-EXTRACT-JSON] Extracted JSON:', {\n          startIdx: firstBrace,\n          endIdx: i + 1,\n          length: extracted.length,\n          preview: extracted.substring(0, 200),\n        });\n        return extracted;\n      }\n    }\n  }\n\n  logger.info('[LLM-EXTRACT-JSON] No JSON found in text', {\n    textLength: text.length,\n    hasBrace: text.includes('{'),\n    preview: text.substring(0, 200),\n  });\n  throw new Error('Could not find a valid JSON object in the response.');\n}\n\n// ============================================================================\n// RETRY WITH BACKOFF\n// ============================================================================\n\n/**\n * Checks if an error is a transient (retryable) error\n * Transient errors include network errors and connection resets\n *\n * @param error - The error to check\n * @returns True if the error is transient\n */\nfunction isTransientError(error: unknown): boolean {\n  if (!isError(error)) return false;\n\n  if (error.name === 'TypeError' && error.message.includes('fetch')) return true;\n  if (error.name === 'NetworkError') return true;\n\n  if (isErrorWithCause(error)) {\n    const code = error.cause?.code;\n    if (code === 'ECONNRESET' || code === 'ECONNREFUSED') return true;\n  }\n\n  return false;\n}\n\n/**\n * Checks if an HTTP status code is retryable\n * Retryable statuses: 5xx, 408 (Request Timeout), 429 (Too Many Requests)\n *\n * @param status - HTTP status code\n * @returns True if the status is retryable\n */\nfunction isRetryableStatus(status: number): boolean {\n  return status >= 500 || status === 408 || status === 429;\n}\n\n/**\n * Type guard for objects with status property\n */\nfunction hasStatus(obj: unknown): obj is { status: number } {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    'status' in obj &&\n    typeof (obj as { status: unknown }).status === 'number'\n  );\n}\n\n/**\n * Retries an async function with exponential backoff and jitter\n *\n * @template T - Return type of the function\n * @param fn - Async function to retry\n * @param options - Retry configuration options\n * @returns Promise resolving to the function result\n * @throws The last error if all retries are exhausted\n *\n * @example\n * await retryWithBackoff(() => fetch('/api/data'), { maxRetries: 3 })\n *\n * @example\n * await retryWithBackoff(() => fetchData(), {\n *   maxRetries: 5,\n *   baseDelay: 2000,\n *   factor: 2,\n *   jitter: 0.3\n * })\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  options: RetryConfig = {}\n): Promise<T> {\n  const { maxRetries = 3, baseDelay = 1000, factor = 2, jitter = 0.5 } = options;\n\n  let lastError: unknown;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      const result = await fn();\n\n      // Check if result has retryable status\n      if (hasStatus(result) && isRetryableStatus(result.status)) {\n        throw new Error(`HTTP ${result.status}`);\n      }\n\n      return result;\n    } catch (error) {\n      lastError = error;\n\n      const hasErrorStatus =\n        isError(error) && typeof (error as unknown as { status?: unknown }).status === 'number';\n      const status = hasErrorStatus ? (error as unknown as { status: number }).status : null;\n      const isTransient = isTransientError(error) || (status !== null && isRetryableStatus(status));\n\n      if (attempt === maxRetries || !isTransient) {\n        throw lastError;\n      }\n\n      // Calculate delay with exponential backoff and jitter\n      const exponentialDelay = baseDelay * Math.pow(factor, attempt);\n      const jitterAmount = exponentialDelay * jitter * (Math.random() * 2 - 1);\n      const delay = exponentialDelay + jitterAmount;\n\n      await new Promise<void>((resolve) => setTimeout(resolve, Math.max(0, delay)));\n    }\n  }\n\n  throw lastError;\n}\n\n// ============================================================================\n// VALIDATION\n// ============================================================================\n\n/**\n * Logs validation errors\n *\n * @param message - Error message\n * @param details - Additional error details\n */\nfunction logError(message: string, details: LoggerContext = {}): void {\n  logger.error(`[Validation Error] ${message}`, details);\n}\n\n/**\n * Validates and sanitizes a value against a schema definition\n *\n * @template T - Expected type of the value\n * @param value - The value to validate\n * @param schema - Schema definition\n * @param fieldName - Name of the field being validated\n * @returns Validated and sanitized value\n */\nfunction validateValue<T>(value: unknown, schema: SchemaField<T>, fieldName: string): T {\n  // Handle missing/undefined values\n  if (value === undefined || value === null) {\n    if (schema.required) {\n      logError(`Missing required field: ${fieldName}`, { received: value });\n    }\n    return schema.default;\n  }\n\n  // Type validation and conversion\n  switch (schema.type) {\n    case 'string': {\n      if (typeof value !== 'string') {\n        logError(`Type mismatch for ${fieldName}: expected string`, {\n          received: typeof value,\n        });\n        return schema.default;\n      }\n      return value as T;\n    }\n\n    case 'number': {\n      let numValue: number;\n\n      if (typeof value !== 'number') {\n        const converted = Number(value);\n        if (isNaN(converted)) {\n          logError(`Type mismatch for ${fieldName}: expected number`, {\n            received: typeof value,\n          });\n          return schema.default;\n        }\n        numValue = converted;\n      } else {\n        numValue = value;\n      }\n\n      if (schema.validate && !schema.validate(numValue as unknown)) {\n        logError(`Validation failed for ${fieldName}`, { received: numValue });\n        return schema.default;\n      }\n\n      return numValue as T;\n    }\n\n    case 'array': {\n      if (!Array.isArray(value)) {\n        logError(`Type mismatch for ${fieldName}: expected array`, {\n          received: typeof value,\n        });\n        return schema.default;\n      }\n\n      return value as T;\n    }\n\n    case 'boolean': {\n      if (typeof value !== 'boolean') {\n        logError(`Type mismatch for ${fieldName}: expected boolean`, {\n          received: typeof value,\n        });\n        return schema.default;\n      }\n\n      return value as T;\n    }\n\n    default:\n      return schema.default;\n  }\n}\n\n/**\n * Type guard for parsed JSON object\n */\nfunction isJsonObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n/**\n * Validates an LLM response against the Tag schema\n * Handles JSON parsing errors, schema validation, and fallbacks\n *\n * @param response - Raw response (string or already parsed object)\n * @returns Validated response with fallback values\n *\n * @example\n * validateLLMResponse('{\"tags\": [\"work\", \"urgent\"], \"confidence\": 0.8}')\n * // Returns { tags: [\"work\", \"urgent\"], confidence: 0.8, reasoning: \"\" }\n *\n * @example\n * validateLLMResponse('Some text {\"tags\": [\"personal\"]} more text')\n * // Returns { tags: [\"personal\"], confidence: 0.5, reasoning: \"\" }\n *\n * @example\n * validateLLMResponse('invalid json')\n * // Returns { tags: [], confidence: 0.5, reasoning: \"\" }\n */\nexport function validateLLMResponse(response: unknown): TagResponse {\n  // Log raw response for debugging\n  logger.info('[LLM-RAW-RESPONSE] Raw LLM response:', {\n    type: typeof response,\n    preview:\n      typeof response === 'string'\n        ? response.substring(0, 500)\n        : JSON.stringify(response).substring(0, 500),\n    isNull: response === null,\n    isUndefined: response === undefined,\n    isEmpty: typeof response === 'string' && response.trim().length === 0,\n  });\n\n  let parsed: Record<string, unknown>;\n\n  // Parse JSON if response is a string\n  if (isString(response)) {\n    try {\n      // First try to extract JSON if it's embedded in text\n      const jsonText = extractJson(response);\n      parsed = JSON.parse(jsonText) as Record<string, unknown>;\n      logger.info('[LLM-PARSED-JSON] Parsed JSON (extracted):', {\n        keys: Object.keys(parsed),\n        hasTags: 'tags' in parsed,\n        hasConfidence: 'confidence' in parsed,\n        tagsValue: parsed.tags,\n        confidenceValue: parsed.confidence,\n      });\n    } catch (error) {\n      // Fallback: try parsing the whole string as JSON\n      try {\n        parsed = JSON.parse(response) as Record<string, unknown>;\n        logger.info('[LLM-PARSED-JSON] Parsed JSON (fallback):', {\n          keys: Object.keys(parsed),\n          hasTags: 'tags' in parsed,\n          hasConfidence: 'confidence' in parsed,\n          tagsValue: parsed.tags,\n          confidenceValue: parsed.confidence,\n        });\n      } catch (parseError) {\n        const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);\n        logError('Failed to parse JSON response', {\n          error: errorMessage,\n          response: response.substring(0, 200),\n        });\n        // Return fallback response\n        return {\n          tags: [],\n          confidence: 0.5,\n          confidence_score: 50,\n          reasoning: '',\n        };\n      }\n    }\n  } else if (isJsonObject(response)) {\n    parsed = response;\n    logger.info('[LLM-PARSED-JSON] Parsed JSON (object input):', {\n      keys: Object.keys(parsed),\n      hasTags: 'tags' in parsed,\n      hasConfidence: 'confidence' in parsed,\n      tagsValue: parsed.tags,\n      confidenceValue: parsed.confidence,\n    });\n  } else {\n    logError('Invalid response type', { type: typeof response });\n    return {\n      tags: [],\n      confidence: 0.5,\n      confidence_score: 50,\n      reasoning: '',\n    };\n  }\n\n  // Validate each field against schema\n  const validated = {} as TagResponse;\n  for (const [fieldName, schema] of Object.entries(TAG_RESPONSE_SCHEMA)) {\n    validated[fieldName as keyof TagResponse] = validateValue(\n      parsed[fieldName] as unknown,\n      schema,\n      fieldName\n    );\n  }\n\n  // Calculate confidence_score (0-100 scale) from confidence (0-1 scale)\n  validated.confidence_score = Math.round(validated.confidence * 100);\n\n  return validated;\n}\n\n// ============================================================================\n// APP CONFIG VALIDATION\n// ============================================================================\n\n/**\n * Type guard for checking if a value is a valid CustomTags array\n * @param value - Value to check\n * @returns True if value is a valid CustomTags array\n */\nfunction isCustomTags(value: unknown): value is CustomTags {\n  if (!Array.isArray(value)) return false;\n\n  for (const item of value) {\n    if (typeof item !== 'object' || item === null) return false;\n    const tag = item as Record<string, unknown>;\n\n    if (typeof tag.key !== 'string' || tag.key.trim().length === 0) return false;\n    if (typeof tag.name !== 'string' || tag.name.trim().length === 0) return false;\n    if (typeof tag.color !== 'string' || !/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(tag.color))\n      return false;\n    // prompt is optional\n  }\n\n  return true;\n}\n\n/**\n * Validates and sanitizes a partial AppConfig from storage\n * @param result - Storage result to validate\n * @returns Validated Partial<AppConfig> with fallback values for invalid fields\n */\nexport function validateAppConfig(result: Record<string, unknown>): Partial<AppConfig> {\n  const validated: Partial<AppConfig> = {};\n\n  // Validate provider (string, must be valid provider)\n  if (typeof result.provider === 'string') {\n    if (Object.values(Provider).includes(result.provider as Provider)) {\n      validated.provider = result.provider as Provider;\n    }\n  }\n\n  // Validate boolean fields\n  if (typeof result.enableNotifications === 'boolean') {\n    validated.enableNotifications = result.enableNotifications;\n  }\n  if (typeof result.enableLogging === 'boolean') {\n    validated.enableLogging = result.enableLogging;\n  }\n\n  // Validate API key fields (strings)\n  if (typeof result.openaiApiKey === 'string') {\n    validated.openaiApiKey = result.openaiApiKey;\n  }\n  if (typeof result.geminiApiKey === 'string') {\n    validated.geminiApiKey = result.geminiApiKey;\n  }\n  if (typeof result.claudeApiKey === 'string') {\n    validated.claudeApiKey = result.claudeApiKey;\n  }\n  if (typeof result.mistralApiKey === 'string') {\n    validated.mistralApiKey = result.mistralApiKey;\n  }\n  if (typeof result.deepseekApiKey === 'string') {\n    validated.deepseekApiKey = result.deepseekApiKey;\n  }\n  if (typeof result.zaiPaasApiKey === 'string') {\n    validated.zaiPaasApiKey = result.zaiPaasApiKey;\n  }\n  if (typeof result.zaiCodingApiKey === 'string') {\n    validated.zaiCodingApiKey = result.zaiCodingApiKey;\n  }\n\n  if (typeof result.ollamaApiUrl === 'string') {\n    validated.ollamaApiUrl = result.ollamaApiUrl;\n  }\n  if (typeof result.ollamaModel === 'string') {\n    validated.ollamaModel = result.ollamaModel;\n  }\n  if (typeof result.zaiPaasModel === 'string') {\n    validated.zaiPaasModel = result.zaiPaasModel;\n  }\n  if (typeof result.zaiCodingModel === 'string') {\n    validated.zaiCodingModel = result.zaiCodingModel;\n  }\n\n  // Validate customTags (array of Tag objects)\n  if (isCustomTags(result.customTags)) {\n    validated.customTags = result.customTags;\n  }\n\n  return validated;\n}\n\n/**\n * Validates customTags storage result\n * @param result - Storage result containing customTags\n * @returns Validated customTags or default if invalid\n */\nexport function validateCustomTagsResult(result: Record<string, unknown>): {\n  customTags: CustomTags;\n} {\n  if (isCustomTags(result.customTags)) {\n    return { customTags: result.customTags };\n  }\n\n  return { customTags: DEFAULT_CUSTOM_TAGS };\n}\n\n// ============================================================================\n// REQUEST BODY VALIDATION\n// ============================================================================\n\n/**\n * Validates that a value is a valid RequestBody (non-null object)\n * @param payload - Payload to validate\n * @returns Validated RequestBody\n * @throws {Error} If payload is invalid\n */\nexport function validateRequestBody(payload: unknown): RequestBody {\n  if (typeof payload !== 'object' || payload === null) {\n    throw new Error('RequestBody must be a non-null object');\n  }\n\n  return payload as Record<string, unknown>;\n}\n\n// ============================================================================\n// DEBOUNCE UTILITY\n// ============================================================================\n\n/**\n * Creates a debounced version of a function that delays invoking func until after wait milliseconds\n * have elapsed since the last time the debounced function was invoked.\n *\n * @template T - Function type to debounce\n * @param func - Function to debounce\n * @param wait - Delay in milliseconds\n * @returns Debounced function\n *\n * @example\n * const debouncedSearch = debounce((query: string) => searchAPI(query), 500);\n * inputElement.addEventListener('input', () => debouncedSearch(inputElement.value));\n */\nexport function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: number | null = null;\n\n  return function (this: any, ...args: Parameters<T>) {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n    timeout = window.setTimeout(() => func.apply(this, args), wait);\n  };\n}\n\n// ============================================================================\n// TYPE GUARDS FOR COMMON TYPES\n// ============================================================================\n\n/**\n * Type guard for BatchAnalysisProgress\n * @param value - Value to check\n * @returns True if value is a valid BatchAnalysisProgress\n */\nexport function isBatchAnalysisProgress(value: unknown): value is BatchAnalysisProgress {\n  if (typeof value !== 'object' || value === null) return false;\n\n  const obj = value as Record<string, unknown>;\n  const validStatuses = ['idle', 'running', 'completed', 'cancelled', 'error'];\n\n  return (\n    typeof obj.status === 'string' &&\n    validStatuses.includes(obj.status) &&\n    typeof obj.total === 'number' &&\n    typeof obj.processed === 'number' &&\n    typeof obj.successful === 'number' &&\n    typeof obj.failed === 'number' &&\n    typeof obj.startTime === 'number'\n  );\n}\n\n// Import BatchAnalysisProgress type for type guard\ntype BatchAnalysisProgress = {\n  status: 'idle' | 'running' | 'completed' | 'cancelled' | 'error';\n  total: number;\n  processed: number;\n  successful: number;\n  failed: number;\n  startTime: number;\n  endTime?: number;\n  errorMessage?: string;\n};\n",
        "last_modified": "2026-01-05T19:59:00.208594"
      },
      "task_intent": {
        "title": "Confidence Score Display and Threshold Configuration",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-05T14:48:03.155242",
  "last_updated": "2026-01-05T14:48:03.158689"
}