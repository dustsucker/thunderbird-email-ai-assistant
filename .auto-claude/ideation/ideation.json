{
  "id": "ideation-20251228-181508",
  "project_id": "/home/titus/Projects/thunderbird-email-ai-assistant",
  "config": {
    "enabled_types": [
      "code_improvements",
      "ui_ux_improvements",
      "security_hardening",
      "documentation_gaps",
      "performance_optimizations",
      "code_quality"
    ],
    "include_roadmap_context": true,
    "include_kanban_context": true,
    "max_ideas_per_type": 5
  },
  "ideas": [
    {
      "id": "ci-001",
      "type": "code_improvements",
      "title": "Add listModels() to All Provider Implementations",
      "description": "Extend the listModels() capability from OpenAIProvider to all other provider implementations (Claude, Mistral, Gemini, Deepseek) that support model listing APIs. This enables dynamic model discovery in the settings UI across all providers.",
      "rationale": "The pattern already exists in OpenAIProvider.listModels() which fetches available models from the API. The IProvider interface already has this as an optional method. The SettingsForm.populateModelsForProvider() infrastructure is ready to consume this data, but currently only works for providers that implement it.",
      "builds_upon": [
        "OpenAIProvider.listModels() implementation",
        "IProvider interface with optional listModels",
        "SettingsForm.populateModelsForProvider()"
      ],
      "estimated_effort": "small",
      "affected_files": [
        "src/infrastructure/providers/impl/ClaudeProvider.ts",
        "src/infrastructure/providers/impl/MistralProvider.ts",
        "src/infrastructure/providers/impl/GeminiProvider.ts",
        "src/infrastructure/providers/impl/DeepseekProvider.ts"
      ],
      "existing_patterns": [
        "OpenAIProvider.listModels() - fetch models list, return array of model IDs"
      ],
      "implementation_approach": "Follow OpenAIProvider.listModels() pattern: 1) Check for API key, 2) Call provider's models API endpoint (Claude: /v1/models, Mistral: /v1/models, etc.), 3) Parse response and return model ID array. Each provider has documented model listing endpoints that can be used.",
      "status": "draft",
      "created_at": "2025-12-28T18:15:00.000Z"
    },
    {
      "id": "ci-002",
      "type": "code_improvements",
      "title": "Add Cache Statistics Event",
      "description": "Add a new domain event CacheStatsEvent that is published when cache operations occur, enabling monitoring of cache hit rate and performance. This builds on the existing event system to provide observability into caching behavior.",
      "rationale": "The DomainEventBus pattern is established with create*Event factory functions (createEmailAnalyzedEvent, createProviderErrorEvent). The MemoryCache already tracks hitCount/missCount and has getStats(). Publishing events on cache hit/miss allows for analytics and debugging cache effectiveness.",
      "builds_upon": [
        "DomainEventBus event system",
        "MemoryCache.getStats() with hitRate tracking",
        "createEmailAnalyzedEvent pattern"
      ],
      "estimated_effort": "trivial",
      "affected_files": [
        "src/domain/events/CacheStatsEvent.ts",
        "src/domain/events/index.ts",
        "src/application/use-cases/AnalyzeEmail.ts"
      ],
      "existing_patterns": [
        "createEmailAnalyzedEvent() factory function pattern",
        "DomainEvent interface with eventType, occurredAt, aggregateId"
      ],
      "implementation_approach": "1) Create CacheStatsEvent.ts following EmailAnalyzedEvent pattern with cacheKey, isHit, and optional stats fields, 2) Export from events/index.ts, 3) Publish in AnalyzeEmail.checkCache() when cache hit/miss occurs, 4) Optionally subscribe in MessageHandler for logging/monitoring.",
      "status": "draft",
      "created_at": "2025-12-28T18:15:00.000Z"
    },
    {
      "id": "ci-003",
      "type": "code_improvements",
      "title": "Add Configurable Retry Settings Per Provider",
      "description": "Extend the provider configuration to allow customizable retry settings (maxRetries, baseDelay, factor) per provider through IConfigRepository, instead of using hardcoded DEFAULT_RETRY_CONFIG in BaseProvider.",
      "rationale": "BaseProvider has a retryConfig object that is currently hardcoded. Different providers may have different rate limits and reliability characteristics. IConfigRepository.IProviderSettings already has additionalConfig field for provider-specific settings. The pattern of loading configuration from ConfigRepository exists in AnalyzeBatchEmails.",
      "builds_upon": [
        "BaseProvider.retryConfig pattern",
        "IProviderSettings.additionalConfig field",
        "IConfigRepository configuration loading pattern"
      ],
      "estimated_effort": "small",
      "affected_files": [
        "src/infrastructure/providers/BaseProvider.ts",
        "src/infrastructure/interfaces/IConfigRepository.ts",
        "src/infrastructure/interfaces/IProvider.ts"
      ],
      "existing_patterns": [
        "IProviderSettings.additionalConfig for provider-specific settings",
        "AnalyzeBatchEmails.loadAppConfig() pattern for loading config"
      ],
      "implementation_approach": "1) Add optional retryConfig to IProviderSettings.additionalConfig, 2) Modify BaseProvider constructor to accept optional retryConfig, 3) In provider analyze(), merge default config with settings.additionalConfig.retryConfig if provided, 4) Add UI fields to SettingsForm for advanced retry configuration.",
      "status": "draft",
      "created_at": "2025-12-28T18:15:00.000Z"
    },
    {
      "id": "ci-004",
      "type": "code_improvements",
      "title": "Add Log Level Filtering to ConsoleLogger",
      "description": "Enhance ConsoleLogger to support configurable log level filtering (debug, info, warn, error) via IAppConfig, allowing users to control verbosity of logging output.",
      "rationale": "ConsoleLogger implements all log levels but always outputs everything. The IAppConfig.enableLogging boolean exists but is not used. Adding log level filtering follows the existing pattern of configurable behavior through IConfigRepository. This is valuable for debugging vs production use.",
      "builds_upon": [
        "ConsoleLogger with debug/info/warn/error methods",
        "IAppConfig.enableLogging setting",
        "IConfigRepository configuration pattern"
      ],
      "estimated_effort": "small",
      "affected_files": [
        "src/infrastructure/logger/ConsoleLogger.ts",
        "src/infrastructure/interfaces/ILogger.ts",
        "src/infrastructure/interfaces/IConfigRepository.ts"
      ],
      "existing_patterns": [
        "ConsoleLogger.formatMessage() pattern",
        "IAppConfig configuration pattern"
      ],
      "implementation_approach": "1) Add logLevel field to IAppConfig (enum: 'debug'|'info'|'warn'|'error'), 2) Inject IConfigRepository into ConsoleLogger (or pass level at construction), 3) Add level check before each log method outputs, 4) Add log level selector to options UI following existing form patterns.",
      "status": "draft",
      "created_at": "2025-12-28T18:15:00.000Z"
    },
    {
      "id": "ci-005",
      "type": "code_improvements",
      "title": "Add Batch Analysis Cache Stats to Progress",
      "description": "Extend BatchProgress interface to include cache statistics (cache hits, cache misses, hit rate) during batch analysis, providing visibility into how effective caching is for batch operations.",
      "rationale": "AnalyzeBatchEmails already tracks progress with BatchProgress interface. AnalyzeEmail tracks cache hits via fromCache flag in EmailAnalyzedEvent. The cache infrastructure (MemoryCache.getStats()) exists. Combining these provides valuable metrics for batch operations.",
      "builds_upon": [
        "BatchProgress interface in AnalyzeBatchEmails",
        "AnalyzeEmailResult.fromCache tracking",
        "MemoryCache.getStats() pattern"
      ],
      "estimated_effort": "trivial",
      "affected_files": [
        "src/application/use-cases/AnalyzeBatchEmails.ts"
      ],
      "existing_patterns": [
        "BatchProgress interface with processed/failed/percentage",
        "EmailAnalyzedEvent with fromCache metadata"
      ],
      "implementation_approach": "1) Add cacheHits and cacheMisses counters to AnalyzeBatchEmails private fields, 2) Extend BatchProgress interface with cacheHits, cacheMisses, and cacheHitRate, 3) In processQueueItem(), check if analysis was from cache and increment appropriate counter, 4) Return cache stats in getProgress().",
      "status": "draft",
      "created_at": "2025-12-28T18:15:00.000Z"
    },
    {
      "id": "uiux-001",
      "type": "ui_ux_improvements",
      "title": "Add focus states for keyboard navigation",
      "description": "Add visible focus indicators to all interactive elements (buttons, inputs, selects, tabs) for better keyboard navigation support",
      "rationale": "The current CSS has no :focus styles defined at all, making keyboard navigation nearly impossible for users who rely on it. This is a critical accessibility issue that affects users with motor disabilities or those who prefer keyboard navigation.",
      "category": "accessibility",
      "affected_components": [
        "options.css",
        "options.html"
      ],
      "screenshots": [],
      "current_state": "No focus indicators are visible when tabbing through interactive elements. Users cannot tell which element is currently focused when using keyboard navigation.",
      "proposed_change": "Add focus ring styles to options.css:\n\nbutton:focus,\ninput:focus,\nselect:focus,\ntextarea:focus,\n.tab-button:focus {\n  outline: 2px solid #007bff;\n  outline-offset: 2px;\n}\n\nbutton:focus:not(:focus-visible) {\n  outline: none;\n}\n\nbutton:focus-visible,\ninput:focus-visible,\nselect:focus-visible {\n  outline: 2px solid #007bff;\n  outline-offset: 2px;\n  box-shadow: 0 0 0 4px rgba(0, 123, 255, 0.25);\n}",
      "user_benefit": "Users who navigate with keyboard can clearly see which element is focused, making the interface fully accessible for keyboard-only navigation",
      "status": "draft",
      "created_at": "2025-12-28T18:12:00.000Z"
    },
    {
      "id": "uiux-002",
      "type": "ui_ux_improvements",
      "title": "Standardize UI language to English",
      "description": "Replace all German UI text with English equivalents for consistent international user experience",
      "rationale": "The interface mixes German and English text inconsistently (e.g., 'Analysiere alle E-Mails' vs 'Save General Settings', 'Fortschritt' vs 'Progress'). This creates confusion and reduces usability for international users.",
      "category": "usability",
      "affected_components": [
        "options.html",
        "src/interfaces/options/BatchAnalysisUI.ts",
        "src/interfaces/options/OptionsScript.ts"
      ],
      "screenshots": [],
      "current_state": "Mixed language UI:\n- Button: 'Analysiere alle E-Mails' (German)\n- Button: 'Save General Settings' (English)\n- Label: 'Fortschritt:' (German)\n- Status: 'Starte Batch-Analyse...' (German)\n- Help text: 'LLM-Antworten werden f\u00fcr 24 Stunden zwischengespeichert' (German)",
      "proposed_change": "Standardize all UI text to English:\n1. In options.html:\n   - 'Analysiere alle E-Mails' -> 'Analyze All Emails'\n   - 'Abbrechen' -> 'Cancel'\n   - 'Queue leeren' -> 'Clear Queue'\n   - 'Cache leeren' -> 'Clear Cache'\n   - 'Fortschritt:' -> 'Progress:'\n   - German help text -> English equivalents\n2. In BatchAnalysisUI.ts:\n   - Update all German status messages to English\n3. In OptionsScript.ts:\n   - Update German cache messages to English",
      "user_benefit": "Consistent English interface makes the extension accessible to international users and provides a more professional appearance",
      "status": "draft",
      "created_at": "2025-12-28T18:12:00.000Z"
    },
    {
      "id": "uiux-003",
      "type": "ui_ux_improvements",
      "title": "Fix mismatched form element IDs",
      "description": "Align HTML element IDs with the DOM selectors used in SettingsForm.ts to ensure form elements are found correctly",
      "rationale": "The HTML uses camelCase IDs (e.g., 'zaiPaasApiKey') while SettingsForm.ts tries to find kebab-case IDs (e.g., 'zai-paas-api-key'). This mismatch causes provider settings elements to not be found, breaking the save/load functionality for Zai providers.",
      "category": "usability",
      "affected_components": [
        "options.html",
        "src/interfaces/options/SettingsForm.ts"
      ],
      "screenshots": [],
      "current_state": "HTML has:\n- id='zaiPaasApiKey'\n- id='zaiPaasModel'\n- id='zaiPaasBaseUrl'\n- id='zaiCodingApiKey'\n- id='zaiCodingModel'\n- id='zaiCodingBaseUrl'\n\nSettingsForm.ts looks for:\n- 'zai-paas-api-key'\n- 'zai-paas-model'\n- 'zai-paas-base-url'\n- 'zai-coding-api-key'\n- 'zai-coding-model'\n- 'zai-coding-base-url'",
      "proposed_change": "Update options.html to use consistent kebab-case IDs matching SettingsForm.ts expectations:\n\n<!-- Zai PaaS Settings -->\n<input type='password' id='zai-paas-api-key' name='zai-paas-api-key'>\n<select id='zai-paas-model' name='zai-paas-model'></select>\n<input type='text' id='zai-paas-base-url' name='zai-paas-base-url'>\n\n<!-- Zai Coding Settings -->\n<input type='password' id='zai-coding-api-key' name='zai-coding-api-key'>\n<select id='zai-coding-model' name='zai-coding-model'></select>\n<input type='text' id='zai-coding-base-url' name='zai-coding-base-url'>",
      "user_benefit": "Zai provider configuration will work correctly - users can save and load their API keys and settings without errors",
      "status": "draft",
      "created_at": "2025-12-28T18:12:00.000Z"
    },
    {
      "id": "uiux-004",
      "type": "ui_ux_improvements",
      "title": "Add loading state to Save Settings button",
      "description": "Show visual loading feedback on the Save button during settings persistence to indicate the operation is in progress",
      "rationale": "When users click 'Save General Settings', there's no immediate visual feedback that the operation is processing. Users may click multiple times or think the extension is unresponsive. Adding a loading state improves perceived responsiveness.",
      "category": "performance",
      "affected_components": [
        "options.css",
        "src/interfaces/options/SettingsForm.ts"
      ],
      "screenshots": [],
      "current_state": "The Save button has no visual change during the save operation. Only after completion does a status message appear briefly. Users have no indication that saving is in progress.",
      "proposed_change": "1. Add CSS for loading state in options.css:\n\nbutton.loading {\n  position: relative;\n  color: transparent;\n  pointer-events: none;\n}\n\nbutton.loading::after {\n  content: '';\n  position: absolute;\n  width: 16px;\n  height: 16px;\n  top: 50%;\n  left: 50%;\n  margin-left: -8px;\n  margin-top: -8px;\n  border: 2px solid #ffffff;\n  border-radius: 50%;\n  border-top-color: transparent;\n  animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n  to { transform: rotate(360deg); }\n}\n\n2. Update SettingsForm.ts saveSettings():\n- Add 'loading' class to submit button before save\n- Remove 'loading' class after save completes",
      "user_benefit": "Users get immediate visual feedback that their settings are being saved, reducing uncertainty and preventing multiple clicks",
      "status": "draft",
      "created_at": "2025-12-28T18:12:00.000Z"
    },
    {
      "id": "uiux-005",
      "type": "ui_ux_improvements",
      "title": "Add visual required field indicators",
      "description": "Add asterisks and styling to indicate which form fields are required before submission",
      "rationale": "Required fields (API keys, model names) are not visually distinguished from optional fields. Users only discover requirements through validation errors after attempting to save, creating a frustrating trial-and-error experience.",
      "category": "usability",
      "affected_components": [
        "options.html",
        "options.css"
      ],
      "screenshots": [],
      "current_state": "All form labels look identical. Users cannot tell which fields are mandatory (API keys) vs optional (base URLs). The 'required' attribute exists on some inputs but has no visual indicator.",
      "proposed_change": "1. Add CSS for required field indicators:\n\nlabel.required::after {\n  content: ' *';\n  color: #dc3545;\n  font-weight: bold;\n}\n\n.required-note {\n  font-size: 12px;\n  color: #666;\n  margin-bottom: 15px;\n}\n\n2. Update options.html:\n- Add class='required' to labels for mandatory fields\n- Add note at form top: '<p class=\"required-note\">* Required fields</p>'\n\nExample:\n<label for='openai-api-key' class='required'>OpenAI API Key:</label>",
      "user_benefit": "Users can immediately identify which fields must be filled out, reducing form submission errors and improving task completion efficiency",
      "status": "draft",
      "created_at": "2025-12-28T18:12:00.000Z"
    },
    {
      "id": "sec-001",
      "type": "security_hardening",
      "title": "Fix HIGH Severity Vulnerabilities in Dependencies (node-forge, js-yaml)",
      "description": "npm audit reveals 4 vulnerabilities including HIGH severity issues in node-forge (ASN.1 Unbounded Recursion, Interpretation Conflict vulnerability, OID Integer Truncation) and MODERATE severity prototype pollution in js-yaml. These dependencies are used by web-ext and could potentially be exploited.",
      "rationale": "Known CVEs in dependencies create exploitable attack vectors. The node-forge vulnerabilities (CVSS 8.6) could allow attackers to manipulate ASN.1 data structures, potentially bypassing security controls. The js-yaml prototype pollution (CWE-1321) could lead to arbitrary code execution if YAML parsing is involved in processing untrusted input.",
      "category": "dependencies",
      "severity": "high",
      "affectedFiles": [
        "package.json",
        "package-lock.json"
      ],
      "vulnerability": "CVE: GHSA-554w-vpv2-vw27, GHSA-5gfm-wpxj-wjgq, GHSA-65ch-62r8-g69g, GHSA-mh29-5h37-fv8m",
      "currentRisk": "Attackers could exploit known vulnerabilities in transitive dependencies during development/build process or if these libraries are bundled into the extension",
      "remediation": "Run 'npm audit fix' to automatically update vulnerable packages. For packages that cannot be automatically fixed, review if updating web-ext to v8.10.0+ resolves the transitive dependencies. Consider using 'npm audit fix --force' with caution or manually updating dependencies.",
      "references": [
        "https://github.com/advisories/GHSA-554w-wpv2-vw27",
        "https://github.com/advisories/GHSA-5gfm-wpxj-wjgq",
        "https://github.com/advisories/GHSA-mh29-5h37-fv8m"
      ],
      "compliance": [
        "SOC2",
        "OWASP-A06"
      ]
    },
    {
      "id": "sec-002",
      "type": "security_hardening",
      "title": "Fix XSS Vulnerability in Tag Management UI (innerHTML with User Content)",
      "description": "The TagManagementUI.ts component uses innerHTML to render tag content including user-controlled 'tag.name' and 'tag.prompt' values without proper sanitization. While tag.color is validated with regex, the name and prompt fields are directly interpolated into HTML templates, creating a stored XSS vulnerability.",
      "rationale": "Stored XSS is a critical vulnerability allowing attackers to inject malicious scripts that execute in the context of other users. In a Thunderbird extension, this could lead to credential theft, email content exfiltration, or extension compromise. The code at line 361-376 in TagManagementUI.ts directly embeds user input into innerHTML.",
      "category": "input_validation",
      "severity": "high",
      "affectedFiles": [
        "src/interfaces/options/TagManagementUI.ts",
        "src/interfaces/options/SettingsForm.ts",
        "src/interfaces/options/OptionsScript.ts"
      ],
      "vulnerability": "CWE-79: Cross-site Scripting (Stored XSS)",
      "currentRisk": "Attacker-controlled tag names/prompts (e.g., '<img src=x onerror=alert(document.cookie)>') will execute JavaScript when displayed in the options page",
      "remediation": "Replace innerHTML with textContent for user-controlled values, or use DOMPurify to sanitize HTML content. Create DOM elements programmatically: const nameDiv = document.createElement('div'); nameDiv.textContent = tag.name; Alternatively, implement an escapeHtml() utility function that encodes < > \" ' & characters.",
      "references": [
        "https://owasp.org/www-community/attacks/xss/",
        "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html",
        "https://cwe.mitre.org/data/definitions/79.html"
      ],
      "compliance": [
        "OWASP-A03",
        "SOC2",
        "PCI-DSS"
      ]
    },
    {
      "id": "sec-003",
      "type": "security_hardening",
      "title": "Encrypt Sensitive API Keys at Rest in Browser Storage",
      "description": "API keys for multiple AI providers (OpenAI, Claude, Gemini, Mistral, Deepseek, ZAI) are stored in browser.storage.local as plaintext. While browser extension storage has some isolation, anyone with physical access to the browser profile or malware with extension access could read these credentials.",
      "rationale": "API keys provide access to paid AI services and could result in significant financial loss or abuse if compromised. Storing credentials in plaintext violates defense-in-depth principles. OWASP recommends encrypting sensitive data at rest.",
      "category": "secrets_management",
      "severity": "medium",
      "affectedFiles": [
        "src/infrastructure/repositories/IndexedDBConfigRepository.ts",
        "src/interfaces/options/SettingsForm.ts"
      ],
      "vulnerability": "CWE-312: Cleartext Storage of Sensitive Information",
      "currentRisk": "API keys can be extracted by anyone with access to the browser profile directory, or by other malicious extensions with storage access",
      "remediation": "Implement encryption for API keys before storing: 1) Use the Web Crypto API with a key derived from a user-provided password, or 2) Use the browser's credentials.store API if available, or 3) At minimum, obfuscate keys using reversible encoding. Consider implementing a 'master password' feature that encrypts/decrypts stored credentials on extension startup.",
      "references": [
        "https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto",
        "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html",
        "https://cwe.mitre.org/data/definitions/312.html"
      ],
      "compliance": [
        "OWASP-A02",
        "SOC2",
        "PCI-DSS"
      ]
    },
    {
      "id": "sec-004",
      "type": "security_hardening",
      "title": "Strengthen Content Security Policy and Reduce Extension Permissions",
      "description": "The manifest.json CSP includes 'unsafe-inline' for styles and the optional_permissions include overly broad patterns ('http://*/*', 'https://*/*') that allow the extension to request access to any web resource. The hardcoded Ollama localhost permission also poses local network risks.",
      "rationale": "Overly permissive CSP weakens protection against XSS attacks. Broad host permissions violate the principle of least privilege and increase attack surface. If the extension is compromised, attackers could communicate with any external server to exfiltrate data or receive commands.",
      "category": "configuration",
      "severity": "medium",
      "affectedFiles": [
        "manifest.json"
      ],
      "vulnerability": "CWE-1176: Ineffective Use of CSP, CWE-250: Execution with Unnecessary Privileges",
      "currentRisk": "Broad permissions could be abused by a compromised extension to exfiltrate email data to attacker-controlled servers. 'unsafe-inline' styles reduce XSS protection.",
      "remediation": "1) Remove 'unsafe-inline' from style-src by moving inline styles to external CSS files, 2) Replace wildcard optional_permissions with specific domains for known AI providers (api.openai.com, api.anthropic.com, etc.), 3) Consider dynamically requesting permissions only when the user selects a specific provider rather than requesting all permissions upfront, 4) Add strict CSP headers like 'upgrade-insecure-requests'.",
      "references": [
        "https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/permissions",
        "https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP",
        "https://owasp.org/www-community/attacks/Content_Security_Policy"
      ],
      "compliance": [
        "OWASP-A05",
        "SOC2"
      ]
    },
    {
      "id": "sec-005",
      "type": "security_hardening",
      "title": "Implement Consistent Log Sanitization Across All Loggers",
      "description": "The codebase has two logger implementations with inconsistent sanitization behavior. ProviderUtils.ts logger has comprehensive sanitizeContext() that masks sensitive fields recursively, but LegacyLogger.ts only has a standalone maskApiKey() method that requires manual invocation. Debug logs could leak API keys or sensitive email content.",
      "rationale": "Inconsistent logging practices can lead to accidental credential leakage in logs or error messages. This is particularly concerning since the extension processes email content which may contain PII. Logging of sensitive data violates GDPR and other privacy regulations.",
      "category": "data_protection",
      "severity": "low",
      "affectedFiles": [
        "src/infrastructure/logger/LegacyLogger.ts",
        "src/infrastructure/logger/ConsoleLogger.ts",
        "src/infrastructure/providers/ProviderUtils.ts",
        "test/e2e-real-provider.test.ts"
      ],
      "vulnerability": "CWE-532: Information Exposure Through Log Files",
      "currentRisk": "API keys or email content could be accidentally logged in development mode or when debug logging is enabled, potentially exposing sensitive data in browser console or log aggregation systems",
      "remediation": "1) Consolidate on a single logger implementation with automatic sanitization, 2) Apply sanitizeContext() in all logger formatMessage() methods, 3) Add email content (subject, body, from) to the sensitive field patterns, 4) Review test files to ensure they don't log full API keys (e2e-real-provider.test.ts logs first 8 chars which is acceptable), 5) Consider implementing a 'production mode' that disables debug-level logging entirely.",
      "references": [
        "https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html",
        "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/08-Test_for_Log_Exposure",
        "https://cwe.mitre.org/data/definitions/532.html"
      ],
      "compliance": [
        "OWASP-A09",
        "GDPR",
        "SOC2"
      ]
    },
    {
      "id": "doc-001",
      "type": "documentation_gaps",
      "title": "Create Architecture Documentation with Clean Architecture Diagram",
      "description": "The codebase follows a well-structured Clean Architecture pattern with domain/, application/, infrastructure/, and interfaces/ layers, but this architecture is not documented anywhere. The src/ directory has clear separation of concerns with domain entities, use cases, providers, and UI adapters, but developers need to reverse-engineer this structure from the code.",
      "rationale": "New contributors and maintainers need to understand the architectural decisions (dependency injection with TSyringe, event-driven patterns, provider abstraction) to contribute effectively. The project uses sophisticated patterns that aren't immediately obvious.",
      "category": "architecture",
      "targetAudience": "contributors",
      "affectedAreas": [
        "src/domain/",
        "src/application/",
        "src/infrastructure/",
        "src/interfaces/"
      ],
      "currentDocumentation": "Only README.md with usage instructions; no architecture documentation exists",
      "proposedContent": "Create docs/ARCHITECTURE.md with: 1) High-level diagram showing layers (domain, application, infrastructure, interfaces), 2) Data flow diagram for email analysis pipeline, 3) Dependency injection patterns and tokens, 4) Event bus system explanation, 5) Provider abstraction and factory pattern",
      "priority": "high",
      "estimatedEffort": "medium"
    },
    {
      "id": "doc-002",
      "type": "documentation_gaps",
      "title": "Add JSDoc Documentation to Provider Implementations",
      "description": "Provider implementations have inconsistent documentation. OllamaProvider.ts has only 1 documented method (listModels) out of 7, while other providers like ClaudeProvider, MistralProvider, GeminiProvider, OpenAIProvider, and DeepseekProvider follow similar patterns but lack comprehensive JSDoc comments explaining their configuration, API interaction, and error handling.",
      "rationale": "Providers are the core integration points with external AI services. Developers extending or debugging providers need to understand: required settings, API endpoints, request/response formats, error handling strategies, and rate limiting considerations.",
      "category": "api_docs",
      "targetAudience": "developers",
      "affectedAreas": [
        "src/infrastructure/providers/impl/OllamaProvider.ts",
        "src/infrastructure/providers/impl/ClaudeProvider.ts",
        "src/infrastructure/providers/impl/OpenAIProvider.ts",
        "src/infrastructure/providers/impl/MistralProvider.ts",
        "src/infrastructure/providers/impl/GeminiProvider.ts",
        "src/infrastructure/providers/impl/DeepseekProvider.ts"
      ],
      "currentDocumentation": "Only listModels() has JSDoc; other methods like validateSettings(), buildRequestBody(), parseResponse() are undocumented",
      "proposedContent": "Add JSDoc to all provider methods: 1) Class-level documentation explaining provider purpose and API requirements, 2) Method documentation with @param, @returns, @throws, 3) Configuration examples in @example blocks, 4) Document provider-specific quirks and requirements",
      "priority": "high",
      "estimatedEffort": "medium"
    },
    {
      "id": "doc-003",
      "type": "documentation_gaps",
      "title": "Create CONTRIBUTING.md with Provider Extension Guide",
      "description": "The project lacks contributing guidelines and documentation on how to extend the system. There's no guidance on: coding standards, PR requirements, testing expectations, or how to add new AI providers. The codebase supports 8 providers (OpenAI, Claude, Gemini, Mistral, Ollama, DeepSeek, ZAI-PaaS, ZAI-Coding) but adding new ones requires reading existing implementations.",
      "rationale": "Open source contributors and team members need clear guidance on contribution workflow. Adding new AI providers is a common extension point but currently requires reverse-engineering BaseProvider and provider registration patterns.",
      "category": "readme",
      "targetAudience": "contributors",
      "affectedAreas": [
        "src/infrastructure/providers/BaseProvider.ts",
        "src/infrastructure/providers/ProviderFactory.ts",
        "src/infrastructure/interfaces/IProvider.ts"
      ],
      "currentDocumentation": "No CONTRIBUTING.md exists; README only covers installation and usage",
      "proposedContent": "Create CONTRIBUTING.md with: 1) Development setup instructions, 2) Coding standards and linting rules, 3) Testing requirements (unit/e2e), 4) PR process and review expectations, 5) Step-by-step guide to add a new AI provider including: implementing BaseProvider, registering with ProviderFactory, adding settings UI, and writing tests",
      "priority": "high",
      "estimatedEffort": "medium"
    },
    {
      "id": "doc-004",
      "type": "documentation_gaps",
      "title": "Add Troubleshooting Section to README with Common Issues",
      "description": "The README lacks troubleshooting guidance for end users. The comprehensive troubleshooting section in docs/E2E-TESTING.md (written in German) covers testing issues but not common user-facing problems like: API connection failures, tag not appearing, permission errors, or extension not processing emails.",
      "rationale": "End users installing from Thunderbird Add-ons may encounter configuration issues. Common problems include: API key validation failures, permission requests being denied, emails not being tagged, and Ollama connection issues. Currently users must search issues or read source code.",
      "category": "troubleshooting",
      "targetAudience": "users",
      "affectedAreas": [
        "README.md"
      ],
      "currentDocumentation": "README has setup instructions but no troubleshooting; E2E-TESTING.md has testing troubleshooting only",
      "proposedContent": "Add README Troubleshooting section with: 1) 'Extension not tagging emails' - check provider settings, API key validity, 2) 'Permission denied' - explain permission request flow and origins, 3) 'Ollama not connecting' - localhost URL validation, CORS issues, 4) 'Tags not visible in Thunderbird' - tag sync and filter setup, 5) Debug mode and console logging instructions",
      "priority": "medium",
      "estimatedEffort": "low"
    },
    {
      "id": "doc-005",
      "type": "documentation_gaps",
      "title": "Document Test Helpers and Fixtures with Usage Examples",
      "description": "The test/ directory contains helper utilities (test-helpers.ts, fixture-loader.ts, MockProvider.ts) that lack JSDoc documentation. Functions like runTaggingTest(), expectValidResponse(), and loadEmailFixture() are used throughout tests but have no documentation explaining their purpose, parameters, or usage patterns.",
      "rationale": "Contributors writing new tests need to understand the testing infrastructure. The existing test helpers enable consistent testing patterns but their capabilities aren't documented. This leads to duplicated test code or inconsistent testing approaches.",
      "category": "api_docs",
      "targetAudience": "contributors",
      "affectedAreas": [
        "test/test-helpers.ts",
        "test/fixtures/fixture-loader.ts",
        "test/mocks/MockProvider.ts",
        "test/test-config.ts"
      ],
      "currentDocumentation": "No JSDoc on test utilities; only code inspection reveals usage patterns",
      "proposedContent": "Add JSDoc to test utilities: 1) test-helpers.ts - document runTaggingTest() params and return value, expectValidResponse() assertions, MOCK_SETTINGS usage, 2) fixture-loader.ts - document loadEmailFixture() and available fixtures, 3) MockProvider.ts - explain mock behavior and customization, 4) test-config.ts - document getTestConfig() and hasValidZaiConfig() for conditional E2E tests",
      "priority": "medium",
      "estimatedEffort": "low"
    },
    {
      "id": "perf-001",
      "type": "performance_optimizations",
      "title": "Replace SHA-256 cache key hashing with faster FNV-1a hash",
      "description": "The MemoryCache implementation uses SHA-256 (cryptographic hash) via Web Crypto API for hashing cache keys on every get/set/has/delete operation. SHA-256 is designed for security, not speed. Additionally, AnalyzeEmail.ts generates a SHA-256 cache key, which is then hashed again by MemoryCache - doubling the cryptographic overhead.",
      "rationale": "SHA-256 is ~100x slower than FNV-1a or djb2 string hashing. Every cache operation pays this cost. For cache keys, cryptographic security is unnecessary - we only need distribution. The double-hashing in AnalyzeEmail.ts + MemoryCache.ts means 2 SHA-256 operations per cache interaction.",
      "category": "runtime",
      "impact": "medium",
      "affectedAreas": [
        "src/infrastructure/cache/MemoryCache.ts",
        "src/application/use-cases/AnalyzeEmail.ts"
      ],
      "currentMetric": "~1-2ms per cache operation due to async SHA-256, plus promise overhead",
      "expectedImprovement": "~0.01ms per cache operation with synchronous FNV-1a hash, ~100x faster cache lookups",
      "implementation": "1. Replace async hashKey() with sync FNV-1a/djb2 string hash\n2. Remove the redundant sha256() call in AnalyzeEmail.ts - pass raw key to cache\n3. Convert cache methods from async to sync (optional, removes Promise overhead)\n4. Alternatively, if async is needed for interface compatibility, use the original key string directly",
      "tradeoffs": "FNV-1a has theoretically higher collision probability than SHA-256, but for cache keys with unique email content this is negligible. SHA-256 is overkill for non-security purposes.",
      "estimatedEffort": "small"
    },
    {
      "id": "perf-002",
      "type": "performance_optimizations",
      "title": "Replace array-sort PriorityQueue with binary heap implementation",
      "description": "The PriorityQueue implementation in src/application/services/PriorityQueue.ts calls array.sort() after every enqueue operation. This is O(n log n) per insertion. For batch email analysis with potentially hundreds of emails, this creates O(n^2 log n) total complexity.",
      "rationale": "A binary heap provides O(log n) insertion and O(log n) extraction. For a queue of 100 items, this is ~700 comparisons (heap) vs ~700 comparisons per insert = 70,000 total (array sort). The current implementation at line 79: `this.queue.sort((a, b) => b.priority - a.priority)` after every push is the bottleneck.",
      "category": "runtime",
      "impact": "medium",
      "affectedAreas": [
        "src/application/services/PriorityQueue.ts",
        "src/application/use-cases/AnalyzeBatchEmails.ts"
      ],
      "currentMetric": "O(n log n) per enqueue, O(n^2 log n) for batch of n emails",
      "expectedImprovement": "O(log n) per enqueue, O(n log n) for batch of n emails - ~100x faster for 100-email batches",
      "implementation": "1. Implement binary min-heap (inverted for max priority)\n2. Replace push+sort with siftUp operation\n3. Replace shift with siftDown operation\n4. Alternatively use a well-tested heap library like 'heap-js' (~2KB gzipped)",
      "tradeoffs": "Slightly more complex code. Binary heap is not stable (same-priority items may reorder), though this is unlikely to matter for email analysis.",
      "estimatedEffort": "small"
    },
    {
      "id": "perf-003",
      "type": "performance_optimizations",
      "title": "Replace RateLimiter polling with event-driven token availability",
      "description": "The RateLimiterService uses a polling loop with 100ms intervals (line 603-604: `setTimeout(r, 100)`) to wait for token availability. This wastes CPU cycles and adds up to 100ms latency per request when tokens are depleted.",
      "rationale": "The current implementation polls every 100ms: `while (!this.hasTokens(provider)) { await new Promise<void>((r) => setTimeout(r, 100)); }`. This is inefficient when many requests are queued. An event-driven approach using Promise resolution when tokens become available would eliminate polling overhead and reduce latency.",
      "category": "runtime",
      "impact": "medium",
      "affectedAreas": [
        "src/application/services/RateLimiterService.ts"
      ],
      "currentMetric": "Up to 100ms wasted latency per request, continuous CPU wake-ups during token depletion",
      "expectedImprovement": "Zero polling overhead, instant token acquisition when available, reduced battery drain on laptops",
      "implementation": "1. Maintain a waiting queue of Promise resolvers per provider\n2. When tokens are consumed, check if any requests are waiting\n3. When tokens are refilled (or request completes), resolve the next waiting Promise\n4. Replace polling loop with await on waiter Promise\n5. Similar to the existing semaphore implementation in acquireSemaphore()",
      "tradeoffs": "Slightly more complex state management. Need to handle edge cases when queue is cleared or service is reset.",
      "estimatedEffort": "medium"
    },
    {
      "id": "perf-004",
      "type": "performance_optimizations",
      "title": "Implement LRU eviction policy for unbounded MemoryCache",
      "description": "The MemoryCache has no size limit - it only evicts entries when they expire (24-hour TTL). For long-running Thunderbird sessions with many email analyses, the cache can grow unbounded, consuming excessive memory.",
      "rationale": "Each cached email analysis stores the full tag response. With thousands of emails over weeks of usage, memory usage can grow significantly. The cleanupExpired() method only removes expired entries but doesn't limit total cache size. An LRU policy would cap memory usage while keeping frequently accessed entries.",
      "category": "memory",
      "impact": "medium",
      "affectedAreas": [
        "src/infrastructure/cache/MemoryCache.ts",
        "src/infrastructure/interfaces/ICache.ts"
      ],
      "currentMetric": "Unbounded memory growth proportional to number of analyzed emails",
      "expectedImprovement": "Capped memory usage (e.g., 1000 entries max), automatic eviction of least-recently-used entries",
      "implementation": "1. Add maxSize parameter to MemoryCache constructor\n2. Track access order using a doubly-linked list or move-to-front on access\n3. Evict LRU entries when maxSize is exceeded\n4. Consider using Map's insertion-order iteration for simple LRU approximation\n5. Add periodic cleanup timer instead of relying on manual cleanupExpired() calls",
      "tradeoffs": "LRU tracking adds slight overhead per access. Need to choose appropriate maxSize for balance between hit rate and memory usage.",
      "estimatedEffort": "medium"
    },
    {
      "id": "perf-005",
      "type": "performance_optimizations",
      "title": "Cache html-to-text conversion results for repeated email access",
      "description": "The EmailContentExtractor converts HTML to plain text synchronously using htmlToText() on every email access. For emails that are re-analyzed or accessed multiple times, this conversion is repeated unnecessarily.",
      "rationale": "HTML-to-text conversion (src/domain/services/EmailContentExtractor.ts line 45, 121-123) is CPU-intensive for large HTML emails. The conversion result could be cached since email content doesn't change. This is especially beneficial for batch re-analysis scenarios.",
      "category": "runtime",
      "impact": "low",
      "affectedAreas": [
        "src/domain/services/EmailContentExtractor.ts"
      ],
      "currentMetric": "Full HTML parsing on every email content extraction",
      "expectedImprovement": "Instant text retrieval for previously converted emails, reduced CPU usage during batch operations",
      "implementation": "1. Add a content cache keyed by message ID or HTML content hash\n2. Check cache before calling htmlToText()\n3. Store converted text in cache with appropriate TTL\n4. Consider using WeakMap if message objects are available for automatic cleanup",
      "tradeoffs": "Additional memory usage for cached text. Need to invalidate cache if email content could theoretically change (rare in email context).",
      "estimatedEffort": "small"
    },
    {
      "id": "cq-001",
      "type": "code_quality",
      "title": "Split ProviderUtils.ts into focused utility modules",
      "description": "The file src/infrastructure/providers/ProviderUtils.ts has grown to 956 lines and handles multiple unrelated concerns: logging utilities, error handling, JSON extraction, retry logic, validation schemas, type guards, and config validation. This monolithic utility file violates the Single Responsibility Principle.",
      "rationale": "Large utility files increase cognitive load, make testing harder, and lead to tight coupling. When one utility changes, the entire file must be re-tested. Splitting into focused modules improves maintainability, testability, and allows for better tree-shaking.",
      "category": "large_files",
      "severity": "major",
      "affectedFiles": [
        "src/infrastructure/providers/ProviderUtils.ts"
      ],
      "currentState": "Single 956-line file handling: Logger implementation (~80 lines), error display helpers (~120 lines), JSON extraction (~50 lines), retry with backoff (~150 lines), validation schema and utilities (~200 lines), app config validation (~100 lines), debounce (~25 lines), and type guards (~50 lines)",
      "proposedChange": "Split into focused modules:\n- src/infrastructure/utils/logger.ts (logger implementation)\n- src/infrastructure/utils/errorHandler.ts (error display helpers)\n- src/infrastructure/utils/jsonUtils.ts (JSON extraction)\n- src/infrastructure/utils/retryUtils.ts (retry with backoff)\n- src/infrastructure/utils/validation.ts (validation schema utilities)\n- src/infrastructure/utils/typeGuards.ts (common type guards)\n\nMaintain a barrel export in ProviderUtils.ts for backwards compatibility.",
      "codeExample": "// Current (all in ProviderUtils.ts):\nexport function maskApiKey() { ... }\nexport const logger: Logger = { ... }\nexport function logAndDisplayError() { ... }\nexport function extractJson() { ... }\nexport async function retryWithBackoff() { ... }\nexport function validateLLMResponse() { ... }\n\n// Proposed structure:\n// logger.ts\nexport const logger: Logger = { ... };\n\n// retryUtils.ts\nexport async function retryWithBackoff<T>() { ... };\n\n// index.ts (barrel)\nexport * from './logger';\nexport * from './retryUtils';",
      "bestPractice": "Single Responsibility Principle - each module should have one well-defined purpose",
      "metrics": {
        "lineCount": 956,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "medium",
      "breakingChange": false,
      "prerequisites": [
        "Add unit tests for each utility function before refactoring"
      ]
    },
    {
      "id": "cq-002",
      "type": "code_quality",
      "title": "Extract shared listModels logic from provider implementations",
      "description": "The listModels method is nearly identical across OpenAIProvider, ClaudeProvider, GeminiProvider, and other provider implementations. Each provider has 40-50 lines of duplicated logic for fetching models, handling errors, and parsing responses with only minor variations in URL and headers.",
      "rationale": "Code duplication leads to inconsistent bug fixes and increased maintenance burden. When the model fetching logic needs to change, it must be updated in 8+ places. A shared abstraction would centralize this logic.",
      "category": "duplication",
      "severity": "minor",
      "affectedFiles": [
        "src/infrastructure/providers/impl/OpenAIProvider.ts",
        "src/infrastructure/providers/impl/ClaudeProvider.ts",
        "src/infrastructure/providers/impl/GeminiProvider.ts",
        "src/infrastructure/providers/impl/MistralProvider.ts",
        "src/infrastructure/providers/impl/DeepseekProvider.ts",
        "src/infrastructure/providers/impl/OllamaProvider.ts",
        "src/infrastructure/providers/impl/ZaiPaaSProvider.ts",
        "src/infrastructure/providers/impl/ZaiCodingProvider.ts"
      ],
      "currentState": "Each provider implements listModels with:\n1. API key validation\n2. Fetch request with provider-specific URL and headers\n3. Response status check\n4. JSON parsing\n5. Data extraction with type guards\n6. Error logging",
      "proposedChange": "Add a shared fetchModels utility to BaseProvider or create a ModelsFetcher utility class:\n\n1. Define a ModelListConfig interface for provider-specific configuration\n2. Implement fetchModels in BaseProvider that accepts config\n3. Each provider only needs to provide the config (URL builder, headers, response parser)",
      "codeExample": "// Current (repeated in each provider):\npublic async listModels(settings: BaseProviderSettings): Promise<string[]> {\n  try {\n    const apiKey = settings.apiKey;\n    if (!apiKey) {\n      this.logger.error('Provider listModels: API key is missing');\n      return [];\n    }\n    const response = await fetch(url, { headers: {...} });\n    // ... same pattern in each provider\n  }\n}\n\n// Proposed:\n// BaseProvider.ts\nprotected async fetchModels(\n  settings: BaseProviderSettings,\n  config: ModelFetchConfig\n): Promise<string[]> {\n  // Shared implementation\n}\n\n// OpenAIProvider.ts\npublic async listModels(settings: BaseProviderSettings): Promise<string[]> {\n  return this.fetchModels(settings, {\n    url: 'https://api.openai.com/v1/models',\n    headerBuilder: (key) => ({ Authorization: `Bearer ${key}` }),\n    responseParser: (data) => data.data.map(m => m.id)\n  });\n}",
      "bestPractice": "DRY (Don't Repeat Yourself) - extract common logic into reusable abstractions",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": 320,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": null
    },
    {
      "id": "cq-003",
      "type": "code_quality",
      "title": "Refactor SettingsForm.ts repetitive switch cases into provider registry pattern",
      "description": "SettingsForm.ts (895 lines) contains multiple switch statements that repeat the same provider cases: loadSettings, gatherProviderSettings, validateProviderSettings, getProviderSettings, hasRequiredCredentials, convertToProviderSettings, and getPermissionOrigin. Each switch has 8 cases with similar patterns.",
      "rationale": "Repetitive switch statements are a code smell indicating the need for polymorphism or a registry pattern. Adding a new provider requires modifying 7+ switch statements, which is error-prone and violates the Open-Closed Principle.",
      "category": "code_smells",
      "severity": "major",
      "affectedFiles": [
        "src/interfaces/options/SettingsForm.ts"
      ],
      "currentState": "7 switch statements, each with 8 provider cases:\n- loadSettings: populates form fields per provider\n- gatherProviderSettings: collects form values per provider\n- validateProviderSettings: validates required fields per provider\n- getProviderSettings: extracts settings from UI per provider\n- hasRequiredCredentials: checks credentials per provider\n- convertToProviderSettings: converts config per provider\n- getPermissionOrigin: returns API origin per provider",
      "proposedChange": "Implement a ProviderFormConfig registry:\n\n1. Create ProviderFormConfig interface defining form field mappings\n2. Create a registry map: Record<ProviderId, ProviderFormConfig>\n3. Replace switch statements with registry lookups\n4. New providers only need to add one registry entry",
      "codeExample": "// Current (repeated switch pattern):\nswitch (provider) {\n  case 'openai':\n    if (!this.elements.openaiApiKey) throw new Error(...);\n    return { ...baseSettings, openaiApiKey: this.elements.openaiApiKey.value.trim() };\n  case 'gemini':\n    if (!this.elements.geminiApiKey) throw new Error(...);\n    return { ...baseSettings, geminiApiKey: this.elements.geminiApiKey.value.trim() };\n  // ... 6 more cases\n}\n\n// Proposed registry pattern:\ninterface ProviderFormConfig {\n  elementIds: { apiKey?: string; apiUrl?: string; model?: string };\n  permissionOrigin: string;\n  defaultModel: string;\n  validate: (settings: PartialProviderConfig) => boolean;\n}\n\nconst PROVIDER_CONFIGS: Record<string, ProviderFormConfig> = {\n  openai: {\n    elementIds: { apiKey: 'openai-api-key' },\n    permissionOrigin: 'https://api.openai.com/',\n    defaultModel: 'gpt-4o-mini',\n    validate: (s) => !!s.openaiApiKey?.trim()\n  },\n  // ... other providers\n};\n\n// Usage:\nconst config = PROVIDER_CONFIGS[provider];\nif (!config) throw new Error(`Unknown provider: ${provider}`);\nreturn this.gatherFromConfig(config, baseSettings);",
      "bestPractice": "Replace conditional logic with polymorphism or configuration objects to follow Open-Closed Principle",
      "metrics": {
        "lineCount": 895,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "medium",
      "breakingChange": false,
      "prerequisites": [
        "Add unit tests for SettingsForm before refactoring"
      ]
    },
    {
      "id": "cq-004",
      "type": "code_quality",
      "title": "Add type declarations for Thunderbird WebExtension APIs",
      "description": "The codebase has 19 @ts-expect-error comments primarily in MessageHandler.ts (10) and EmailEventListener.ts (7) to suppress TypeScript errors when accessing global browser/messenger WebExtension APIs. This reduces type safety and makes the code harder to maintain.",
      "rationale": "Excessive @ts-expect-error comments indicate missing type definitions. Proper type declarations would enable IDE autocompletion, catch errors at compile time, and improve code documentation. The Thunderbird API surface is well-defined and could be typed.",
      "category": "types",
      "severity": "minor",
      "affectedFiles": [
        "src/interfaces/background/MessageHandler.ts",
        "src/interfaces/background/EmailEventListener.ts",
        "src/infrastructure/providers/ProviderUtils.ts"
      ],
      "currentState": "19 @ts-expect-error comments suppressing type errors for:\n- browser.runtime.onMessage\n- browser.runtime.sendMessage\n- messenger.runtime.onMessage\n- messenger.messages.list\n- messenger.storage.local\n\nEach usage requires a comment explaining why the error is suppressed.",
      "proposedChange": "Create Thunderbird WebExtension API type declarations:\n\n1. Create src/types/thunderbird.d.ts with type definitions for messenger API\n2. Extend @types/webextension-polyfill for any Thunderbird-specific APIs\n3. Add global type declarations for browser and messenger objects\n4. Remove @ts-expect-error comments and use proper typing",
      "codeExample": "// Current:\n// @ts-expect-error - browser is a global WebExtension API\nif (typeof browser !== 'undefined' && browser.runtime?.onMessage) {\n  // @ts-expect-error - browser.runtime.onMessage is a WebExtension API\n  browser.runtime.onMessage.addListener(this.handleMessageHandler);\n}\n\n// Proposed (src/types/thunderbird.d.ts):\ndeclare global {\n  const messenger: {\n    runtime: {\n      onMessage: WebExtensionEvent<MessageListener>;\n      sendMessage: (message: RuntimeMessage) => Promise<unknown>;\n    };\n    messages: {\n      list(folderId?: string): Promise<MessageList>;\n      getFull(messageId: number): Promise<MessagePart>;\n    };\n    storage: {\n      local: StorageArea;\n    };\n  };\n}\n\n// Usage (no @ts-expect-error needed):\nif (typeof messenger !== 'undefined' && messenger.runtime?.onMessage) {\n  messenger.runtime.onMessage.addListener(this.handleMessageHandler);\n}",
      "bestPractice": "Use TypeScript declaration files (.d.ts) for external/global APIs instead of type suppression comments",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": null
    },
    {
      "id": "cq-005",
      "type": "code_quality",
      "title": "Extract MessageHandler type guards into shared utilities",
      "description": "MessageHandler.ts contains 7 nearly identical type guard functions (isStartBatchAnalysisMessage, isGetBatchProgressMessage, isCancelBatchAnalysisMessage, etc.) that follow the exact same pattern. Each guard checks if value is an object with a specific 'action' string property.",
      "rationale": "Repetitive type guards bloat the file and increase maintenance burden. A generic type guard factory would reduce code duplication, ensure consistency, and make adding new message types trivial.",
      "category": "duplication",
      "severity": "minor",
      "affectedFiles": [
        "src/interfaces/background/MessageHandler.ts"
      ],
      "currentState": "7 type guard functions, each 7-8 lines with identical structure:\n```typescript\nfunction isXxxMessage(message: unknown): message is XxxMessage {\n  return (\n    typeof message === 'object' &&\n    message !== null &&\n    'action' in message &&\n    (message as Record<string, unknown>).action === 'xxx'\n  );\n}\n```",
      "proposedChange": "Create a generic type guard factory function:\n\n1. Define createMessageTypeGuard<T>(action: string) utility\n2. Replace individual guards with factory calls\n3. Optionally add additional property checks via options parameter",
      "codeExample": "// Current (repeated 7 times with different action values):\nfunction isStartBatchAnalysisMessage(message: unknown): message is StartBatchAnalysisMessage {\n  return (\n    typeof message === 'object' &&\n    message !== null &&\n    'action' in message &&\n    (message as Record<string, unknown>).action === 'startBatchAnalysis'\n  );\n}\n\nfunction isGetBatchProgressMessage(message: unknown): message is GetBatchProgressMessage {\n  return (\n    typeof message === 'object' &&\n    message !== null &&\n    'action' in message &&\n    (message as Record<string, unknown>).action === 'getBatchProgress'\n  );\n}\n\n// Proposed:\nfunction createMessageGuard<T extends { action: string }>(\n  actionName: T['action']\n): (message: unknown) => message is T {\n  return (message: unknown): message is T => \n    typeof message === 'object' &&\n    message !== null &&\n    'action' in message &&\n    (message as Record<string, unknown>).action === actionName;\n}\n\n// Usage:\nconst isStartBatchAnalysisMessage = createMessageGuard<StartBatchAnalysisMessage>('startBatchAnalysis');\nconst isGetBatchProgressMessage = createMessageGuard<GetBatchProgressMessage>('getBatchProgress');\nconst isCancelBatchAnalysisMessage = createMessageGuard<CancelBatchAnalysisMessage>('cancelBatchAnalysis');\n// ... etc.",
      "bestPractice": "Use factory functions to eliminate repetitive boilerplate code",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": 56,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": null
    }
  ],
  "project_context": {
    "existing_features": [],
    "tech_stack": [
      "TypeScript"
    ],
    "target_audience": null,
    "planned_features": [
      "Specification: Fix Provider Setup with Dynamic Settings"
    ]
  },
  "summary": {
    "total_ideas": 30,
    "by_type": {
      "code_improvements": 5,
      "ui_ux_improvements": 5,
      "security_hardening": 5,
      "documentation_gaps": 5,
      "performance_optimizations": 5,
      "code_quality": 5
    },
    "by_status": {
      "draft": 30
    }
  },
  "generated_at": "2025-12-28T18:15:08.612148",
  "updated_at": "2025-12-28T18:15:08.612161"
}